[{"id":0,"href":"/microservices-datadriven/spring/observability/tracing/","title":"Jaeger Tracing","parent":"Observability","content":"Jaeger is a distributed tracing system used for monitoring and troubleshooting microservices. For more information on Jaeger, see the Jaeger website.\nView application traces in Jaeger web user interface Exposing Jaeger web user interface using port-forward\nkubectl -n observability port-forward svc/jaegertracing-query 16686:16686 Open the Jaeger web user interface URL: http://localhost:16686\nJaeger UI In the Jaeger web user interface, the Search Tab allows you find tracings using various criteria. For example, to find traces for the customer microservice included in the sample apps:\nIf you deployed the sample apps, exposed the customer service through the APISIX Gateway and called it at least once, you will be able to find traces for it in Jaeger.\nSelect Service customer and Operation /api/v1/customers\nClick on the search button \u0026ndash; Several traces will appear (one for each time you invoked the service)\nJaeger Customer Tracing Click on any one of them to view the trace that include multiple services and extends into the Oracle database and Oracle Advanced Queueing:\nJaeger Customer Tracing Details ","description":"Jaeger is a distributed tracing system used for monitoring and troubleshooting microservices. For more information on Jaeger, see the Jaeger website.\nView application traces in Jaeger web user interface Exposing Jaeger web user interface using port-forward\nkubectl -n observability port-forward svc/jaegertracing-query 16686:16686 Open the Jaeger web user interface URL: http://localhost:16686\nJaeger UI In the Jaeger web user interface, the Search Tab allows you find tracings using various criteria. For example, to find traces for the customer microservice included in the sample apps:"},{"id":1,"href":"/microservices-datadriven/spring/development/","title":"Development","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"","description":""},{"id":2,"href":"/microservices-datadriven/spring/release-notes/","title":"Release Notes","parent":"Oracle Backend for Spring Boot - Developer Preview","content":" Developer Preview 0.1.0, January 30, 2023 The following components were added:\nComponent Version Description HashiCorp Vault v1.11.3 Provides a way of store and tightly control access to sensitive data Oracle Backend for Spring Boot CLI 0.1.0 Command line tool to manage application deployment and configuration Netflix Conductor OSS 3.13.2 Workflow orchestration for microservices There were no deprecations or removals.\nDeveloper Preview 0.0.1, December 20, 2022 This release includes the following components:\nComponent Version Description cert-manager 1.10.1 Automates the management of certificates. NGINX Ingress Controller 1.5.1 Traffic management solution for cloud‑native applications in Kubernetes. Prometheus 2.40.2 Provides event monitoring and alerting. Prometheus Operator 0.60.1 Provides management for Prometheus monitoring tools. OpenTelemetry Collector 0.66.0 Collects process and export telemetry data. Grafana 9.2.5 Tool to help you examine, analyze, and monitor metrics. Jaeger Tracing 1.37.0 Distributed tracing system for monitoring and troubleshooting distributed systems. APISIX 2.15.1 Provides full lifecycle API Management. Spring Admin Server 2.7.5 Managing and monitoring Spring Boot applications. Spring Cloud Config Server 2.7.5 Provides server-side support for externalized configuration. Eureka Service Registry 2021.0.3 Provides Service Discovery capabilities HashiCorp Vault v1.11.3 Provides a way of store and tightly control access to sensitive data ","description":"Developer Preview 0.1.0, January 30, 2023 The following components were added:\nComponent Version Description HashiCorp Vault v1.11.3 Provides a way of store and tightly control access to sensitive data Oracle Backend for Spring Boot CLI 0.1.0 Command line tool to manage application deployment and configuration Netflix Conductor OSS 3.13.2 Workflow orchestration for microservices There were no deprecations or removals.\nDeveloper Preview 0.0.1, December 20, 2022 This release includes the following components:"},{"id":3,"href":"/microservices-datadriven/spring/security/","title":"Security","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot has the following security characteristics:\nAll access to the database is done using Mutual TLS (Database Wallet). The username, password and URI are stored in Kubernetes secrets.\nAccessing the dashboards can only be done using port forwarding.\nThe only \u0026ldquo;public\u0026rdquo; exposure is the APISIX Gateway (note that the dashboard is not exposed publicly).\nServices deployed to the platform are not exposed through the gateway automatically.\nThe deployed platform services are using using self-signed certificates.\nA customer application can only access service running in the platform via the APISIX Gateway. The IP address for the gateway can be determined by executing the following command:\nkubectl -n ingress-nginx get svc ingress-nginx-controller The customer application can be secured using Spring Security, e.g., Spring OAuth 2.0 Resource Server. An external authorization server is recommended (for example Okta, Oauth0)\nThe diagram below provides an overview of the security architecture.\n","description":"The Oracle Backend for Spring Boot has the following security characteristics:\nAll access to the database is done using Mutual TLS (Database Wallet). The username, password and URI are stored in Kubernetes secrets.\nAccessing the dashboards can only be done using port forwarding.\nThe only \u0026ldquo;public\u0026rdquo; exposure is the APISIX Gateway (note that the dashboard is not exposed publicly).\nServices deployed to the platform are not exposed through the gateway automatically."},{"id":4,"href":"/microservices-datadriven/spring/cluster-access/","title":"Access Kubernetes Cluster","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot setup creates a Kubernetes cluster where the server and dashboard components are deployed. At the end of setup, in the log for the apply job, you were provided with a command to creating a Kubernetes configuration file to access that cluster.\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the OCI documentation. kubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; Note: The generated kubeconfig file will only work if you are using the DEFAULT profile in your OCI CLI configuration file. If you are using a different OCI CLI profile you must add --profile \u0026lt;PROFILE-NAME\u0026gt; to the command. For example:\nkubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; --profile \u0026lt;PROFILE-NAME\u0026gt; You must also edit the the generated Kubernetes config file and add the following lines to the config file. For example:\n- --profile - \u0026lt;PROFILE-NAME\u0026gt; For example:\n- name: user-xxxx user: exec: apiVersion: client.authentication.k8s.io/v1beta1 args: - ce - cluster - generate-token - --cluster-id - ocid1.cluster....xxxx - --region - us-ashburn-1 - --profile - \u0026lt;PROFILE-NAME\u0026gt; command: oci Using OCI Cloud Shell A simple alternative is to use the OCI Cloud Shell, which is provided in the OCI Console. You can open Cloud Shell by clicking Developer Tools in the upper right hand corner of the OCI Console.\nOCI Cloud Shell icon Run the provided command to create your Kubernetes configuration file and then you will be able to access the Kubernetes cluster. For example, you can list the pods in your cluster:\nWelcome to Oracle Cloud Shell. Update: Cloud Shell will now use Oracle JDK 11 by default. To change this, see Managing Language Runtimes in the Cloud Shell documentation. Your Cloud Shell machine comes with 5GB of storage for your home directory. Your Cloud Shell (machine and home directory) are located in: US East (Ashburn). You are using Cloud Shell in tenancy xxxx as an OCI user xxxx Type `help` for more info. user@cloudshell:~ (us-ashburn-1)$ oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT Existing Kubeconfig file found at /home/user/.kube/config and new config merged into it user@cloudshell:~ (us-ashburn-1)$ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE ingress-nginx ingress-nginx-controller-7d45557d5c-bqwwp 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-klgnb 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-l4d2m 1/1 Running 0 4h18m kube-system coredns-746957c9c6-hwnm8 1/1 Running 0 4h27m kube-system csi-oci-node-kqf5x 1/1 Running 0 4h23m kube-system kube-dns-autoscaler-6f789cfb88-7mptd 1/1 Running 0 4h27m kube-system kube-flannel-ds-hb6ld 1/1 Running 1 (4h22m ago) 4h23m kube-system kube-proxy-v5qwm 1/1 Running 0 4h23m kube-system proxymux-client-vpnh7 1/1 Running 0 4h23m ......... user@cloudshell:~ (us-ashburn-1)$ ","description":"The Oracle Backend for Spring Boot setup creates a Kubernetes cluster where the server and dashboard components are deployed. At the end of setup, in the log for the apply job, you were provided with a command to creating a Kubernetes configuration file to access that cluster.\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the OCI documentation. kubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1."},{"id":5,"href":"/microservices-datadriven/spring/platform/apigw/","title":"API Gateway","parent":"Platform","content":"Apache APISIX is an open-source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nDeploy and Secure Sample Apps APIs using APISIX Oracle Backend for Spring Boot deploys APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the APISIX Dashboard, you must use kubectl port-forward to create a secure channel to service/apisix-dashboard.\nkubectl --namespace apisix get all APISIX K8s Exposing APISIX Dashboard using port-forward\nkubectl port-forward -n apisix svc/apisix-dashboard 8080:80 Open the APISIX Dashboard URL: http://localhost:8080\nusername: admin password: admin Note: Oracle recommends that you change the default password when you first login. Even though the dashboard is not accessible externally, we still recommend using strong passwords to maximize security.\nAPISIX Login Exposing a Spring application through the API Gateway and Load Balancer Once you have your application deployed and running, you may want to expose it to the outside world. Some applications may not need to be exposed if they are only called by other applications in the platform. To expose your application, you create a \u0026ldquo;route\u0026rdquo; in the APISIX API Gateway.\nCreate a Route to the Service\nIn the APISIX Dashboard, click on the \u0026ldquo;Routes\u0026rdquo; option in the menu on the left hand side.\nAPISIX Routes Click on the \u0026ldquo;Create\u0026rdquo; button to create a new route.\nFill out the necessary details (anything not mentioned here can be left at the default value). For example, for the \u0026ldquo;slow service\u0026rdquo; included in the sample apps:\nname = slow path = /fruit* method = get, options upstream type = service discovery discovery type = eureka service name = SLOW (note that this is case sensitive, this is the key from the Eureka dashboard) APISIX Routes Step1 APISIX Routes Step2 APISIX Routes Step3 Save the route you created.\nAPISIX Routes Step4 APISIX Routes Step5 Test a Route to the Service\nGet the APISIX Gateway External IP using this command:\nkubectl -n ingress-nginx get svc ingress-nginx-controller Call API using APISIX Gateway address plus path:\ncurl http://APISIX_IP/fruit You should get \u0026ldquo;banana\u0026rdquo; or \u0026ldquo;fallback fruit is apple\u0026rdquo; back as the response.\n","description":"Apache APISIX is an open-source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nDeploy and Secure Sample Apps APIs using APISIX Oracle Backend for Spring Boot deploys APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the APISIX Dashboard, you must use kubectl port-forward to create a secure channel to service/apisix-dashboard."},{"id":6,"href":"/microservices-datadriven/spring/platform/config/","title":"Configuration","parent":"Platform","content":"Oracle Backend for Spring Boot includes the Spring Config which provides server and client-side support for externalized configuration in a distributed system. The Spring Config Server provides a central place to manage external properties for applications across all environments.\nThe Spring Config Server is pre-configured to work with the Spring Eureka Service Registry, and it is configured to store the configuration in the Oracle Autonomous Database, so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content. Configuration is stored in the CONFIGSERVER schema in the PROPERTIES table.\nAn example of a Config Server client\u0026rsquo;s Spring application.yaml configuration file could include:\nspring: config: import: optional:configserver:http://config-server.config-server.svc.cluster.local:8080 application: name: atael cloud: config: label: latest profile: dev This will fetch data in the value where the application is atael, profile is dev and the label is latest.\nManaging the data for the Config Server should be done using the CLI. If you prefer, you can also work directly with the CONFIGSERVER.PROPERTIES table in the database.\n","description":"Oracle Backend for Spring Boot includes the Spring Config which provides server and client-side support for externalized configuration in a distributed system. The Spring Config Server provides a central place to manage external properties for applications across all environments.\nThe Spring Config Server is pre-configured to work with the Spring Eureka Service Registry, and it is configured to store the configuration in the Oracle Autonomous Database, so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content."},{"id":7,"href":"/microservices-datadriven/spring/database/","title":"Database Access","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot includes an Oracle Database. An instance of the Oracle Autonomous Database (Shared) is created during installation.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for your database during installation (or just accepted the default), then you can use the Database Actions web user interface to work with your database. If you chose the \u0026ldquo;private\u0026rdquo; option, you need to use a bastion to access the database.\nUsing Database Actions To work with data in the database, you can use the Database Actions interface, which can be accessed from the OCI Console. The Oracle Database is created in the same compartments as OKE. In the OCI Console, navigate to Autonomous Database in the main menu and select the database with the Application Name you configured during install, with the suffix “DB”, for example “OBAASTSTPSDB”.\nOracle Autonomous DB Cloud Portal Click on the link to access the database details page, and then click on the “Database Actions” button:\nOracle Autonomous DB Details This will open the Database Actions page, where you have access to many database functions, including the ability to work with the schemas where your Oracle Backend for Spring Boot data are stored.\nAccessing the database from a local workstation After creating the Oracle Backend for Spring Boot environment, you will have to access to Autonomous Database for access, for example, the CONFIGSERVER.PROPERTIES, a table where Applications should add their properties. Also, each application can use the same database instance to host its data.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for database access during installation (or accepted this default), you can download the wallet to access the database from your local machine.\nIf you chose the \u0026ldquo;private\u0026rdquo; option for database access during installation, the database will be configure so that it is only accessible from the private VCN, and access will only be possible using the Bastion Service provisioned during installation.\nCreate Dynamic port forwarding (SOCKS5) session using Bastion service.\nLet\u0026rsquo;s start with ADB access that was created with private end point access only following security guidance. To allow you get access to ADB to run sql commands you will need to stablish an session between your local workstation and ADB passing by the Bastion service.\nWe will create a Dynamic port forwarding (SOCKS5) session.\nDownload ADB client credential After session create you will be able to stablish the tunnel with your ADB Instance issuing a SSH command that you can obtain clicking on three dots menu on right side of the session created.\nssh -i \u0026lt;privateKey\u0026gt; -N -D 127.0.0.1:\u0026lt;localPort\u0026gt; -p 22 ocid1.bastionsession.oc1.phx....@host.bastion.us-phoenix-1.oci.oraclecloud.com Connect with ADB Instance using SQLcl\nWith tunnel stablished, you will be able to connect with ADB instance. First export the Oracle Net port executing the next commmand:\nexport CUSTOM_JDBC=\u0026#34;-Doracle.net.socksProxyHost=127.0.0.1 -Doracle.net.socksProxyPort=\u0026lt;PORT\u0026gt; -Doracle.net.socksRemoteDNS=true\u0026#34; Download ADB client credentials (Wallet):\nDownload ADB client credential Connect with SQLcl\nsql /nolog set cloudconfig \u0026lt;WALLET\u0026gt;.zip connect ADMIN@\u0026lt;TNS_NAME\u0026gt; ","description":"The Oracle Backend for Spring Boot includes an Oracle Database. An instance of the Oracle Autonomous Database (Shared) is created during installation.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for your database during installation (or just accepted the default), then you can use the Database Actions web user interface to work with your database. If you chose the \u0026ldquo;private\u0026rdquo; option, you need to use a bastion to access the database."},{"id":8,"href":"/microservices-datadriven/spring/observability/metrics/","title":"Metrics","parent":"Observability","content":"The Oracle Backend for Spring Boot metrics stack automates metrics aggregation and consists of Prometheus and Grafana components. Metrics sources expose system and application metrics. The Prometheus components retrieve and store the metrics and Grafana provides dashboards to visualize them.\nMetrics View metrics from the application in Prometheus Prometheus is an open-source systems monitoring and alerting. Prometheus collects and stores its metrics as time series data, metrics are stored with the timestamp at which they were recorded, and optional key-value pairs called labels.\nExposing Prometheus UI using port-forward\nkubectl port-forward -n prometheus svc/prometheus 9090:9090 Open the Prometheus UI URL: http://localhost:9090\nPrometheus UI In the Prometheus web user interface you can search for metrics:\nIn the search bar, search for application_ready_time_seconds and click on the Execute button Notice you see metrics for the sample applications Prometheus Metrics In the Prometheus web user interface the Status menu item allow you view the targets being monitored by Prometheus:\nIn the top menu, choose Status and then Targets Notice targets \u0026ldquo;slow\u0026rdquo;, \u0026ldquo;customer\u0026rdquo; and others are in \u0026ldquo;UP\u0026rdquo; status and others are in \u0026ldquo;Down\u0026rdquo;. Prometheus Targets View details of the application in Grafana Grafana open source software enables you to query, visualize, alert on, and explore your metrics, logs, and traces wherever they are stored. Grafana OSS provides you with tools to turn your time-series database (TSDB) data into insightful graphs and visualizations.\nExposing Grafana using port-forward\nkubectl -n grafana port-forward svc/grafana 8080:80 Open the Grafana UI URL: http://localhost:8080\nusername: admin\nTo get the password run this command:\nkubectl -n grafana get secret grafana -o jsonpath=\u0026#39;{.data.admin-password}\u0026#39; | base64 -d Note: If you don\u0026rsquo;t have \u0026ldquo;base64\u0026rdquo; leave off the last part (\u0026quot;| base64 -d\u0026quot;) and then copy the output and use this website to decode it: https://www.base64decode.org/. The password will be a long string of characters like this 210BAqNzYkrcWjd58RKC2Xzerx9c0WkZi9LNsG4c (yours will be different)\nGrafana Login Setup Prometheus Datasource\nOn the left hand side menu, down the bottom, click on the cog wheel and choose Data Sources Click on the second data source, its called \u0026ldquo;Prometheus\u0026rdquo; \u0026amp; In the address (be careful to get the address field, not the name field), change the address from http://prometheus:9090 to http://prometheus.prometheus.svc.cluster.local:9090 Down the bottom of the page click on save \u0026amp; test and wait for the green icon to say the datasource is working (takes 2-3 seconds) Grafana Datasource Setup Dashboard\nNow in the left hand side menu up the top, find the dasbhoards link and click on that Click on the blue button on the right to add a new dashboard, and in the pull down select \u0026ldquo;import\u0026rdquo; In the field for the grafana dashboard ID, paste in this value: 10280 Click on next In the datasource field, choose the one called \u0026ldquo;prometheus\u0026rdquo; Click on save Grafana Import Dashboard Navigate in Spring Boot Dashboard\nNow you should see the new dashboard in the list - it is called Spring Boot Dashboard 2.1 - click on it to open it You should automatically see details for the sample applications in the dashboard Incoke the service, e.g., using curl, a number of times to create some traffic and observe the dashboard. There is round arrow icon in the top right corner that enables automatic refresh every 5 seconds (or whatever period you choose). Grafana Dashboard ","description":"The Oracle Backend for Spring Boot metrics stack automates metrics aggregation and consists of Prometheus and Grafana components. Metrics sources expose system and application metrics. The Prometheus components retrieve and store the metrics and Grafana provides dashboards to visualize them.\nMetrics View metrics from the application in Prometheus Prometheus is an open-source systems monitoring and alerting. Prometheus collects and stores its metrics as time series data, metrics are stored with the timestamp at which they were recorded, and optional key-value pairs called labels."},{"id":9,"href":"/microservices-datadriven/spring/observability/","title":"Observability","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot includes a number of common open-source components to provide application observability including Prometheus, Grafana, Jaeger and Open Telemetry Collector.\nFor more details, please read about:\nMetrics Tracing ","description":"Oracle Backend for Spring Boot includes a number of common open-source components to provide application observability including Prometheus, Grafana, Jaeger and Open Telemetry Collector.\nFor more details, please read about:\nMetrics Tracing "},{"id":10,"href":"/microservices-datadriven/spring/","title":"Oracle Backend for Spring Boot - Developer Preview","parent":"","content":"Oracle Backend for Spring Boot allows developers to build microservices in Spring Boot and provision a backend as a service with the Oracle Database and other infrastructure components that operate on multiple clouds. This service vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nIn addition to an Oracle Autonomous Database Shared instance, the following software components are deployed in an Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE) cluster:\nAPISIX API Gateway and Dashboard Spring Eureka Service Registry Spring Admin Dashboard Spring Config Server Netflix Conductor Prometheus Grafana Open Telemetry Collector Jaeger HashiCorp Vault Developers also have access to development/build time services and libraries including:\nA CLI to manage service deployment and configuration, including database schema management Spring Data (JPA, JDBC) to access Oracle Database Oracle JDBC drivers Spring Config client Spring Eureka Service Discovery client OpenFeign Open Telemetry (including automatic instrumentation) Interested in Mobile or web apps too? Check out Oracle Backend for Parse Platform! Developer Preview This release is a Developer Preview. This means that not all functionality is complete. In this release, most of the planned services and components are provided, however additional configuration options and components may be provided in a future release. We are releasing this as a developer preview to allow interested developers to try it and give feedback.\n","description":"Oracle Backend for Spring Boot allows developers to build microservices in Spring Boot and provision a backend as a service with the Oracle Database and other infrastructure components that operate on multiple clouds. This service vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nIn addition to an Oracle Autonomous Database Shared instance, the following software components are deployed in an Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE) cluster:"},{"id":11,"href":"/microservices-datadriven/spring/platform/","title":"Platform","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot includes a number of Spring platform components that provide services to applications deployed into the platform.\nFor more details, please read about: - API Gateway - Service Discovery - Configuration - Workflow - Spring Admin - Using the CLI - Vault\n","description":"Oracle Backend for Spring Boot includes a number of Spring platform components that provide services to applications deployed into the platform.\nFor more details, please read about: - API Gateway - Service Discovery - Configuration - Workflow - Spring Admin - Using the CLI - Vault"},{"id":12,"href":"/microservices-datadriven/spring/sample-apps/","title":"Sample Apps","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Sample applications that demonstrate Oracle Backend for Spring Boot use cases.\nPrerequisites GraalVM or OpenJDK 17 (OpenJDK Runtime Environment GraalVM CE 22.3.0 (build 17.0.5+8-jvmci-22.3-b08) recommended) Apache Maven 3.8+ A container runtime (to login and push images to OCI Registry), e.g., Docker Make a Clone of the Sample Apps Source Code Now that you have your Oracle Backend for Spring Boot environment available and accessible, you can deploy the sample applications.\nCreate a clone from the GitHub repository using the following command. git clone https://github.com/oracle/microservices-datadriven.git cd mbaas-developer-preview/sample-spring-apps/ This directory contains the sample applications\u0026rsquo; source code.\nCreate OCI Repositories for Sample Applications Before building the sample applications, you have to create the repositories for each sample application in your compartment. The name of the repository should follow the pattern \u0026lt;project name\u0026gt;/\u0026lt;app name\u0026gt;\nNote: If you do not pre-create the repositories, they will be created in the root compartment on the first push.\nOCI-R : Create Repository to host application image The required repositories are:\n\u0026lt;project\u0026gt;/banka \u0026lt;project\u0026gt;/bankb \u0026lt;project\u0026gt;/customer \u0026lt;project\u0026gt;/fraud \u0026lt;project\u0026gt;/notification \u0026lt;project\u0026gt;/slow_service Create an Authentication Token to login to OCI Registry by following the instructions on Generating an Auth Token to Enable Login to Oracle Cloud Infrastructure Registry\nLogin to OCI Registry by executing the following command. This will allow the build to push the sample applications\u0026rsquo; container images to OCI Registry.\nNote: A container runtime that allows you to push images to remote registries is required.\nYou can determine the \u0026lt;region\u0026gt; value from Region code. For example the US East (Ashburn) has the region code iad.\ndocker login \u0026lt;region\u0026gt;.ocir.io \\ --username \u0026lt;tenancy\u0026gt;/oracleidentitycloudservice/\u0026lt;username\u0026gt; \\ --password \u0026#34;\u0026lt;auth-token\u0026gt;\u0026#34; Note: If your account is federated you need to include /oracleidentitycloudservice/ in front of the username as shown above.\nBuild the sample applications and push container images Update the pom.xml in the root directory to match the OCI Registry repository prefix you used above. Configure the region, tenancy and project name:\n\u0026lt;properties\u0026gt; \u0026lt;container.registry\u0026gt;region ocir address/tenancy name/project name\u0026lt;/container.registry\u0026gt; \u0026lt;/properties\u0026gt; For example, if your region is Phoenix and project name is myproject:\n\u0026lt;properties\u0026gt; \u0026lt;container.registry\u0026gt;phx.ocir.io/mytenancy/myproject\u0026lt;/container.registry\u0026gt; \u0026lt;/properties\u0026gt; Run the Maven package goal with the build-docker-image profile using this command:\nmvn package -P build-docker-image When the command completes the build and push process (it will take a few minutes), you will see a message similar to the one below reporting that all modules were built successfully.\nIf you get a build failure, check the output for details of any errors, correct them, and then re-run the command.\nOBaaS : Sample Application build results Update Images in Kubernetes Deployment Descriptors You need to update the address of the images in application deployment descriptor to match the repositories you created. You do this by editing the 01--deployment--APPLICATION_NAME.yaml file in each of the service sub-directories (a total of six). Use the same values you used when editing the pom.xml file in the previous steps.\nspec: containers: - name: app_name image: phx.ocir.io/mytenancy/myproject/app_image:latest Create Database Objects for each application You must create the database users and some objects that are required by the sample services. Connect to the Oracle Autonmous Database instance using (using these instructions) and run the SQL statements for each application. You must edit each SQL script to add your desired password before running the statements.\nEach of the following files must be reviewed, updated, and then processed against the database (as the ADMIN user).\nCustomer microservice\ndb-01-customer-create-user.sql Fraud microservice\ndb-01-fraud-create-user.sql Notification microservice\ndb-01-notification-create-user.sql db-03-notifications-db-queue.sql Add applications configurations into Spring Config Server Properties Table You must create the application configuration entries that are required by the sample services. Connect to the Oracle Autonmous Database instance using (using these instructions) and run the SQL statements for each application. You must edit each SQL script to match your environment before running the statements. The example below shows the lines that must be updated. You must replace the TNS_NAME with the correct name for your database. If your database is called OBAASDB then the TNS_NAME is OBAASDB_TP.\nINSERT INTO CONFIGSERVER.PROPERTIES(APPLICATION, PROFILE, LABEL, PROP_KEY, \u0026#34;VALUE\u0026#34;) VALUES ( \u0026#39;APPLICATION_NAME\u0026#39;, \u0026#39;kube\u0026#39;, \u0026#39;latest\u0026#39;, \u0026#39;spring.datasource.url\u0026#39;, \u0026#39;jdbc:oracle:thin:@TNS_NAME?TNS_ADMIN=/oracle/tnsadmin\u0026#39; ); Each of the following files must be reviewed, updated, and then run against the database (as the ADMIN user).\nCustomer microservice:\ndb-02-customer-configserver-props.sql Fraud microservice:\ndb-02-fraud-configserver-props.sql Notification microservice:\ndb-02-notification-configserver-props.sql Add Kubernetes Secrets for each application\u0026rsquo;s database credentials For each application, you need to create a Kuberentes secret containing the database username and password that you chose in the previous steps. You can create these secrets by executing the following commands (update the values to match your environment):\nCustomer microservice:\nkubectl -n application \\ create secret generic oracledb-creds-customer \\ --from-literal=spring.db.username=CUSTOMER \\ --from-literal=spring.db.password=[DB_PASSWORD] Fraud microservice:\nkubectl -n application \\ create secret generic oracledb-creds-fraud \\ --from-literal=spring.db.username=FRAUD \\ --from-literal=spring.db.password=[DB_PASSWORD] Notification microservice:\nkubectl -n application \\ create secret generic oracledb-creds-notification \\ --from-literal=spring.db.username=NOTIFICATIONS \\ --from-literal=spring.db.password=[DB_PASSWORD] Deploy the applications Apply each application\u0026rsquo;s Kubernetes Deployment YAML using kubectl:\ncd \u0026lt;app dir\u0026gt; kubectl apply -f 01--deployment--\u0026lt;app name\u0026gt;.yaml Deploy each application\u0026rsquo;s Kuberenetes Service YAML using kubectl:\nkubectl apply -f 02--service--\u0026lt;app name\u0026gt;.yaml After deploying all microservices, you will be able to check they are running on Kubernetes using the following command:\nkubectl --namespace=application get all -o wide OBaaS : All resources from the Sample Application deployed on Kubernetes Explore the applications Before using the applications, you need to expose them by creating a route in APISIX API Gateway.\nTo expose the customer service, see the documentation on how to create a route and use these values:\nname = customer path = /api/v1/customers* method = get, post, options upstream type = service discovery discovery type = eureka service name = CUSTOMER (note that this is case sensitive, this is the key from the Eureka dashboard) Once the route is created, you can access the service using the load balancer IP address (as described on that page) using a call like this, for example, to create a customer:\ncurl -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;firstName\u0026#34;: \u0026#34;bob\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;smith\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bob@bob.com\u0026#34;}\u0026#39; \\ http://1.2.3.4/customer/api/v1/customers After you call the service a few times, you might also like to explore the various platform services, including:\nSpring Admin Dashboard where you can see details of the service including metrics, configuration, what endpoints it exposes, what Spring beans are used, etc. Spring Eureka Service Registry where you can see which services are registered and discoverable Prometheus and Grafana which allow you to view metrics and dashboards about the service performance Jaeger which will let you view traces of service executions. For the cusomter service, look for a trace of the POST to /api/v1/customers above. It will show interaction between the customer, fraud and notification services and each one writing to its own data store. The notification service also enqueues a message. ","description":"Sample applications that demonstrate Oracle Backend for Spring Boot use cases.\nPrerequisites GraalVM or OpenJDK 17 (OpenJDK Runtime Environment GraalVM CE 22.3.0 (build 17.0.5+8-jvmci-22.3-b08) recommended) Apache Maven 3.8+ A container runtime (to login and push images to OCI Registry), e.g., Docker Make a Clone of the Sample Apps Source Code Now that you have your Oracle Backend for Spring Boot environment available and accessible, you can deploy the sample applications."},{"id":13,"href":"/microservices-datadriven/spring/platform/eureka/","title":"Service Discovery","parent":"Platform","content":"Oracle Backend for Spring Boot includes the Spring Eureka Service Registry, which is an application that stores information about client services/applications. Typically, each microservice will register with the Eureka server at startup and the Eureka server will maintain a list of all active instances of the service, including their ports and IP addresses. This information can be looked up by other services using a well-known key. This allows services to interact with each other without needing to know each others\u0026rsquo; addresses at development/deployment time.\nAccess the Eureka web user interface Expose the Eureka web user interface using port-forward\nkubectl port-forward -n eureka svc/eureka 8761:8761 Open the Eureka web user interface: http://localhost:8761\nEureka web user interface On the web page, you will see all of the services registered with Eureka. If you deployed the sample apps, look for an entry called \u0026ldquo;SLOW\u0026rdquo; - the presence of this entry confirms that the application successfully registered itself with the service registry You should also see \u0026ldquo;CONFIG-SERVER\u0026rdquo; and \u0026ldquo;ADMIN-SERVER\u0026rdquo; there - these are deployed as part of the platform ","description":"Oracle Backend for Spring Boot includes the Spring Eureka Service Registry, which is an application that stores information about client services/applications. Typically, each microservice will register with the Eureka server at startup and the Eureka server will maintain a list of all active instances of the service, including their ports and IP addresses. This information can be looked up by other services using a well-known key. This allows services to interact with each other without needing to know each others\u0026rsquo; addresses at development/deployment time."},{"id":14,"href":"/microservices-datadriven/spring/setup/","title":"Setup","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot is available in the OCI Marketplace.\nPrerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot:\nAn OCI account in a tenancy with sufficient quota to create:\nAn OCI Container Engine for Kubernetes cluster, plus a node pool with three worker nodes A VCN with at least two public IP\u0026rsquo;s available A public load balancer An Oracle Autonomous Database - Shared instance At least one free OCI Auth Token (note that the maximum is two per user)\nOn local workstation:\nThe Kubernetes command-line tool (kubectl) Oracle Cloud Infrastructure Command Line Interface (CLI) Oracle Backend for Spring Boot command-line tool Summary of components Oracle Backend for Spring Boot setup will install the following components:\nComponent Version Description cert-manager 1.10.1 Automates the management of certificates. NGINX Ingress Controller 1.5.1 Traffic management solution for cloud‑native applications in Kubernetes. Prometheus 2.40.2 Provides event monitoring and alerting. Prometheus Operator 0.60.1 Provides management for Prometheus monitoring tools. OpenTelemetry Collector 0.66.0 Collects process and export telemetry data. Grafana 9.2.5 Tool to help you examine, analyze, and monitor metrics. Jaeger Tracing 1.37.0 Distributed tracing system for monitoring and troubleshooting distributed systems. APISIX 2.15.1 Provides full lifecycle API Management. Spring Admin Server 2.7.5 Managing and monitoring Spring Boot applications. Spring Cloud Config Server 2.7.5 Provides server-side support for externalized configuration. Eureka Service Registry 2021.0.3 Provides Service Discovery capabilities HashiCorp Vault v1.11.3 Provides a way of store and tightly control access to sensitive data Setup the OCI environment Go to the OCI Marketplace listing for Oracle Backend for Spring Boot.\nChoose the target compartment, agree to the terms and click on the \u0026ldquo;Launch Stack\u0026rdquo; button. This will start the wizard to create the new stack. On the first page choose a compartment to host your stack and select Next\nFill in the following configuration variables as needed and select Next\nApplication Name (Optional) OKE Control Plane Options. Public Control Plane: this option allows access the OKE Control Plane from the Internet (Public IP). If not selected, access will only be from a private VCN. Control Plane Access Control: CIDR (IP range) allowed to access the control plane (Oracle recommends you set this as restrictive as possible). Enable Horizontal Pod Scaling?: The Horizontal Pod Autoscaler can help applications scale out to meet increased demand, or scale in when resources are no longer needed. Node Pool Workers: Number of Kubernetes worker nodes (virtual machines) to attach to the OKE Cluster. Create Stack Wizard Config Variables Load Balancers Options.\nEnable Public Load Balancer this option allows access to the load balancer from the Internet (Public IP). If not selected, access will only be from a private VCN. Public Load Balancer Ports Exposed. Ports exposed from the load balancer. Minimum bandwidth. The minimum bandwidth the load balancer can achieve. Maximum bandwidth. The maximum bandwidth the load balancer can achieve. Vault Options. You have the option of creating a new OCI Vault or use an an existing OCI Vault. Fill in the information below if you want to use an existing OCI Vault.\nVault Compartment (Optional) Select a Compartment for the OCI Vault. Existing Vault (Optional). Select an existing OCI Vault Existing Vault Key (Optional). Select an existing OCI Vault Key. Maximum bandwidth. The maximum bandwidth the load balancer can achieve. Create Stack Wizard Config Variables Now you can review the stack configuration and save the changes. Oracle recommends that you do not check the \u0026ldquo;Run apply\u0026rdquo; option - this will give you the opportunity to run the \u0026ldquo;plan\u0026rdquo; first and check for issues.\nCreate Stack Wizard Config Review Apply the Stack\nAfter you create your stack, you will be able to test the plan, edit the stack, and apply or destroy the stack.\nOracle recommends you test the plan before applying the stack, in order to identify any issues before you start creating resources. Testing a plan does not create any actual resources, it is just a \u0026ldquo;dry run\u0026rdquo; to tell you what would happen if you applied.\nCreate Stack Plan You can test the plan by clicking on the \u0026ldquo;Plan\u0026rdquo; button and then reviewing the output. If you see any issues, for example you may find that you do not have enough quota for some resource, you can fix that issue before proceeding.\nWhen you are happy with the results of the test, you can apply the stack by clicking on the \u0026ldquo;Apply\u0026rdquo; button. This will create your Oracle Backend as a Service for Spring Cloud Environment. This takes about 20 minutes to complete. A lot of this time is spent provisioning the Kubernetes cluster, worker nodes, and database. You can watch the logs to follow progress of the operation.\nCreate Stack Apply The OCI Resource Manager will apply your stack and generate the execution logs. The apply job takes approximately 45 minutes.\nCreate Stack Apply Logs Collect the OKE access information by clicking on the Outputs menu item.\nCreate Stack Outputs Click on the Copy for the Variable named kubeconfig_cmd. Save this information as it is needed to access the OKE Cluster.\nGet Kube Config Cmd Setup the local workstation Setting Up Cluster Access\nTo access a cluster using kubectl installed (see the Kubernetes access) locally. If you haven\u0026rsquo;t already done so,\ninstall kubectl (see the kubectl documentation).\ngenerate an API signing key pair If you already have an API signing key pair, go straight to the next step. If not:\nUse OpenSSL commands to generate the key pair in the required PEM format. If you\u0026rsquo;re using Windows, you\u0026rsquo;ll need to install Git Bash for Windows and run the commands with that tool. See How to Generate an API Signing Key. Copy the contents of the public key to the clipboard (you\u0026rsquo;ll need to paste the value into the Console later). add the public key value of the API signing key pair to the User Settings for your username\nIn the top-right corner of the Oracle Cloud Infrastructure Console, open the Profile menu (User menu icon) and then click User Settings to view the details.\nClick Add Public Key.\nPaste the public key\u0026rsquo;s value into the window and click Add.\nThe key is uploaded and its fingerprint is displayed (for example, d1:b2:32:53:d3:5f:cf:68:2d:6f:8b:5f:77:8f:07:13).\ninstall and configure the Oracle Cloud Infrastructure CLI\nInstall the Oracle Cloud Infrastructure CLI version 2.6.4 (or later). See Quickstart. Configure the Oracle Cloud Infrastructure CLI. See Configuring the CLI. Install Oracle Backend for Spring Boot command-line\nThe Oracle Backend for Spring Boot command-line tool, oractl, is available for Linux and Mac systems. Download the binary you want from the Releases page and add it to your PATH environment variable. You may like to rename the binary to remove the suffix.\nIf your environment is a Linux or Mac machine you need to run chmod +x on the downloaded binary. Also if your environment is a Mac you need run the following command sudo xattr -r -d com.apple.quarantine \u0026lt;downloaded-file\u0026gt; otherwise will you get a security warning and the CLI will not work.\n","description":"Oracle Backend for Spring Boot is available in the OCI Marketplace.\nPrerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot:\nAn OCI account in a tenancy with sufficient quota to create:\nAn OCI Container Engine for Kubernetes cluster, plus a node pool with three worker nodes A VCN with at least two public IP\u0026rsquo;s available A public load balancer An Oracle Autonomous Database - Shared instance At least one free OCI Auth Token (note that the maximum is two per user)"},{"id":15,"href":"/microservices-datadriven/spring/platform/spring-admin/","title":"Spring Admin","parent":"Platform","content":" View application details using the Spring Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications.\nExposing Spring Admin Dashboard using port-forward\nkubectl -n admin-server port-forward svc/admin-server 8989:8989 Open the Spring Admin Dashboard URL: http://localhost:8989\nusername: admin password: admin Note: Oracle recommends that you change the default password when you first login. Even though the dashboard is not accessible externally, we still recommend using strong passwords to maximize security.\nSpring Admin DashboardI On the web page, navigate to the applications tab:\nIf you deployed the sample apps, Find the \u0026ldquo;slow\u0026rdquo; entry and click on it to expand it Click on the instance of the service Notice you can see details about the service instance, metrics, configuration, etc. Spring Admin Service Details ","description":"View application details using the Spring Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications.\nExposing Spring Admin Dashboard using port-forward\nkubectl -n admin-server port-forward svc/admin-server 8989:8989 Open the Spring Admin Dashboard URL: http://localhost:8989"},{"id":16,"href":"/microservices-datadriven/spring/tags/","title":"Tags","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"","description":""},{"id":17,"href":"/microservices-datadriven/spring/uninstall/","title":"Uninstall","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"To remove the Oracle Backend for Spring Boot, in the OCI Console main menu, navigate to “Developer Services” then “Resource Manager - Stacks”. Make sure you are in the correct region and compartment where you installed the BaaS.\nClick on the link to open the detail view for the Oracle Backend for Spring Boot instance and click on the Destroy button to clean up resources:\nOCI Stack Destroy The OCI Resource Manager will use stack definition to destroy all resources.\nOCI Stack Destroy Logs The destroy job takes about 20 minutes to complete. You should review the logs at the end to make sure it completed successfully. If there were any errors, in most cases running the destroy job again will fix any issues.\n","description":"To remove the Oracle Backend for Spring Boot, in the OCI Console main menu, navigate to “Developer Services” then “Resource Manager - Stacks”. Make sure you are in the correct region and compartment where you installed the BaaS.\nClick on the link to open the detail view for the Oracle Backend for Spring Boot instance and click on the Destroy button to clean up resources:\nOCI Stack Destroy The OCI Resource Manager will use stack definition to destroy all resources."},{"id":18,"href":"/microservices-datadriven/spring/development/cli/","title":"Using the OBaaS CLI","parent":"Development","content":"The Oracle Backend for Spring Boot offers a command-line tool, oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources they use. Download the CLI here The platform specific binary can be renamed to oractl for convenience.\nUsing the CLI Expose the Oracle Backend for Spring Boot Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/obaas-admin -n obaas-admin 8080:8080 Start the CLI in interactive mode by simply running oractl from your terminal window.\noractl AVAILABLE COMMANDS Short descriptions of the available commands are as follows. These can be viewed by issuing the help command and detailed help for any individual command can be viewed by issuing help [commandname]\nAVAILABLE COMMANDS\noractl:\u0026gt;help AVAILABLE COMMANDS Admin Server Commands change-password: Change password for OBaaS Spring Cloud admin user. connect: Connect to the OBaaS Spring Cloud admin console. Application/Namespace Commands create: Create an application/namespace. delete: Delete a service or entire application/namespace. Built-In Commands help: Display help about available commands stacktrace: Display the full stacktrace of the last error. clear: Clear the shell screen. quit, exit: Exit the shell. history: Display or save the history of previously run commands version: Show version info script: Read and execute commands from a file. Informational Commands list: list/show details of application services. Service Commands bind: Create a schema/user and bind it to service deployment. config: View and modify application configuration. deploy: Deploy a service. oractl:\u0026gt; An application is a namespace encompassing related microservices. For example, a \u0026ldquo;cloudbank\u0026rdquo; application may have \u0026ldquo;banktransfer\u0026rdquo; \u0026ldquo;frauddetection\u0026rdquo;, etc., microservices deployed within it. The create command results in the creation of an application namespace.\nThe bind command results in the automatic creation of a database schema for a given service/user and binds the information for that schema/database in the environment of the microservice for it to use. The option of the prefix for the environment properties bound is also given. For example, most Spring microservices us \u0026ldquo;spring.datasource\u0026rdquo;.\nThe deploy command takes serviceName, appName, and jarLocation as it\u0026rsquo;s main arguments (imageVersion and javaVersion options are also provided). When the deploy command is issued, the microservice JAR file is uploaded to the backend, a container image is created for the JAR/microservice, and various Kubernetes resources such as deployment, service, etc. are also created. This is all done automatically to simplify the development process and the management of the microservices by the backend.\nThe list command can then be used show the details of the deployed microservice, etc.\nThe config command can also be used to view and update configuration managed by the Spring Config Server.\nA common development workflow pattern is to connect, change-password (only if necessary), create (once per app/namespace), config, bind (only if necessary), deploy, and list.\nFurther development and redeployment of the service can then be iterated upon by issuing the deploy, list, etc. commands.\nThe following is an example development workflow using the CLI.\nFirst, a connection is made to the Oracle server-side Spring Admin\noractl:\u0026gt;help connect NAME connect - Connect to the OBaaS Spring Cloud admin console. SYNOPSIS connect --url String --username String OPTIONS --url String admin server URL [Optional, default = http://localhost:8080] --username String username (will be prompted for password) [Optional, default = admin] oractl:\u0026gt;connect password (defaults to oractl): using default value... connect successful server version:011223 Then, an application namespace is created withe the create command. This namespace will contain the microservices that are deployed later.\noractl:\u0026gt;help create NAME create - Create an application/namespace. SYNOPSIS create --appName String OPTIONS --appName String application/namespace [Optional, default = cloudbank] oractl:\u0026gt;create application/namespace created successfully and image pull secret (registry-auth) created successfully Next, the bind command will create a database schema/user for the service (if one hasn\u0026rsquo;t already been created). The command will also create the Kubernetes secret and binding environment entries for the schema (these will be set in the Kubernetes deployment created with the deploy command).\noractl:\u0026gt;help bind NAME bind - Create a schema/user and bind it to service deployment. SYNOPSIS bind --appName String --serviceName String --springBindingPrefix String OPTIONS --appName String application/namespace [Optional, default = cloudbank] --serviceName String database user/serviceName [Optional, default = banka] --springBindingPrefix String spring binding prefix [Optional, default = spring.datasource] oractl:\u0026gt;bind database password/servicePassword (defaults to Welcome12345): using default value... database secret created successfully and schema created successfully for banka The microservice JAR will now be deployed with the deploy command which will create, build, and push an image for the microservice and create the necessary deployment, service, secret, etc. Kubernetes resources for the microservice.\noractl:\u0026gt;help deploy NAME deploy - Deploy a service. SYNOPSIS deploy --isRedeploy String --bind String --appName String --serviceName String --jarLocation String --imageVersion String --javaImage String OPTIONS --isRedeploy String whether the service has already been deployed or not [Optional, default = true] --bind String automatically create and bind resources. possible values are [jms] [Optional, default = none] --appName String application/namespace [Optional, default = cloudbank] --serviceName String service name [Optional, default = banka] --jarLocation String service jar location [Optional, default = target/banka-0.0.1-SNAPSHOT.jar] --imageVersion String image version [Optional, default = 0.1] --javaImage String java image [Optional, default = ghcr.io/graalvm/jdk:ol7-java17-22.2.0] oractl:\u0026gt;deploy --isRedeploy false --bind jms --jarLocation ebaas-sample-apps/banka/target/banka-0.0.1-SNAPSHOT.jar uploading... upload successful building and pushing image... docker build and push successful binding resources... successful (no resources found to bind) creating deployment and service... create deployment and service = banka, appName = cloudbank, isRedeploy = false successful successfully deployed The list command can then be used to show details of the microservice deployed in the previous step.\noractl:\u0026gt;help list NAME list - list/show details of application services. SYNOPSIS list --appName String OPTIONS --appName String application/namespace [Optional, default = cloudbank] oractl:\u0026gt;list name:banka-7fbff59d8c-gt42g status:class V1ContainerStatus { containerID: cri-o://df2ec83b9359dee8aad658bde2d9ba988f7e43ea2a3e7add61c0cd2eeca612af image: ams.ocir.io/maacloud/walleye/cloudbank-banka:0.1 imageID: ams.ocir.io/maacloud/walleye/cloudbank-banka@sha256:d37f889f6f706accd32df0ccff576237b3a15c736d90ee99b7f97f84860c3502 lastState: class V1ContainerState { running: null terminated: null waiting: null } name: banka ready: true restartCount: 0 started: true state: class V1ContainerState { running: class V1ContainerStateRunning { startedAt: 2023-01-18T15:54:10Z } terminated: null waiting: null } }name:banka kind:null The config command can be used to view and update config managed by the Spring Config Server. More information on the configuration server can be found here:\nSpring Config Server oractl:\u0026gt;help config NAME config - View and modify application configuration. SYNOPSIS config --command String --application String --label String --profile String --propKey String --value String OPTIONS --command String possible values are [c]reate, [r]ead all, [u]pdate, and [d]elete [Optional, default = r] --application String application/namespace config [Optional, default = cloudbank] --label String label for config [Optional, default = test] --profile String profile for config [Optional, default = test] --propKey String the property key for the config [Optional, default = test] --value String the value for the config [Optional, default = test] oractl:\u0026gt;config command ([c]reate, [r]ead all, [u]pdate, [d]elete): r [id\u0026#34;:1,\u0026#34;application\u0026#34;:\u0026#34;atael\u0026#34;,\u0026#34;profile\u0026#34;:\u0026#34;dev\u0026#34;,\u0026#34;label\u0026#34;:\u0026#34;latest\u0026#34;,\u0026#34;propKey\u0026#34;:\u0026#34;test-property\u0026#34;,\u0026#34;value\u0026#34;:\u0026#34;This is the test-property value\u0026#34;,\u0026#34;createdOn\u0026#34;:\u0026#34;2022-12-14T12:42:33.000+00:00\u0026#34;,\u0026#34;createdBy\u0026#34;:\u0026#34;ADMIN” […] ","description":"The Oracle Backend for Spring Boot offers a command-line tool, oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources they use. Download the CLI here The platform specific binary can be renamed to oractl for convenience.\nUsing the CLI Expose the Oracle Backend for Spring Boot Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/obaas-admin -n obaas-admin 8080:8080 Start the CLI in interactive mode by simply running oractl from your terminal window."},{"id":19,"href":"/microservices-datadriven/spring/platform/vault/","title":"Vault","parent":"Platform","content":"Oracle Backend as a Service for Spring Cloud includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Vault uses the following Oracle OCI Services:\nObject Storage for storing Vault data OCI Vault to auto unseal the Vault Container Engine for Kubernetes for running the Vault server The Vault is unsealed using the OCI KMS key. The root token is provided during deployment of Oracle Backend as a Service for Spring Cloud.\nThe following Vault services are enabled during deployment. Other services can be enabled using the vault command and the Web User Interface.\nToken Auth Method. The token auth method is built-in and automatically available. It allows users to authenticate using a token, as well to create new tokens, revoke secrets by token, and more. KV Secrets Engine Version 2. The kv secrets engine is a generic Key-Value store used to store arbitrary secrets. AppRole Auth Method. The approle auth method allows machines or apps to authenticate with Vault-defined roles. Accessing Vault using using kubectl To access Vault using kubectl you need to setup Kubernetes Access\nTest access to Vault\nVault Documentation contains all the commands you can use with the Vault CLI. For example this command returns the current status of Vault:\nkubectl exec pod/vault-0 -n vault -it -- vault status The output will be similar to this:\nKey Value --- ----- Recovery Seal Type shamir Initialized true Sealed false Total Recovery Shares 5 Threshold 3 Version 1.11.3 Build Date 2022-08-26T10:27:10Z Storage Type oci Cluster Name vault-cluster-28535f69 Cluster ID 993662ee-b3ee-2a13-3354-97adae01e1ca HA Enabled true HA Cluster https://vault-0.vault-internal:8201 HA Mode active Active Since 2023-01-26T16:14:32.628291153Z Login into Vault\nTo interact with vault you need to login using a token. The root token is stored in a k8s secret. Get the token by running this command, the output is the root token. It is VERY IMPORTANT that the token is saved in multiple places, loosing the token can result in loss of access to the Vault.\nkubectl get secret root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34; Login to the vault:\nkubectl exec pod/vault-0 -n vault -it -- vault login Token (will be hidden): Sample output from logging in as the root user which only should be done initial setup. As an administrator you must generate separate tokens and ACLs for the users than needs access to Vault. See Vault Documentation.\nKey Value --- ----- token hvs....... token_accessor Hcx....... token_duration ∞ token_renewable false token_policies [\u0026#34;root\u0026#34;] identity_policies [] policies [\u0026#34;root\u0026#34;] Display the enabled secret engines\nTo display the enabled secrets engines execute the following command:\nkubectl exec pod/vault-0 -n vault -it -- vault secrets list The output will look similar to this:\nPath Type Accessor Description ---- ---- -------- ----------- cubbyhole/ cubbyhole cubbyhole_a07a59ec per-token private secret storage identity/ identity identity_8b1e1a80 identity store kv-v2/ kv kv_06acc397 n/a sys/ system system_df5c39a8 system endpoints used for control, policy and debugging Create a secret\nCreate a secret at path kv-v2/customer/acme with a nme and an email\nkubectl exec pod/vault-0 -n vault -it -- vault kv put -mount=kv-v2 customer/acme customer_name=\u0026#34;ACME Inc.\u0026#34; \\ contact_email=\u0026#34;john.smith@acme.com\u0026#34; The output will look similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 Get a secret\nGet the created secret:\nkubectl exec pod/vault-0 -n vault -it -- vault kv get -mount=kv-v2 customer/acme The output will look similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 ======== Data ======== Key Value --- ----- contact_email john.smith@acme.com customer_name ACME Inc. For more information about the Key/Value secrets engine Key/value Documentation and Versioned Key/Value Secrets Engine Tutorial.\nAccessing Vault using the Web User Interface Expose the Vault Web User Interface using port-forward\nkubectl port-forward -n vault svc/vault 8200:8200 Get the root token\nTo interact with vault you need to login using a token. The root token is stored in a k8s secret. Get the token by running this command, the output is the root token. It is VERY IMPORTANT that the token is saved in multiple places, loosing the token can result in loss of access to the Vault.\nkubectl get secret root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34; Open the Vault Web User Interface: https://localhost:8200\nVault Web User Interface Login using the root token. As an administrator you must generate separate tokens and ACLs for the users than needs access to Vault. See Vault Documentation.\nYou are presented with the home screen showing the installed secret engines\nVault Home Page Create a Key/Value secret\nClick on the k2-v2 link from the home page.\nVault K/V V2 Home Click on the Create Secret link\nVault Create Secret Create a secret\nVault Secret View the secret content by clicking on the eye icon for each value\nVault Show Secret ","description":"Oracle Backend as a Service for Spring Cloud includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Vault uses the following Oracle OCI Services:\nObject Storage for storing Vault data OCI Vault to auto unseal the Vault Container Engine for Kubernetes for running the Vault server The Vault is unsealed using the OCI KMS key."},{"id":20,"href":"/microservices-datadriven/spring/platform/conductor/","title":"Workflow","parent":"Platform","content":"Oracle Backend as a Service for Spring Cloud includes Netflix Conductor Server. Conductor is a popular workflow solution that works well with Spring Boot microservices and the Oracle database.\nFull documentation on Conductor can be found here:\nNetflix Conductor Documentation Accessing Server UI Expose the Oracle Spring Cloud Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor Server UI.\nhttp://localhost:8080 Access the Swagger Documentation\nhttp://localhost:8080/swagger-ui/index.html API Specification The API Specification can be found here:\nAPI Specification ","description":"Oracle Backend as a Service for Spring Cloud includes Netflix Conductor Server. Conductor is a popular workflow solution that works well with Spring Boot microservices and the Oracle database.\nFull documentation on Conductor can be found here:\nNetflix Conductor Documentation Accessing Server UI Expose the Oracle Spring Cloud Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor Server UI.\nhttp://localhost:8080 Access the Swagger Documentation"}]