[{"id":0,"href":"/microservices-datadriven/spring/observability/tracing/","title":"Jaeger Tracing","parent":"Observability","content":"Jaeger is a distributed tracing system used for monitoring and troubleshooting microservices. For more information on Jaeger, see the Jaeger website.\nView application traces in Jaeger web user interface Exposing Jaeger web user interface using port-forward\nkubectl -n observability port-forward svc/jaegertracing-query 16686:16686 Open the Jaeger web user interface URL: http://localhost:16686\nJaeger UI In the Jaeger web user interface, the Search Tab allows you find tracings using various criteria. For example, to find traces for the customer microservice included in the sample apps:\nIf you deployed the sample apps, exposed the customer service through the APISIX Gateway and called it at least once, you will be able to find traces for it in Jaeger.\nSelect Service customer and Operation /api/v1/customers\nClick on the search button \u0026ndash; Several traces will appear (one for each time you invoked the service)\nJaeger Customer Tracing Click on any one of them to view the trace that include multiple services and extends into the Oracle database and Oracle Advanced Queueing:\nJaeger Customer Tracing Details ","description":"Jaeger is a distributed tracing system used for monitoring and troubleshooting microservices. For more information on Jaeger, see the Jaeger website.\nView application traces in Jaeger web user interface Exposing Jaeger web user interface using port-forward\nkubectl -n observability port-forward svc/jaegertracing-query 16686:16686 Open the Jaeger web user interface URL: http://localhost:16686\nJaeger UI In the Jaeger web user interface, the Search Tab allows you find tracings using various criteria. For example, to find traces for the customer microservice included in the sample apps:"},{"id":1,"href":"/microservices-datadriven/spring/azure/","title":"Azure","parent":"Oracle Backend for Spring Boot - Developer Preview","content":" Azure/OCI Multi-Cloud Installation The Oracle Backend for Spring Boot is available to install in Multi-Cloud (Azure and OCI). This installation will deplpoy the Oracle Backend for Spring Boot in Azure with an Oracle Autonomous Database running in OCI.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot Multi-Cloud (Azure and OCI):\nAn account on Azure An account on OCI Download Download Oracle Backend for Spring Boot.\nSetup A few setup steps are required in both Oracle Cloud Infrastructure (OCI) and Azure to deploy the Oracle Backend for Spring Boot application.\nOCI The Multi-Cloud Installation will provision an Oracle Autonomous Database in OCI via the Oracle Database Operator for Kubernetes (OraOperator).\nTo allow the OraOperator access to OCI, an API Key must be generated:\nLog into OCI Open the Profile menu and click My profile. In the Resources section at the bottom left, click API Keys Click Download Private Key and save the key as private_key.pem. You do not need to download the public key. Click Add. The key is added and the Configuration File Preview is displayed. The file snippet includes required parameters and values you\u0026rsquo;ll need. Copy and paste the configuration file snippet from the text box and keep handy for later steps.\nAzure The Multi-Cloud Installation will be done via the Azure Cloud Shell. The following steps are required in Azure to prepare for the installation.\nLog into Azure Open the Azure Cloud Shell Upload the Oracle Backend for Spring Boot Stack Upload the API Private Key (private_key.pem) Unzip the Stack to a directory called obaas unzip azure-ebaas-platform_latest.zip -d obaas Move the private_key.pem file to obaas mv private_key.pem obaas/ Run the configuration helper script, inputing the values from the API Key cd ~/obaas ./obaas_configure.py Install Ansible Install Ansible to run the Configuration Management Playbook. The helper scripts will create a Python Virtual Environment and install Ansible and additional modules:\ncd ~/obaas/ansible ./setup_ansible.sh source ./activate.env Deploy the Infrastructure From the Azure Cloud Shell:\ncd ~/obaas terraform init terraform plan -out=multicloud.plan terraform apply \u0026#34;multicloud.plan\u0026#34; Finish Next, move on the the Getting Started page to learn how to use the newly installed environment.\n","description":"Azure/OCI Multi-Cloud Installation The Oracle Backend for Spring Boot is available to install in Multi-Cloud (Azure and OCI). This installation will deplpoy the Oracle Backend for Spring Boot in Azure with an Oracle Autonomous Database running in OCI.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot Multi-Cloud (Azure and OCI):\nAn account on Azure An account on OCI Download Download Oracle Backend for Spring Boot."},{"id":2,"href":"/microservices-datadriven/spring/development/","title":"Development","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"","description":""},{"id":3,"href":"/microservices-datadriven/spring/on-premises/","title":"On Premises","parent":"Oracle Backend for Spring Boot - Developer Preview","content":" On-Premises Installation The Oracle Backend for Spring Boot is available to install On-Premises. The On-Premises installation includes both a Desktop installation and an Estate installation.\nThe Desktop installation can be used to explore the in a non-Production environment, while the Estate installation is targeted for Production infrastructure.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot On-Premises:\nAccess to an Oracle Database - Enterprise Edition 21.3.0.0 Access to a Container Repository Access to a Kubernetes Cluster Python 3+ When installing on a Desktop the above pre-requisites are met through an additional Setup task, but there are additional desktop system/software requirements:\n2 CPUs or more 8GB of free memory 60GB of free disk space (40G minikube and container images, 20G database) Internet connection Minikube Podman1 Oracle SSO Account to download the database image Download Download Oracle Backend for Spring Boot.\nSetup An On-Premises installation, whether Desktop or Estate, consists of defining the Infrastructure followed by running the Configuration Management Playbook to build images and deploy the microservices.\nFor an Estate installation, you need to have a Kubernetes cluster, and the kubectl command-line tool must be configured to communicate with your cluster.\nA helper Playbook has been provided for the Desktop installations to assist in defining the Infrastructure. Please review the appropriate documentation for examples of installing and defining the Desktop installation (more Desktop examples may be provided in the future).\nMacOS Ventura (x86) Oracle Linux 8 (x86) The Desktop Playbook will be run as part of the Configuration Management.\nDownload the Database/ORDS Images (Desktop Installation) The Desktop installation will provision an Oracle Database into the Kubernetes cluster. The images must be downloaded from Oracle\u0026rsquo;s Container Registry prior to continuing.\nAfter Installing Podman:\nLog into Oracle\u0026rsquo;s Container Registry: podman login container-registry.oracle.com Pull the Database Image: podman pull container-registry.oracle.com/database/enterprise:21.3.0.0 Pull the ORDS Image: podman pull container-registry.oracle.com/database/ords:21.4.2-gh Defining the Database (Estate Installation) The database is defined in ansible/roles/database/vars/main.yaml. Below is an example definition:\n--- oracle_dbs: [\u0026#39;BAASPDB\u0026#39;] default_db: BAASPDB BAASPDB: username: \u0026#39;PDBADMIN\u0026#39; password: \u0026#39;Correct-horse-Battery-staple-35\u0026#39; service: \u0026#39;(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=BAASPDB)))\u0026#39; ocid: \u0026#39;\u0026#39; ... The oracle_dbs and default_db key values should be the name of your Pluggable Database (PDB). These are followed by the PDB Name and key/values defining how to access the PDB. If using mTLS authentication, specify the full path of the wallet file.\nDefining the Container Repository (Estate Installation) The container repository is defined in ansible/roles/registry/vars/main.yaml. Below is an example definition:\n--- registry_username: \u0026#39;oracle\u0026#39; registry_password: \u0026#39;Correct-horse-Battery-staple-35\u0026#39; push_registry_url: \u0026#39;docker.io/myorg\u0026#39; push_registry_auth: auths: docker.io/myorg: auth: \u0026#39;b3JhY2xlOjdaUVgxLXhhbFR0NTJsS0VITlA0\u0026#39; pull_registry_url: \u0026#39;docker.io/myorg\u0026#39; pull_registry_auth: auths: docker.io/myorg: auth: \u0026#39;b3JhY2xlOjdaUVgxLXhhbFR0NTJsS0VITlA0\u0026#39; ... Specify the URL/authentication credentials for your Container Repository in pull_registry_url, push_registry_url, registry_username and registry_password.\nFor the registry_auth section, manually log into your repository and copy the values found in file created, often found in $HOME/.config/containers/auth.json\nYou maybe curious as to why there is duplication between the push and pull URL\u0026rsquo;s. The pull URL is used inside the pods while the push is used from the deployment machine. If you have a private registry inside the Kubernetes cluster, these URL\u0026rsquo;s could be different. This is the case for the Desktop installation; the push URL is localhost:5000, while the pull URL is \u0026lt;Registry Pod ClusterIP\u0026gt;:5000.\nConfiguration Management From the source package, run the configuration management Playbook:\nInstall Ansible Using python, install Ansible to run the Configuration Management Playbook. The helper scripts will create a Python Virtual Environment and install Ansible and additional modules:\n./setup_ansible.sh source ./activate.env Desktop Playbook If this is an Estate installation, the Infrastructure should be manually defined as per above.\nIf this is a Desktop installation; run the helper Playbook to define the infrastructure:\nansible-playbook ansible/desktop-apply.yaml Build and Push Images to the Container Repository For the Desktop installation, start a new terminal and tunnel or port-forward to the minikube cluster. Refer to the specific platform details for more information.\nFor both installations, on the original terminal, run the Images Playbook:\nansible-playbook ansible/images_build.yaml Install the Microservices ansible-playbook ansible/k8s_apply.yaml -t full Finish Next, move on the the Getting Started page to learn how to use the newly installed environment.\nFootnotes Certification has been performed against Podman, however, other container or virtual machine managers are available and may be substituted. Experience is needed and your milage may vary.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"On-Premises Installation The Oracle Backend for Spring Boot is available to install On-Premises. The On-Premises installation includes both a Desktop installation and an Estate installation.\nThe Desktop installation can be used to explore the in a non-Production environment, while the Estate installation is targeted for Production infrastructure.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot On-Premises:\nAccess to an Oracle Database - Enterprise Edition 21."},{"id":4,"href":"/microservices-datadriven/spring/on-premises/macos_ventura/","title":"Macos Ventura","parent":"On Premises","content":" On-Premises Installation - MacOS Ventura (x86) This is an example of installing on a MacOS Venture desktop\nPlease read the On-Premises and ensure your desktop meets the minimum system requirements.\nInstall Podman brew install podman PODMAN_VERSION=$(podman -v |awk \u0026#39;{print $NF}\u0026#39;) sudo /usr/local/Cellar/podman/${PODMAN_VERSION}/bin/podman-mac-helper install podman machine init --cpus 4 --disk-size 60 --memory 8192 --rootful --now podman system connection default podman-machine-default-root Download the Database/ORDS Images The Desktop installation will provision an Oracle Database into the Kubernetes cluster. The images must be downloaded from Oracle\u0026rsquo;s Container Registry prior to continuing.\nLog into Oracle\u0026rsquo;s Container Registry: podman login container-registry.oracle.com Pull the Database Image: podman pull container-registry.oracle.com/database/enterprise:21.3.0.0 Pull the ORDS Image: podman pull container-registry.oracle.com/database/ords:21.4.2-gh Minikube brew install minikube minikube config set driver podman minikube start --cpus 4 --memory max --container-runtime=containerd minikube addons enable ingress If minikube fails to start due to: Failed kubeconfig update: could not read config, run: mv ~/.kube ~/.kube.bak and retry.\nDownload Oracle Backend for Spring Boot Download the Oracle Backend for Spring Boot and unzip into a new directory.\nInstall Ansible ./setup_ansible.sh source ./activate.env Define the Infrastructure Use the helper Playbook to define the infrastructure. This Playbook will also:\nCreate additional namespaces for the Container Registry and Database Create a Private Container Registry in the Kubernetes Cluster Modify the application microservices to be Desktop compatible Run: ansible-playbook ansible/desktop_apply.yaml\nOpen a Tunnel In order to push the images to the Container Registry in the Kubernetes cluster; open a new terminal and start a tunnel.\nRun: minikube tunnel\nTo test access to the registry: curl -X GET -k https://localhost:5000/v2/_catalog\nThe above curl should result in:\n{\u0026#34;errors\u0026#34;:[{\u0026#34;code\u0026#34;:\u0026#34;UNAUTHORIZED\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;authentication required\u0026#34;,\u0026#34;detail\u0026#34;:[{\u0026#34;Type\u0026#34;:\u0026#34;registry\u0026#34;,\u0026#34;Class\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;catalog\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;*\u0026#34;}]}]} Build the Images Build and Push the Images to the Container Registry in the Kubernetes cluster:\nRun: ansible-playbook ansible/images_build.yaml\nAfter the images are built and pushed, the tunnel is no longer required and can be stopped.\nDeploy Oracle Backend for Spring Boot Deploy the Database and Microservices.\nRun: ansible-playbook ansible/k8s_apply.yaml -t full\nNotes VPN and Proxies If you are behind a VPN or Proxy, please see https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/ for more details on additional tasks.\n","description":"On-Premises Installation - MacOS Ventura (x86) This is an example of installing on a MacOS Venture desktop\nPlease read the On-Premises and ensure your desktop meets the minimum system requirements.\nInstall Podman brew install podman PODMAN_VERSION=$(podman -v |awk \u0026#39;{print $NF}\u0026#39;) sudo /usr/local/Cellar/podman/${PODMAN_VERSION}/bin/podman-mac-helper install podman machine init --cpus 4 --disk-size 60 --memory 8192 --rootful --now podman system connection default podman-machine-default-root Download the Database/ORDS Images The Desktop installation will provision an Oracle Database into the Kubernetes cluster."},{"id":5,"href":"/microservices-datadriven/spring/on-premises/ol8/","title":"Ol8","parent":"On Premises","content":" On-Premises Installation - Oracle Linux 8 (x86) This is an example of installing on a MacOS Venture desktop\nPlease read the On-Premises and ensure your desktop meets the minimum system requirements.\nInstall Podman sudo dnf -y module install container-tools:ol8 sudo dnf -y install conntrack podman curl sudo dnf -y install oracle-database-preinstall-21c Download the Database/ORDS Images The Desktop installation will provision an Oracle Database into the Kubernetes cluster. The images must be downloaded from Oracle\u0026rsquo;s Container Registry prior to continuing.\nLog into Oracle\u0026rsquo;s Container Registry: podman login container-registry.oracle.com Pull the Database Image: podman pull container-registry.oracle.com/database/enterprise:21.3.0.0 Pull the ORDS Image: podman pull container-registry.oracle.com/database/ords:21.4.2-gh Install and Start Minikube curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64 sudo install minikube-linux-amd64 /usr/local/bin/minikube minikube config set driver podman minikube start --cpus 4 --memory 32768 --disk-size=\u0026#39;40g\u0026#39; --container-runtime=cri-o minikube addons enable ingress Download Oracle Backend for Spring Boot Download the Oracle Backend for Spring Boot and unzip into a new directory.\nInstall Ansible ./setup_ansible.sh source ./activate.env Define the Infrastructure Use the helper Playbook to define the infrastructure. This Playbook will also:\nCreate additional namespaces for the Container Registry and Database Create a Private Container Registry in the Kubernetes Cluster Modify the application microservices to be Desktop compatible Run: ansible-playbook ansible/desktop_apply.yaml\nOpen a Tunnel In order to push the images to the Container Registry in the Kubernetes cluster; open a new terminal and start a port-forward.\nRun: kubectl port-forward service/private -n container-registry 5000:5000\nTo test access to the registry: curl -X GET -k https://localhost:5000/v2/_catalog\nThe above curl should result in:\n{\u0026#34;errors\u0026#34;:[{\u0026#34;code\u0026#34;:\u0026#34;UNAUTHORIZED\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;authentication required\u0026#34;,\u0026#34;detail\u0026#34;:[{\u0026#34;Type\u0026#34;:\u0026#34;registry\u0026#34;,\u0026#34;Class\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;catalog\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;*\u0026#34;}]}]} Build the Images Build and Push the Images to the Container Registry in the Kubernetes cluster:\nRun: ansible-playbook ansible/images_build.yaml\nAfter the images are built and pushed, the port-forward is no longer required and can be stopped.\nDeploy Oracle Backend for Spring Boot Deploy the Database and Microservices.\nRun: ansible-playbook ansible/k8s_apply.yaml -t full\nNotes config-server and obaas-admin Pod Failures The pods in the config-server and obaas-admin namespaces rely on the database that is created in the oracle-database-operator-system. During initial provisioning these pods will start well before the database is available resulting in intial failures. They will resolve themselves once the database becomes available.\nVPN and Proxies If you are behind a VPN or Proxy, please see https://minikube.sigs.k8s.io/docs/handbook/vpn_and_proxy/ for more details on additional tasks. Specifically, when you start minikube, you may see the following messages:\n","description":"On-Premises Installation - Oracle Linux 8 (x86) This is an example of installing on a MacOS Venture desktop\nPlease read the On-Premises and ensure your desktop meets the minimum system requirements.\nInstall Podman sudo dnf -y module install container-tools:ol8 sudo dnf -y install conntrack podman curl sudo dnf -y install oracle-database-preinstall-21c Download the Database/ORDS Images The Desktop installation will provision an Oracle Database into the Kubernetes cluster. The images must be downloaded from Oracle\u0026rsquo;s Container Registry prior to continuing."},{"id":6,"href":"/microservices-datadriven/spring/release-notes/","title":"Release Notes","parent":"Oracle Backend for Spring Boot - Developer Preview","content":" Developer Preview 0.3.0, April 17, 2023 Notes:\nOracle Backend for Spring Boot now includes the option to install in a Multi-Cloud (OCI/Azure) Environment. The Oracle Database Operator for Kubernetes will be bound the existing ADB created by IaC in an all-OCI installation and will provision the ADB in the multi-cloud installation. Improvements to On-Premises and Desktop Installation process The following components were added:\nComponent New Version Description Oracle Backend for Spring Boot Visual Studio Code Extension 0.3.7 Allows Visual Studio Code users to manage the platform, deployments and configuration. The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot CLI 0.3.0 0.1.0 There were no component deprecations or removals.\nDeveloper Preview 0.2.3, March 8, 2023 Notes:\nOracle Backend for Spring Boot now includes the option to also install Parse Platform in the same deployment. Oracle Backend for Spring Boot CLI 0.2.3 includes a number of bug fixes, and adds support for custom listen ports for services. APISIX is now pre-configured for both Eureka and Kubernetes service discovery. The following components were added:\nComponent Version Description Oracle Database Operator for Kubernetes 0.6.1 Helps reduce the time and complexity of deploying and managing Oracle Databases Parse Server 5.2.7 Provides backend services for mobile and web applications Parse Dashboard 5.0.0 Web user interface for managing Parse Server Oracle Storage Adapter for Parse 0.2.0 Enables Parse Server to store data in Oracle Database The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot CLI 0.2.3 0.1.0 cert-manager 1.11.0 1.10.1 NGNIX Ingress Controller 1.6.4 1.5.1 Jaeger Tracing 1.39.0 1.37.0 APISIX 3.1.1 2.15.1 Eureka Service Registry 3.1.4 2021.0.3 There were no deprecations or removals.\nDeveloper Preview 0.2.0, February 27, 2023 The following components were added:\nComponent Version Description Oracle Transaction Manager for Microservices 22.3.1 Manages distributed transactions to ensure consistency across microservices Strimzi Kafka Operator 0.33.1 Manages Kafka clusters Apacha Kafka 3.2.0 - 3.3.2 Distributed event streaming There were no deprecations or removals.\nDeveloper Preview 0.1.0, January 30, 2023 The following components were added:\nComponent Version Description HashiCorp Vault v1.11.3 Provides a way of store and tightly control access to sensitive data Oracle Backend for Spring Boot CLI 0.1.0 Command line tool to manage application deployment and configuration Netflix Conductor OSS 3.13.2 Workflow orchestration for microservices On-premises installer 0.1.0 Allows you to install a self-hosted stack There were no deprecations or removals.\nDeveloper Preview 0.0.1, December 20, 2022 This release includes the following components:\nComponent Version Description cert-manager 1.10.1 Automates the management of certificates. NGINX Ingress Controller 1.5.1 Traffic management solution for cloud‑native applications in Kubernetes. Prometheus 2.40.2 Provides event monitoring and alerting. Prometheus Operator 0.60.1 Provides management for Prometheus monitoring tools. OpenTelemetry Collector 0.66.0 Collects process and export telemetry data. Grafana 9.2.5 Tool to help you examine, analyze, and monitor metrics. Jaeger Tracing 1.37.0 Distributed tracing system for monitoring and troubleshooting distributed systems. APISIX 2.15.1 Provides full lifecycle API Management. Spring Admin Server 2.7.5 Managing and monitoring Spring Boot applications. Spring Cloud Config Server 2.7.5 Provides server-side support for externalized configuration. Eureka Service Registry 2021.0.3 Provides Service Discovery capabilities ","description":"Developer Preview 0.3.0, April 17, 2023 Notes:\nOracle Backend for Spring Boot now includes the option to install in a Multi-Cloud (OCI/Azure) Environment. The Oracle Database Operator for Kubernetes will be bound the existing ADB created by IaC in an all-OCI installation and will provision the ADB in the multi-cloud installation. Improvements to On-Premises and Desktop Installation process The following components were added:\nComponent New Version Description Oracle Backend for Spring Boot Visual Studio Code Extension 0."},{"id":7,"href":"/microservices-datadriven/spring/security/","title":"Security","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot has the following security characteristics:\nAll access to the database is done using Mutual TLS (Database Wallet). The username, password and URI are stored in Kubernetes secrets.\nAccessing the dashboards can only be done using port forwarding.\nThe only \u0026ldquo;public\u0026rdquo; exposure is the APISIX Gateway (note that the dashboard is not exposed publicly).\nServices deployed to the platform are not exposed through the gateway automatically.\nThe deployed platform services are using using self-signed certificates.\nA customer application can only access service running in the platform via the APISIX Gateway. The IP address for the gateway can be determined by executing the following command:\nkubectl -n ingress-nginx get svc ingress-nginx-controller The customer application can be secured using Spring Security, e.g., Spring OAuth 2.0 Resource Server. An external authorization server is recommended (for example Okta, Oauth0)\nThe diagram below provides an overview of the security architecture.\n","description":"The Oracle Backend for Spring Boot has the following security characteristics:\nAll access to the database is done using Mutual TLS (Database Wallet). The username, password and URI are stored in Kubernetes secrets.\nAccessing the dashboards can only be done using port forwarding.\nThe only \u0026ldquo;public\u0026rdquo; exposure is the APISIX Gateway (note that the dashboard is not exposed publicly).\nServices deployed to the platform are not exposed through the gateway automatically."},{"id":8,"href":"/microservices-datadriven/spring/cluster-access/","title":"Access Kubernetes Cluster","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot setup creates a Kubernetes cluster where the server and dashboard components are deployed. At the end of setup, in the log for the apply job, you were provided with a command to creating a Kubernetes configuration file to access that cluster.\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the OCI documentation. kubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; Note: The generated kubeconfig file will only work if you are using the DEFAULT profile in your OCI CLI configuration file. If you are using a different OCI CLI profile you must add --profile \u0026lt;PROFILE-NAME\u0026gt; to the command. For example:\nkubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; --profile \u0026lt;PROFILE-NAME\u0026gt; You must also edit the the generated Kubernetes config file and add the following lines to the config file. For example:\n- --profile - \u0026lt;PROFILE-NAME\u0026gt; For example:\n- name: user-xxxx user: exec: apiVersion: client.authentication.k8s.io/v1beta1 args: - ce - cluster - generate-token - --cluster-id - ocid1.cluster....xxxx - --region - us-ashburn-1 - --profile - \u0026lt;PROFILE-NAME\u0026gt; command: oci Using OCI Cloud Shell A simple alternative is to use the OCI Cloud Shell, which is provided in the OCI Console. You can open Cloud Shell by clicking Developer Tools in the upper right hand corner of the OCI Console.\nOCI Cloud Shell icon Run the provided command to create your Kubernetes configuration file and then you will be able to access the Kubernetes cluster. For example, you can list the pods in your cluster:\nWelcome to Oracle Cloud Shell. Update: Cloud Shell will now use Oracle JDK 11 by default. To change this, see Managing Language Runtimes in the Cloud Shell documentation. Your Cloud Shell machine comes with 5GB of storage for your home directory. Your Cloud Shell (machine and home directory) are located in: US East (Ashburn). You are using Cloud Shell in tenancy xxxx as an OCI user xxxx Type `help` for more info. user@cloudshell:~ (us-ashburn-1)$ oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT Existing Kubeconfig file found at /home/user/.kube/config and new config merged into it user@cloudshell:~ (us-ashburn-1)$ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE ingress-nginx ingress-nginx-controller-7d45557d5c-bqwwp 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-klgnb 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-l4d2m 1/1 Running 0 4h18m kube-system coredns-746957c9c6-hwnm8 1/1 Running 0 4h27m kube-system csi-oci-node-kqf5x 1/1 Running 0 4h23m kube-system kube-dns-autoscaler-6f789cfb88-7mptd 1/1 Running 0 4h27m kube-system kube-flannel-ds-hb6ld 1/1 Running 1 (4h22m ago) 4h23m kube-system kube-proxy-v5qwm 1/1 Running 0 4h23m kube-system proxymux-client-vpnh7 1/1 Running 0 4h23m ......... user@cloudshell:~ (us-ashburn-1)$ ","description":"The Oracle Backend for Spring Boot setup creates a Kubernetes cluster where the server and dashboard components are deployed. At the end of setup, in the log for the apply job, you were provided with a command to creating a Kubernetes configuration file to access that cluster.\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the OCI documentation. kubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1."},{"id":9,"href":"/microservices-datadriven/spring/platform/apigw/","title":"API Gateway","parent":"Platform","content":"Apache APISIX is an open-source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nDeploy and Secure Sample Apps APIs using APISIX Oracle Backend for Spring Boot deploys APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the APISIX Dashboard, you must use kubectl port-forward to create a secure channel to service/apisix-dashboard.\nkubectl --namespace apisix get all APISIX K8s Exposing APISIX Dashboard using port-forward\nkubectl port-forward -n apisix svc/apisix-dashboard 8080:80 Open the APISIX Dashboard URL: http://localhost:8080\nusername: admin password: admin Note: Oracle recommends that you change the default password when you first login. Even though the dashboard is not accessible externally, we still recommend using strong passwords to maximize security.\nAPISIX Login Exposing a Spring application through the API Gateway and Load Balancer Once you have your application deployed and running, you may want to expose it to the outside world. Some applications may not need to be exposed if they are only called by other applications in the platform. To expose your application, you create a \u0026ldquo;route\u0026rdquo; in the APISIX API Gateway.\nCreate a Route to the Service\nIn the APISIX Dashboard, click on the \u0026ldquo;Routes\u0026rdquo; option in the menu on the left hand side.\nAPISIX Routes Click on the \u0026ldquo;Create\u0026rdquo; button to create a new route.\nFill out the necessary details (anything not mentioned here can be left at the default value). For example, for the \u0026ldquo;slow service\u0026rdquo; included in the sample apps:\nname = slow path = /fruit* method = get, options upstream type = service discovery discovery type = eureka service name = SLOW (note that this is case sensitive, this is the key from the Eureka dashboard) Note: The API Gateway is pre-configured with both \u0026ldquo;Eureka\u0026rdquo; and \u0026ldquo;Kubernetes\u0026rdquo; discovery types. For Eureka, the service name is the key used to deploy the service in Eureka, which is normally the value from spring.application.name in the Spring Boot configuration file (src/main/resources/application.yaml), in upper case. For Kubernetes, the service name is in the format namespace/service:port where namespace is the Kubernetes namespace in which the Spring Boot application is deployed, service is the name of the Kubernetes Service for that application, and port is the name of the port in that service. If you deployed your Spring Boot application with the Oracle Backend for Spring Boot CLI, the port name will be spring. So an application called slow-service deployed in the my-apps namespace would be my-apps/slow-service:spring for example.\nAPISIX Routes Step1 APISIX Routes Step2 APISIX Routes Step3 Save the route you created.\nAPISIX Routes Step4 APISIX Routes Step5 Test a Route to the Service\nGet the APISIX Gateway External IP using this command:\nkubectl -n ingress-nginx get svc ingress-nginx-controller Call API using APISIX Gateway address plus path:\ncurl http://APISIX_IP/fruit You should get \u0026ldquo;banana\u0026rdquo; or \u0026ldquo;fallback fruit is apple\u0026rdquo; back as the response.\n","description":"Apache APISIX is an open-source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nDeploy and Secure Sample Apps APIs using APISIX Oracle Backend for Spring Boot deploys APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the APISIX Dashboard, you must use kubectl port-forward to create a secure channel to service/apisix-dashboard."},{"id":10,"href":"/microservices-datadriven/spring/platform/config/","title":"Configuration","parent":"Platform","content":"Oracle Backend for Spring Boot includes the Spring Config which provides server and client-side support for externalized configuration in a distributed system. The Spring Config Server provides a central place to manage external properties for applications across all environments.\nThe Spring Config Server is pre-configured to work with the Spring Eureka Service Registry, and it is configured to store the configuration in the Oracle Autonomous Database, so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content. Configuration is stored in the CONFIGSERVER schema in the PROPERTIES table.\nAn example of a Config Server client\u0026rsquo;s Spring application.yaml configuration file could include:\nspring: config: import: optional:configserver:http://config-server.config-server.svc.cluster.local:8080 application: name: atael cloud: config: label: latest profile: dev This will fetch data in the value where the application is atael, profile is dev and the label is latest.\nManaging the data for the Config Server should be done using the CLI. If you prefer, you can also work directly with the CONFIGSERVER.PROPERTIES table in the database.\n","description":"Oracle Backend for Spring Boot includes the Spring Config which provides server and client-side support for externalized configuration in a distributed system. The Spring Config Server provides a central place to manage external properties for applications across all environments.\nThe Spring Config Server is pre-configured to work with the Spring Eureka Service Registry, and it is configured to store the configuration in the Oracle Autonomous Database, so it easily supports labelled versions of configuration environments, as well as being accessible to a wide range of tooling for managing the content."},{"id":11,"href":"/microservices-datadriven/spring/database/","title":"Database Access","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"The Oracle Backend for Spring Boot includes an Oracle Database. An instance of the Oracle Autonomous Database (Shared) is created during installation.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for your database during installation (or just accepted the default), then you can use the Database Actions web user interface to work with your database. If you chose the \u0026ldquo;private\u0026rdquo; option, you need to use a bastion to access the database.\nUsing Database Actions To work with data in the database, you can use the Database Actions interface, which can be accessed from the OCI Console. The Oracle Database is created in the same compartments as OKE. In the OCI Console, navigate to Autonomous Database in the main menu and select the database with the Application Name you configured during install, with the suffix “DB”, for example “OBAASTSTPSDB”.\nOracle Autonomous DB Cloud Portal Click on the link to access the database details page, and then click on the “Database Actions” button:\nOracle Autonomous DB Details This will open the Database Actions page, where you have access to many database functions, including the ability to work with the schemas where your Oracle Backend for Spring Boot data are stored.\nAccessing the database from a local workstation After creating the Oracle Backend for Spring Boot environment, you will have to access to Autonomous Database for access, for example, the CONFIGSERVER.PROPERTIES, a table where Applications should add their properties. Also, each application can use the same database instance to host its data.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for database access during installation (or accepted this default), you can download the wallet to access the database from your local machine.\nIf you chose the \u0026ldquo;private\u0026rdquo; option for database access during installation, the database will be configure so that it is only accessible from the private VCN, and access will only be possible using the Bastion Service provisioned during installation.\nCreate Dynamic port forwarding (SOCKS5) session using Bastion service.\nLet\u0026rsquo;s start with ADB access that was created with private end point access only following security guidance. To allow you get access to ADB to run sql commands you will need to stablish an session between your local workstation and ADB passing by the Bastion service.\nWe will create a Dynamic port forwarding (SOCKS5) session.\nDownload ADB client credential After session create you will be able to stablish the tunnel with your ADB Instance issuing a SSH command that you can obtain clicking on three dots menu on right side of the session created.\nssh -i \u0026lt;privateKey\u0026gt; -N -D 127.0.0.1:\u0026lt;localPort\u0026gt; -p 22 ocid1.bastionsession.oc1.phx....@host.bastion.us-phoenix-1.oci.oraclecloud.com Connect with ADB Instance using SQLcl\nWith tunnel stablished, you will be able to connect with ADB instance. First export the Oracle Net port executing the next commmand:\nexport CUSTOM_JDBC=\u0026#34;-Doracle.net.socksProxyHost=127.0.0.1 -Doracle.net.socksProxyPort=\u0026lt;PORT\u0026gt; -Doracle.net.socksRemoteDNS=true\u0026#34; Download ADB client credentials (Wallet):\nDownload ADB client credential Connect with SQLcl\nsql /nolog set cloudconfig \u0026lt;WALLET\u0026gt;.zip connect ADMIN@\u0026lt;TNS_NAME\u0026gt; ","description":"The Oracle Backend for Spring Boot includes an Oracle Database. An instance of the Oracle Autonomous Database (Shared) is created during installation.\nIf you chose the \u0026ldquo;secure access from anywhere\u0026rdquo; option for your database during installation (or just accepted the default), then you can use the Database Actions web user interface to work with your database. If you chose the \u0026ldquo;private\u0026rdquo; option, you need to use a bastion to access the database."},{"id":12,"href":"/microservices-datadriven/spring/observability/metrics/","title":"Metrics","parent":"Observability","content":"The Oracle Backend for Spring Boot metrics stack automates metrics aggregation and consists of Prometheus and Grafana components. Metrics sources expose system and application metrics. The Prometheus components retrieve and store the metrics and Grafana provides dashboards to visualize them.\nMetrics View metrics from the application in Prometheus Prometheus is an open-source systems monitoring and alerting. Prometheus collects and stores its metrics as time series data, metrics are stored with the timestamp at which they were recorded, and optional key-value pairs called labels.\nExposing Prometheus UI using port-forward\nkubectl port-forward -n prometheus svc/prometheus 9090:9090 Open the Prometheus UI URL: http://localhost:9090\nPrometheus UI In the Prometheus web user interface you can search for metrics:\nIn the search bar, search for application_ready_time_seconds and click on the Execute button Notice you see metrics for the sample applications Prometheus Metrics In the Prometheus web user interface the Status menu item allow you view the targets being monitored by Prometheus:\nIn the top menu, choose Status and then Targets Notice targets \u0026ldquo;slow\u0026rdquo;, \u0026ldquo;customer\u0026rdquo; and others are in \u0026ldquo;UP\u0026rdquo; status and others are in \u0026ldquo;Down\u0026rdquo;. Prometheus Targets View details of the application in Grafana Grafana open source software enables you to query, visualize, alert on, and explore your metrics, logs, and traces wherever they are stored. Grafana OSS provides you with tools to turn your time-series database (TSDB) data into insightful graphs and visualizations.\nExposing Grafana using port-forward\nkubectl -n grafana port-forward svc/grafana 8080:80 Open the Grafana UI URL: http://localhost:8080\nusername: admin\nTo get the password run this command:\nkubectl -n grafana get secret grafana -o jsonpath=\u0026#39;{.data.admin-password}\u0026#39; | base64 -d Note: If you don\u0026rsquo;t have \u0026ldquo;base64\u0026rdquo; leave off the last part (\u0026quot;| base64 -d\u0026quot;) and then copy the output and use this website to decode it: https://www.base64decode.org/. The password will be a long string of characters like this 210BAqNzYkrcWjd58RKC2Xzerx9c0WkZi9LNsG4c (yours will be different)\nGrafana Login Setup Prometheus Datasource\nOn the left hand side menu, down the bottom, click on the cog wheel and choose Data Sources Click on the second data source, its called \u0026ldquo;Prometheus\u0026rdquo; \u0026amp; In the address (be careful to get the address field, not the name field), change the address from http://prometheus:9090 to http://prometheus.prometheus.svc.cluster.local:9090 Down the bottom of the page click on save \u0026amp; test and wait for the green icon to say the datasource is working (takes 2-3 seconds) Grafana Datasource Setup Dashboard\nNow in the left hand side menu up the top, find the dasbhoards link and click on that Click on the blue button on the right to add a new dashboard, and in the pull down select \u0026ldquo;import\u0026rdquo; In the field for the grafana dashboard ID, paste in this value: 10280 Click on next In the datasource field, choose the one called \u0026ldquo;prometheus\u0026rdquo; Click on save Grafana Import Dashboard Navigate in Spring Boot Dashboard\nNow you should see the new dashboard in the list - it is called Spring Boot Dashboard 2.1 - click on it to open it You should automatically see details for the sample applications in the dashboard Incoke the service, e.g., using curl, a number of times to create some traffic and observe the dashboard. There is round arrow icon in the top right corner that enables automatic refresh every 5 seconds (or whatever period you choose). Grafana Dashboard ","description":"The Oracle Backend for Spring Boot metrics stack automates metrics aggregation and consists of Prometheus and Grafana components. Metrics sources expose system and application metrics. The Prometheus components retrieve and store the metrics and Grafana provides dashboards to visualize them.\nMetrics View metrics from the application in Prometheus Prometheus is an open-source systems monitoring and alerting. Prometheus collects and stores its metrics as time series data, metrics are stored with the timestamp at which they were recorded, and optional key-value pairs called labels."},{"id":13,"href":"/microservices-datadriven/spring/observability/","title":"Observability","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot includes a number of common open-source components to provide application observability including Prometheus, Grafana, Jaeger and Open Telemetry Collector.\nFor more details, please read about:\nMetrics Tracing ","description":"Oracle Backend for Spring Boot includes a number of common open-source components to provide application observability including Prometheus, Grafana, Jaeger and Open Telemetry Collector.\nFor more details, please read about:\nMetrics Tracing "},{"id":14,"href":"/microservices-datadriven/spring/","title":"Oracle Backend for Spring Boot - Developer Preview","parent":"","content":"Oracle Backend for Spring Boot allows developers to build microservices in Spring Boot and provision a backend as a service with the Oracle Database and other infrastructure components that operate on multiple clouds. This service vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nIn addition to an Oracle Autonomous Database Shared instance, the following software components are deployed in an Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE) cluster:\nAPISIX API Gateway and Dashboard Spring Eureka Service Registry Spring Admin Dashboard Spring Config Server Netflix Conductor Prometheus Grafana Open Telemetry Collector Jaeger HashiCorp Vault Developers also have access to development/build time services and libraries including:\nA CLI to manage service deployment and configuration, including database schema management Spring Data (JPA, JDBC) to access Oracle Database Oracle JDBC drivers Spring Config client Spring Eureka Service Discovery client OpenFeign Open Telemetry (including automatic instrumentation) Interested in Mobile or web apps too? Check out Oracle Backend for Parse Platform! Developer Preview This release is a Developer Preview. This means that not all functionality is complete. In this release, most of the planned services and components are provided, however additional configuration options and components may be provided in a future release. We are releasing this as a developer preview to allow interested developers to try it and give feedback.\n","description":"Oracle Backend for Spring Boot allows developers to build microservices in Spring Boot and provision a backend as a service with the Oracle Database and other infrastructure components that operate on multiple clouds. This service vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nIn addition to an Oracle Autonomous Database Shared instance, the following software components are deployed in an Oracle Cloud Infrastructure Container Engine for Kubernetes (OKE) cluster:"},{"id":15,"href":"/microservices-datadriven/spring/platform/vscode-plugin/","title":"Oracle Backend for Spring Boot VS Code plugin","parent":"Platform","content":"Developer Preview 0.3.7 - April, 2023\nOracle Backend for Spring Boot VS Code plugin is an extension to browse and deploy applications on the Oracle Backend for Spring Boot platform. This plugin allows to inspect the content of an Oracle Backend for Spring Boot deployment, in terms of applications, services and related configurations. It simplifies the access to the Platform Services installed, like Grafana, Spring, Apisix, Eureka and Jaeger creating ssh tunnels on-demand, and providing access to their respective web admin consoles. It allows to add credentials to access and bind services to the Oracle Autonomous DB included into Oracle Backend for Spring Boot deployment. This plug-in replicates the functionalities available in OBaas CLI and simplify the access to Oracle Backend for Spring Boot deployments from a development IDE like VS Code.\nOracle Free Use Terms and Conditions License\nPrerequisites Already installed and configured:\nThe Kubernetes command-line tool (kubectl) Oracle Cloud Infrastructure Command Line Interface (CLI) as required for the Oracle Backend for Spring Boot setup.\nInstallation Download the plug-in from here\nOn the VS Code right menu bar, click on Extensions item:\nFrom the up-right corner menu, choose Install from VSIX\u0026hellip;:\nand upload plug-in binaries previously downloaded.\nRe-start VS Code to make fully operative the plugin.\nIf you don\u0026rsquo;t see the plugin in the left bar, with the Oracle logo, as shown here:\nclick on Additional Views menu to select the eBaaS Explorer.\nUsing VS Code plugin Selecting the plugin from the left plugin menu bar, the Oracle Backend for Spring Boot VS Code plugin will ask to specify the Kubernetes config file full path as shown here:\nBy default it\u0026rsquo;s shown the path in the user\u0026rsquo;s Home directory .kube/config in which normally kubectl stores all the information regarding the K8S clusters configured. You could set the full path of another Kubernetes config file. If the file is correctly loaded, the plugin will show the list of contexts available in which select one:\nIn positive case, you should see a tree view with one node and the context chosen:\nIf the file path it hasn\u0026rsquo;t been correctly set, it will shown an error message:\nTo restart the plugin and proceed again in Kubernetes config file setting, in command palette execute a window reload:\nHow to access to cluster Until you create a dedicated ssh tunnel to the Kubernetes cluster, and you don\u0026rsquo;t connect to Oracle Backend for Spring Boot admin services, you will not be able to browse resources included into the Oracle Backend for Spring Boot deployment. To do this, follow these steps:\nSelect the cluster and click on the wheel symbol to set the credentials:\nOn top menu, it will be required the Oracle Backend for Spring Boot admin password:\nand admin Oracle Backend for Spring Boot\u0026rsquo;s user for the deployment:\nTwo message boxes will confirm credentials have been set correctly:\nNOTE: if you don\u0026rsquo;t execute this steps and try to expand the kubernetes context, you will receive a message:\nSelect again the cluster and click the right mouse button and choose Create tunnel menu item. VS Code will open a new terminal that will try to open a tunnel to the Kubernetes cluster on a local port, starting from 8081:\nBefore proceed to connection, please wait until the tunnel is established and the terminal shows a message like this:\nNOTE: if the K8s cluster it\u0026rsquo;s not related to an Oracle Backend for Spring Boot deployment, the tunnel creation will fail. In this case in command palette execute a window reload to chose another cluster. If you have any problem in connection, you could start another tunnel: the plugin will try on another local port to connect to the cluster.\nAgain select the cluster and by clicking the right mouse button choose Connect menu item. This will create a session with credentials set at the first step.\nExplore resources As soon as completed the steps to create tunnel and you get connected to the backend, it\u0026rsquo;s possible to expand or refresh the tree related to the deployment.\nYou\u0026rsquo;ll see four top classes of resources that can be exploded in underlying items:\napplications: the list of applications deployed and the services holding ADB: in this release we have one ADB in which are stored configuration and schema related to services deployed platformServices: the list of Oracle Backend for Spring Boot deployed services, like Grafana, Spring, Apisix, Eureka and Jaeger. oBaasConf: the list of keys defined by application, stored in the ADB provisioned and available to share configuration information among services in each application. Let\u0026rsquo;s go to show the operations you can do on each item of browse tree.\nApplications Open the list clicking on the arrow at the left of applications:\nand then expand the application about you want to know which services includes:\nAt root level, by clicking the right mouse button on applications leaf, chose Add application to create a new application. On VS Code Command Palette will appear the prompt to set the application name it will be created:\nTo show the list updated, click on the Refresh icon on right side of applications item.\nOn each application, you can Add service -\u0026gt; upload .jar or Delete Application.\nAdd Service The Add Service command imply the upload of a Spring Boot microservice in an Application context. Clicking Add service -\u0026gt; upload .jar menu item on a specific application:\nin the VS Code Command Palette prompt will be required the parameters needed, in this order:\nA popup will be opened to select the local Spring Boot .jar file\nif you need to bind the service to an user/schema in DB:\nService Name\nDB User Password you have to set only if you have chosen to bind a schema on DB the service you are deploying:\nSpring Binding prefix (Default: spring.datasource)\nImage Version (Default: 0.1)\nJava image (Default: ghcr.io/graalvm/jdk:ol7-java17-22.2.0)\nRedeploy (Default: false)\nAdd Health probe (Default: false)\nService Port (Default: 8080)\nService Profile (Default: obaas)\nAt the end of parameters collection, it will be started the binding and upload process that will generate a sequence of messages showing the status. These messages will end with \u0026ldquo;Service deployed successfully!\u0026rdquo; or \u0026ldquo;Deploy failed\u0026rdquo;. According to the size and network constraints, the process will take more or less time to terminate.\nDelete Service You can delete an existing service or one you have deployed from VS Code extension. In either cases, you have to select the service and click the right mouse button to select the only command available, i.e. Delete service. Also in this case, you should refresh the tree at application level to have an updated view and, sometimes, more than one time.\nDelete Application This command will remove the application and all the services included. At the end of process it will be shown a message \u0026ldquo;Delete successful\u0026rdquo; or \u0026ldquo;Delete application failed!\u0026rdquo;. After that you can refresh the tree, at single application level and then at applications level. Take in consideration that the termination of pods and application isn\u0026rsquo;t synchronous operation: so it could happen you have to refresh more than one times to have a clean view.\nADB database For each Oracle Backend for Spring Boot is provisioned an Oracle Autonomous Transaction Processing Database to hold the schema related to the Spring Boot services and configuration details. To store the Admin DB Password you can click the wheel shown next to the ADB database item. In the VS Code Command Palette will be prompted the password:\nplatformServices This leaf of tree can be expanded to show the services available in the Oracle Backend for Spring Boot platform. For each of them, by clicking the right mouse button on the leaf you can open an ssh tunnel to the service on a specific local port automatically chosen. At the end, it will prompted a link to open in the default web browser the admin console of each platform services. For example, by clicking the right mouse button on grafana console:\nit will be opened a tunnel and a message with a button opening a web browser on the admin Grafana\u0026rsquo;s console will be shown:\nNOTE: if something goes wrong, like port already used or a timeout opening the connection, you can open another ssh tunnel: it will be automatically opened on another port.\noBaasConf Oracle Backend for Spring Boot offers to developers a store for the metadata and configurations useful to share info among pods in an application. The VS Code plug-in can browse the content of this key-value store, add, update and delete keys according the needs. Expanding the leaf oBaasConf you will see the applications deployed and, expanding each of them, the key-value pair, as shown in the following pictures:\nMoving mouse on each key-value pair, you can see the other metadata related to the key, profile and label. In the following picture, the key spring.datasource.url with value \u0026lsquo;jdbc:oracle:thin:@$\u0026hellip;.\u0026rsquo; has the property application coming from the root, i.e. cloudbank, profile=1.0 and label=kube.\nThe operation that can be done are:\nAdd key: by clicking the right mouse button on an oBaasConf or service-conf item, in the VS Code Command Palette will be requested:\nService name\nLabel\nProfile\nPropKey\nValue\nNOTE: you can add a config properties also for a Service not yet deployed. In some case it is mandatory to prepare properties before deploy services in order to correctly startup them.\nEdit key: by clicking the right mouse button on a selected key, in the VS Code Command Palette will be requested to update the current content Value\nDelete key: by clicking the right mouse button on a selected key, it will possible delete it.\n","description":"Developer Preview 0.3.7 - April, 2023\nOracle Backend for Spring Boot VS Code plugin is an extension to browse and deploy applications on the Oracle Backend for Spring Boot platform. This plugin allows to inspect the content of an Oracle Backend for Spring Boot deployment, in terms of applications, services and related configurations. It simplifies the access to the Platform Services installed, like Grafana, Spring, Apisix, Eureka and Jaeger creating ssh tunnels on-demand, and providing access to their respective web admin consoles."},{"id":16,"href":"/microservices-datadriven/spring/platform/","title":"Platform","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot includes a number of Spring platform components that provide services to applications deployed into the platform.\nFor more details, please read about: - API Gateway - Service Discovery - Configuration - Workflow - Spring Admin - Using the CLI - Vault\n","description":"Oracle Backend for Spring Boot includes a number of Spring platform components that provide services to applications deployed into the platform.\nFor more details, please read about: - API Gateway - Service Discovery - Configuration - Workflow - Spring Admin - Using the CLI - Vault"},{"id":17,"href":"/microservices-datadriven/spring/blogs/","title":"Read our blogs!","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Our team members post blog articles and other content on various sites including Medium, LinkedIn (Corrado de Bari, Doug Drechsel), RedStack, DZone, and the Oracle Developers Blog. We\u0026rsquo;d love you to check them out. This page acts as an index/aggregator for some of our featured content.\nLong Running Actions\nPaul Parkinson demonstrates a Spring Boot microservices application that implements the Saga pattern with Long Running Actions using the Oracle Transaction Manager for Microservices to manage data consistency across microservices.\nPaul Parkinson - 4/18/2023\nIntroducing Cloud Bank\nAnd introduction to the Cloud Bank sample application which showcases Spring Boot microservices, long running actions/sagas and a Flutter mobile application built with the Oracle Backend for Spring Boot.\nMark Nelson - 4/6/2023\nDeveloping Saga Participant Code For Compensating Transactions\nA detailed comparison of the saga pattern with XA (2PC) comparing the pros and cons of each approach to provide data integrity between multiple services and for potentially long running transactions.\nPaul Parkinson - 3/27/2023\nOracle Backend for Spring Boot is LIVE! (Developer Preview)\nAn introduction to the Oracle Backend for Spring Boot.\nAndy Tael - 3/25/2023\nA First Spring Boot Service with Oracle\nA detailed guide to building a Spring Boot microservice from scratch that uses Spring Data JPA to manage data in the Oracle Database and exposes various endpoints to access the data.\nMark Nelson - 2/3/2023\nReact Native and Oracle MBaaS – a beginner’s tutorial\nA step-by-step guide to building a React Native mobile application using the Parse APIs and Oracle Backend for Parse Platform.\nCorrado de Bari - 1/5/2023\nOracle Mobile Backend as a Service (MBaaS)\nAn introduction and walk-through of the Oracle Backend for Parse Platform, including installation, using the dashboard, getting started with application development and integration with the Oracle Autonomous Database.\nDoug Drechsel - 12/23/2022\nReact.JS on Oracle MBaaS\nA step-by-step guide to implement a simple ReactJS app leveraging Oracle MBaaS.\nCorrado de Bari - 12/22/2022\nTwo new Backend as a Service offerings live now!\nA brief announcement and introduction to our Developer Preview releases of Oracle Backend for Spring Boot and Parse Platform.\nMark Nelson - 12/21/2022\nDevelopment Environment Setup with Spring Boot For Oracle\nA detailed guide to setting up a development environment to build Spring Boot microservices with the Oracle Database.\nMark Nelson - 12/8/2022\nBackend-as-a-Service (BaaS) and Oracle Database (Video) OCW Teaser\nErin Dawson, DevRel Communications Manager talks with Mark about the Oracle CloudWorld 2022 presentations and hands-on labs for Oracle Backend for Spring Boot and Parse Platform.\nMark Nelson - 10/12/2022\nOracle REST Data Services 22.3 bring new REST APIs for Transactional Event Queues\nAn announcement and several example that show how to use the new REST APIs for Transactional Event Queues.\nMark Nelson - 10/11/2022\nGetting Started with the New Observability Exporter for Oracle Database\nA simple step-by-step getting started example that shows you how to use the Observability Exporter for Oracle Database to expose data from the Oracle Database as Promeheus metrics.\nMark Nelson - 9/27/2022\nDevelop React \u0026#43; GraphQL \u0026#43; Spring Data JPA \u0026#43; UCP \u0026#43; Oracle\nA a succinct description and example of a modern full stack microservice app including a React frontend service that conducts GraphQL queries against a Spring Boot Data JPA backend service that in turn maps to an Oracle database.\nPaul Parkinson - 9/18/2022\nUnified Observability Exporters: Metrics, Logs, and Tracing\nA deep dive into metrics, logs and tracing exporters for the Oracle Database and how to configure them with Grafana to provide unified observability for microservices and the Oracle Database.\nPaul Parkinson - 8/11/2022\nLet the Oracle Database Operator for Kubernetes Do the Job\nAn introduction to and overview of the Oracle Database Operator for Kubernetes.\nPaulo Simoes - 1/6/2022\nHow to use Vaults and Wallets for Simple Secure Connectivity\nProvides details on how to secure connections in Java, JavaScript, Python, .NET, and Go as well as convenience integration features that are provided by microservice frameworks, specifically Helidon and Micronaut.\nPaul Parkinson - 12/18/2021\nDeveloping Event Driven Microservices in Java, Javascript, PL/SQL, Go, Python\nLearn about developing Event-Driven Microservices in Java, JavaScript, Python, .NET, and Go with AQ/TEQ in the Oracle Database.\nPaul Parkinson - 12/17/2021\nApache Kafka vs Oracle Transactional Event Queues for Event Driven Microservices\nComparing transactional and message delivery behavior, as it relates to microservice architectures (event mesh, event sourcing, etc.) Kafka and Oracle Transaction Event Queues.\nPaul Parkinson - 9/23/2021\n","description":"Our team members post blog articles and other content on various sites including Medium, LinkedIn (Corrado de Bari, Doug Drechsel), RedStack, DZone, and the Oracle Developers Blog. We\u0026rsquo;d love you to check them out. This page acts as an index/aggregator for some of our featured content.\nLong Running Actions\nPaul Parkinson demonstrates a Spring Boot microservices application that implements the Saga pattern with Long Running Actions using the Oracle Transaction Manager for Microservices to manage data consistency across microservices."},{"id":18,"href":"/microservices-datadriven/spring/sample-apps/","title":"Sample Apps","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Sample applications that demonstrate Oracle Backend for Spring Boot use cases.\nPrerequisites GraalVM or OpenJDK 17 (OpenJDK Runtime Environment GraalVM CE 22.3.0 (build 17.0.5+8-jvmci-22.3-b08) recommended) Apache Maven 3.8+ A container runtime (to login and push images to OCI Registry), e.g., Docker Make a Clone of the Sample Apps Source Code Now that you have your Oracle Backend for Spring Boot environment available and accessible, you can deploy the sample applications.\nCreate a clone from the GitHub repository using the following command. git clone https://github.com/oracle/microservices-datadriven.git cd developer-preview/sample-spring-apps/ This directory contains the sample applications\u0026rsquo; source code.\nCreate OCI Repositories for Sample Applications Before building the sample applications, you have to create the repositories for each sample application in your compartment. The name of the repository should follow the pattern \u0026lt;project name\u0026gt;/\u0026lt;app name\u0026gt;\nNote: If you do not pre-create the repositories, they will be created in the root compartment on the first push.\nOCI-R : Create Repository to host application image The required repositories are:\n\u0026lt;project\u0026gt;/banka \u0026lt;project\u0026gt;/bankb \u0026lt;project\u0026gt;/customer \u0026lt;project\u0026gt;/fraud \u0026lt;project\u0026gt;/notification \u0026lt;project\u0026gt;/slow_service Create an Authentication Token to login to OCI Registry by following the instructions on Generating an Auth Token to Enable Login to Oracle Cloud Infrastructure Registry\nLogin to OCI Registry by executing the following command. This will allow the build to push the sample applications\u0026rsquo; container images to OCI Registry.\nNote: A container runtime that allows you to push images to remote registries is required.\nYou can determine the \u0026lt;region\u0026gt; value from Region code. For example the US East (Ashburn) has the region code iad.\ndocker login \u0026lt;region\u0026gt;.ocir.io \\ --username \u0026lt;tenancy\u0026gt;/oracleidentitycloudservice/\u0026lt;username\u0026gt; \\ --password \u0026#34;\u0026lt;auth-token\u0026gt;\u0026#34; Note: If your account is federated you need to include /oracleidentitycloudservice/ in front of the username as shown above.\nBuild the sample applications and push container images Update the pom.xml in the root directory to match the OCI Registry repository prefix you used above. Configure the region, tenancy and project name:\n\u0026lt;properties\u0026gt; \u0026lt;container.registry\u0026gt;region ocir address/tenancy name/project name\u0026lt;/container.registry\u0026gt; \u0026lt;/properties\u0026gt; For example, if your region is Phoenix and project name is myproject:\n\u0026lt;properties\u0026gt; \u0026lt;container.registry\u0026gt;phx.ocir.io/mytenancy/myproject\u0026lt;/container.registry\u0026gt; \u0026lt;/properties\u0026gt; Run the Maven package goal with the build-docker-image profile using this command:\nmvn package -P build-docker-image When the command completes the build and push process (it will take a few minutes), you will see a message similar to the one below reporting that all modules were built successfully.\nIf you get a build failure, check the output for details of any errors, correct them, and then re-run the command.\nOBaaS : Sample Application build results Update Images in Kubernetes Deployment Descriptors You need to update the address of the images in application deployment descriptor to match the repositories you created. You do this by editing the 01--deployment--APPLICATION_NAME.yaml file in each of the service sub-directories (a total of six). Use the same values you used when editing the pom.xml file in the previous steps.\nspec: containers: - name: app_name image: phx.ocir.io/mytenancy/myproject/app_image:latest Create Database Objects for each application You must create the database users and some objects that are required by the sample services. Connect to the Oracle Autonmous Database instance using (using these instructions) and run the SQL statements for each application. You must edit each SQL script to add your desired password before running the statements.\nEach of the following files must be reviewed, updated, and then processed against the database (as the ADMIN user).\nCustomer microservice\ndb-01-customer-create-user.sql Fraud microservice\ndb-01-fraud-create-user.sql Notification microservice\ndb-01-notification-create-user.sql db-03-notifications-db-queue.sql Add applications configurations into Spring Config Server Properties Table You must create the application configuration entries that are required by the sample services. Connect to the Oracle Autonmous Database instance using (using these instructions) and run the SQL statements for each application. You must edit each SQL script to match your environment before running the statements. The example below shows the lines that must be updated. You must replace the TNS_NAME with the correct name for your database. If your database is called OBAASDB then the TNS_NAME is OBAASDB_TP.\nINSERT INTO CONFIGSERVER.PROPERTIES(APPLICATION, PROFILE, LABEL, PROP_KEY, \u0026#34;VALUE\u0026#34;) VALUES ( \u0026#39;APPLICATION_NAME\u0026#39;, \u0026#39;kube\u0026#39;, \u0026#39;latest\u0026#39;, \u0026#39;spring.datasource.url\u0026#39;, \u0026#39;jdbc:oracle:thin:@TNS_NAME?TNS_ADMIN=/oracle/tnsadmin\u0026#39; ); Each of the following files must be reviewed, updated, and then run against the database (as the ADMIN user).\nCustomer microservice:\ndb-02-customer-configserver-props.sql Fraud microservice:\ndb-02-fraud-configserver-props.sql Notification microservice:\ndb-02-notification-configserver-props.sql Add Kubernetes Secrets for each application\u0026rsquo;s database credentials For each application, you need to create a Kuberentes secret containing the database username and password that you chose in the previous steps. You can create these secrets by executing the following commands (update the values to match your environment):\nCustomer microservice:\nkubectl -n application \\ create secret generic oracledb-creds-customer \\ --from-literal=spring.db.username=CUSTOMER \\ --from-literal=spring.db.password=[DB_PASSWORD] Fraud microservice:\nkubectl -n application \\ create secret generic oracledb-creds-fraud \\ --from-literal=spring.db.username=FRAUD \\ --from-literal=spring.db.password=[DB_PASSWORD] Notification microservice:\nkubectl -n application \\ create secret generic oracledb-creds-notification \\ --from-literal=spring.db.username=NOTIFICATIONS \\ --from-literal=spring.db.password=[DB_PASSWORD] Deploy the applications Apply each application\u0026rsquo;s Kubernetes Deployment YAML using kubectl:\ncd \u0026lt;app dir\u0026gt; kubectl apply -f 01--deployment--\u0026lt;app name\u0026gt;.yaml Deploy each application\u0026rsquo;s Kuberenetes Service YAML using kubectl:\nkubectl apply -f 02--service--\u0026lt;app name\u0026gt;.yaml After deploying all microservices, you will be able to check they are running on Kubernetes using the following command:\nkubectl --namespace=application get all -o wide OBaaS : All resources from the Sample Application deployed on Kubernetes Explore the applications Before using the applications, you need to expose them by creating a route in APISIX API Gateway.\nTo expose the customer service, see the documentation on how to create a route and use these values:\nname = customer path = /api/v1/customers* method = get, post, options upstream type = service discovery discovery type = eureka service name = CUSTOMER (note that this is case sensitive, this is the key from the Eureka dashboard) Once the route is created, you can access the service using the load balancer IP address (as described on that page) using a call like this, for example, to create a customer:\ncurl -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;firstName\u0026#34;: \u0026#34;bob\u0026#34;, \u0026#34;lastName\u0026#34;: \u0026#34;smith\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;bob@bob.com\u0026#34;}\u0026#39; \\ http://1.2.3.4/customer/api/v1/customers After you call the service a few times, you might also like to explore the various platform services, including:\nSpring Admin Dashboard where you can see details of the service including metrics, configuration, what endpoints it exposes, what Spring beans are used, etc. Spring Eureka Service Registry where you can see which services are registered and discoverable Prometheus and Grafana which allow you to view metrics and dashboards about the service performance Jaeger which will let you view traces of service executions. For the cusomter service, look for a trace of the POST to /api/v1/customers above. It will show interaction between the customer, fraud and notification services and each one writing to its own data store. The notification service also enqueues a message. ","description":"Sample applications that demonstrate Oracle Backend for Spring Boot use cases.\nPrerequisites GraalVM or OpenJDK 17 (OpenJDK Runtime Environment GraalVM CE 22.3.0 (build 17.0.5+8-jvmci-22.3-b08) recommended) Apache Maven 3.8+ A container runtime (to login and push images to OCI Registry), e.g., Docker Make a Clone of the Sample Apps Source Code Now that you have your Oracle Backend for Spring Boot environment available and accessible, you can deploy the sample applications."},{"id":19,"href":"/microservices-datadriven/spring/platform/eureka/","title":"Service Discovery","parent":"Platform","content":"Oracle Backend for Spring Boot includes the Spring Eureka Service Registry, which is an application that stores information about client services/applications. Typically, each microservice will register with the Eureka server at startup and the Eureka server will maintain a list of all active instances of the service, including their ports and IP addresses. This information can be looked up by other services using a well-known key. This allows services to interact with each other without needing to know each others\u0026rsquo; addresses at development/deployment time.\nAccess the Eureka web user interface Expose the Eureka web user interface using port-forward\nkubectl port-forward -n eureka svc/eureka 8761:8761 Open the Eureka web user interface: http://localhost:8761\nEureka web user interface On the web page, you will see all of the services registered with Eureka. If you deployed the sample apps, look for an entry called \u0026ldquo;SLOW\u0026rdquo; - the presence of this entry confirms that the application successfully registered itself with the service registry You should also see \u0026ldquo;CONFIG-SERVER\u0026rdquo; and \u0026ldquo;ADMIN-SERVER\u0026rdquo; there - these are deployed as part of the platform ","description":"Oracle Backend for Spring Boot includes the Spring Eureka Service Registry, which is an application that stores information about client services/applications. Typically, each microservice will register with the Eureka server at startup and the Eureka server will maintain a list of all active instances of the service, including their ports and IP addresses. This information can be looked up by other services using a well-known key. This allows services to interact with each other without needing to know each others\u0026rsquo; addresses at development/deployment time."},{"id":20,"href":"/microservices-datadriven/spring/setup/","title":"Setup","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"Oracle Backend for Spring Boot is available in the OCI Marketplace.\nPrerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot:\nAn OCI account in a tenancy with sufficient quota to create:\nAn OCI Container Engine for Kubernetes cluster, plus a node pool with three worker nodes A VCN with at least two public IP\u0026rsquo;s available A public load balancer An Oracle Autonomous Database - Shared instance At least one free OCI Auth Token (note that the maximum is two per user)\nOn local workstation:\nThe Kubernetes command-line tool (kubectl) Oracle Cloud Infrastructure Command Line Interface (CLI) Oracle Backend for Spring Boot command-line tool Summary of components Oracle Backend for Spring Boot setup will install the following components:\nComponent Version Description cert-manager 1.11.0 Automates the management of certificates. NGINX Ingress Controller 1.6.4 Traffic management solution for cloud‑native applications in Kubernetes. Prometheus 2.40.2 Provides event monitoring and alerting. Prometheus Operator 0.60.1 Provides management for Prometheus monitoring tools. OpenTelemetry Collector 0.66.0 Collects process and export telemetry data. Grafana 9.2.5 Tool to help you examine, analyze, and monitor metrics. Jaeger Tracing 1.39.0 Distributed tracing system for monitoring and troubleshooting distributed systems. APISIX 3.1.1 Provides full lifecycle API Management. Spring Admin Server 2.7.5 Managing and monitoring Spring Boot applications. Spring Cloud Config Server 2.7.5 Provides server-side support for externalized configuration. Eureka Service Registry 3.1.4 Provides Service Discovery capabilities HashiCorp Vault 1.11.3 Provides a way of store and tightly control access to sensitive data Oracle Database Operator 0.6.1 Helps reduce the time and complexity of deploying and managing Oracle Databases. Setup the OCI environment Go to the OCI Marketplace listing for Oracle Backend for Spring Boot.\nChoose the target compartment, agree to the terms and click on the \u0026ldquo;Launch Stack\u0026rdquo; button. This will start the wizard to create the new stack. On the first page choose a compartment to host your stack and select Next\nFill in the following configuration variables as needed and select Next\nApplication Name (Optional) OKE Control Plane Options. Public Control Plane: this option allows access the OKE Control Plane from the Internet (Public IP). If not selected, access will only be from a private VCN. Control Plane Access Control: CIDR (IP range) allowed to access the control plane (Oracle recommends you set this as restrictive as possible). Enable Horizontal Pod Scaling?: The Horizontal Pod Autoscaler can help applications scale out to meet increased demand, or scale in when resources are no longer needed. Node Pool Workers: Number of Kubernetes worker nodes (virtual machines) to attach to the OKE Cluster. Create Stack Wizard Config Variables Load Balancers Options.\nEnable Public Load Balancer this option allows access to the load balancer from the Internet (Public IP). If not selected, access will only be from a private VCN. Public Load Balancer Ports Exposed. Ports exposed from the load balancer. Minimum bandwidth. The minimum bandwidth the load balancer can achieve. Maximum bandwidth. The maximum bandwidth the load balancer can achieve. Vault Options. You have the option of creating a new OCI Vault or use an an existing OCI Vault. Fill in the information below if you want to use an existing OCI Vault.\nVault Compartment (Optional) Select a Compartment for the OCI Vault. Existing Vault (Optional). Select an existing OCI Vault Existing Vault Key (Optional). Select an existing OCI Vault Key. Maximum bandwidth. The maximum bandwidth the load balancer can achieve. Create Stack Wizard Config Variables Now you can review the stack configuration and save the changes. Oracle recommends that you do not check the \u0026ldquo;Run apply\u0026rdquo; option - this will give you the opportunity to run the \u0026ldquo;plan\u0026rdquo; first and check for issues.\nCreate Stack Wizard Config Review Apply the Stack\nAfter you create your stack, you will be able to test the plan, edit the stack, and apply or destroy the stack.\nOracle recommends you test the plan before applying the stack, in order to identify any issues before you start creating resources. Testing a plan does not create any actual resources, it is just a \u0026ldquo;dry run\u0026rdquo; to tell you what would happen if you applied.\nCreate Stack Plan You can test the plan by clicking on the \u0026ldquo;Plan\u0026rdquo; button and then reviewing the output. If you see any issues, for example you may find that you do not have enough quota for some resource, you can fix that issue before proceeding.\nWhen you are happy with the results of the test, you can apply the stack by clicking on the \u0026ldquo;Apply\u0026rdquo; button. This will create your Oracle Backend as a Service for Spring Cloud Environment. This takes about 20 minutes to complete. A lot of this time is spent provisioning the Kubernetes cluster, worker nodes, and database. You can watch the logs to follow progress of the operation.\nCreate Stack Apply The OCI Resource Manager will apply your stack and generate the execution logs. The apply job takes approximately 45 minutes.\nCreate Stack Apply Logs Collect the OKE access information by clicking on the Outputs menu item.\nCreate Stack Outputs Click on the Copy for the Variable named kubeconfig_cmd. Save this information as it is needed to access the OKE Cluster.\nGet Kube Config Cmd Setup the local workstation Setting Up Cluster Access\nTo access a cluster using kubectl installed (see the Kubernetes access) locally. If you haven\u0026rsquo;t already done so,\ninstall kubectl (see the kubectl documentation).\ngenerate an API signing key pair If you already have an API signing key pair, go straight to the next step. If not:\nUse OpenSSL commands to generate the key pair in the required PEM format. If you\u0026rsquo;re using Windows, you\u0026rsquo;ll need to install Git Bash for Windows and run the commands with that tool. See How to Generate an API Signing Key. Copy the contents of the public key to the clipboard (you\u0026rsquo;ll need to paste the value into the Console later). add the public key value of the API signing key pair to the User Settings for your username\nIn the top-right corner of the Oracle Cloud Infrastructure Console, open the Profile menu (User menu icon) and then click User Settings to view the details.\nClick Add Public Key.\nPaste the public key\u0026rsquo;s value into the window and click Add.\nThe key is uploaded and its fingerprint is displayed (for example, d1:b2:32:53:d3:5f:cf:68:2d:6f:8b:5f:77:8f:07:13).\ninstall and configure the Oracle Cloud Infrastructure CLI\nInstall the Oracle Cloud Infrastructure CLI version 2.6.4 (or later). See Quickstart. Configure the Oracle Cloud Infrastructure CLI. See Configuring the CLI. Install Oracle Backend for Spring Boot command-line\nThe Oracle Backend for Spring Boot command-line tool, oractl, is available for Linux and Mac systems. Download the binary you want from the Releases page and add it to your PATH environment variable. You may like to rename the binary to remove the suffix.\nIf your environment is a Linux or Mac machine you need to run chmod +x on the downloaded binary. Also if your environment is a Mac you need run the following command sudo xattr -r -d com.apple.quarantine \u0026lt;downloaded-file\u0026gt; otherwise will you get a security warning and the CLI will not work.\n","description":"Oracle Backend for Spring Boot is available in the OCI Marketplace.\nPrerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot:\nAn OCI account in a tenancy with sufficient quota to create:\nAn OCI Container Engine for Kubernetes cluster, plus a node pool with three worker nodes A VCN with at least two public IP\u0026rsquo;s available A public load balancer An Oracle Autonomous Database - Shared instance At least one free OCI Auth Token (note that the maximum is two per user)"},{"id":21,"href":"/microservices-datadriven/spring/platform/spring-admin/","title":"Spring Admin","parent":"Platform","content":" View application details using the Spring Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications.\nExposing Spring Admin Dashboard using port-forward\nkubectl -n admin-server port-forward svc/admin-server 8989:8989 Open the Spring Admin Dashboard URL: http://localhost:8989\nusername: admin password: admin Note: Oracle recommends that you change the default password when you first login. Even though the dashboard is not accessible externally, we still recommend using strong passwords to maximize security.\nSpring Admin DashboardI On the web page, navigate to the applications tab:\nIf you deployed the sample apps, Find the \u0026ldquo;slow\u0026rdquo; entry and click on it to expand it Click on the instance of the service Notice you can see details about the service instance, metrics, configuration, etc. Spring Admin Service Details ","description":"View application details using the Spring Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications.\nExposing Spring Admin Dashboard using port-forward\nkubectl -n admin-server port-forward svc/admin-server 8989:8989 Open the Spring Admin Dashboard URL: http://localhost:8989"},{"id":22,"href":"/microservices-datadriven/spring/tags/","title":"Tags","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"","description":""},{"id":23,"href":"/microservices-datadriven/spring/uninstall/","title":"Uninstall","parent":"Oracle Backend for Spring Boot - Developer Preview","content":"To remove the Oracle Backend for Spring Boot, in the OCI Console main menu, navigate to “Developer Services” then “Resource Manager - Stacks”. Make sure you are in the correct region and compartment where you installed the BaaS.\nClick on the link to open the detail view for the Oracle Backend for Spring Boot instance and click on the Destroy button to clean up resources:\nOCI Stack Destroy The OCI Resource Manager will use stack definition to destroy all resources.\nOCI Stack Destroy Logs The destroy job takes about 20 minutes to complete. You should review the logs at the end to make sure it completed successfully. If there were any errors, in most cases running the destroy job again will fix any issues.\n","description":"To remove the Oracle Backend for Spring Boot, in the OCI Console main menu, navigate to “Developer Services” then “Resource Manager - Stacks”. Make sure you are in the correct region and compartment where you installed the BaaS.\nClick on the link to open the detail view for the Oracle Backend for Spring Boot instance and click on the Destroy button to clean up resources:\nOCI Stack Destroy The OCI Resource Manager will use stack definition to destroy all resources."},{"id":24,"href":"/microservices-datadriven/spring/development/cli/","title":"Using the OBaaS CLI","parent":"Development","content":"The Oracle Backend for Spring Boot offers a command-line tool, oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources they use. Download the CLI here The platform specific binary can be renamed to oractl for convenience.\nUsing the CLI Expose the Oracle Backend for Spring Boot Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/obaas-admin -n obaas-admin 8080:8080 Start the CLI in interactive mode by simply running oractl from your terminal window.\noractl AVAILABLE COMMANDS Short descriptions of the available commands are as follows. These can be viewed by issuing the help command and detailed help for any individual command can be viewed by issuing help [commandname]\nAVAILABLE COMMANDS\noractl:\u0026gt;help AVAILABLE COMMANDS Admin Server Commands change-password: Change password for OBaaS Spring Cloud admin user. connect: Connect to the OBaaS Spring Cloud admin console. Application/Namespace Commands create: Create an application/namespace. delete: Delete a service or entire application/namespace. Built-In Commands help: Display help about available commands stacktrace: Display the full stacktrace of the last error. clear: Clear the shell screen. quit, exit: Exit the shell. history: Display or save the history of previously run commands version: Show version info script: Read and execute commands from a file. Informational Commands list: list/show details of application services. Service Commands bind: Create a schema/user and bind it to service deployment. config: View and modify application configuration. deploy: Deploy a service. oractl:\u0026gt; An application is a namespace encompassing related microservices. For example, a \u0026ldquo;cloudbank\u0026rdquo; application may have \u0026ldquo;banktransfer\u0026rdquo; \u0026ldquo;frauddetection\u0026rdquo;, etc., microservices deployed within it. The create command results in the creation of an application namespace.\nThe bind command results in the automatic creation of a database schema for a given service/user and binds the information for that schema/database in the environment of the microservice for it to use. The option of the prefix for the environment properties bound is also given. For example, most Spring microservices us \u0026ldquo;spring.datasource\u0026rdquo;.\nThe deploy command takes service-name, app-name, and artifact-path as it\u0026rsquo;s main arguments (image-version and java-version options are also provided). When the deploy command is issued, the microservice JAR file is uploaded to the backend, a container image is created for the JAR/microservice, and various Kubernetes resources such as deployment, service, etc. are also created. This is all done automatically to simplify the development process and the management of the microservices by the backend.\nThe list command can then be used show the details of the deployed microservice, etc.\nThe config command can also be used to add, view, update and delete configuration managed by the Spring Config Server.\nA common development workflow pattern is to connect, change-password (only if necessary), create (once per app/namespace), config, bind (only if necessary), deploy, and list.\nFurther development and redeployment of the service can then be iterated upon by issuing the deploy, list, etc. commands.\nThe following is an example development workflow using the CLI.\nFirst, a connection is made to the Oracle server-side Spring Admin\noractl:\u0026gt;help connect NAME connect - Connect to the OBaaS Spring Cloud admin console. SYNOPSIS connect --url String --username String OPTIONS --url String admin server URL [Optional, default = http://localhost:8080] --username String username (will be prompted for password) [Optional, default = admin] oractl:\u0026gt;connect password (defaults to oractl): using default value... connect successful server version:0.3.0 Then, an application namespace is created withe the create command. This namespace will contain the microservices that are deployed later.\noractl:\u0026gt;help create NAME create - Create an application/namespace. SYNOPSIS create [--app-name String] --help OPTIONS --app-name String application/namespace [Mandatory] --help or -h help for create [Optional] oractl:\u0026gt;create --app-name myapp application/namespace created successfully and image pull secret (registry-auth) created successfully and database TNSAdmin/wallet secret created successfully Next, the bind command will create a database schema/user for the service (if one hasn\u0026rsquo;t already been created). The command will also create the Kubernetes secret and binding environment entries for the schema (these will be set in the Kubernetes deployment created with the deploy command).\noractl:\u0026gt;help bind NAME bind - Create a schema/user and bind it to service deployment. SYNOPSIS bind --app-name String [--service-name String] --binding-prefix String --help OPTIONS --app-name String application/namespace [Optional, default = application] --service-name String Service Name/Database User [Mandatory] --binding-prefix String spring binding prefix [Optional, default = spring.datasource] --help or -h help for bind [Optional] oractl:\u0026gt;bind --app-name myapp --service-name myserv database password/servicePassword (defaults to Welcome12345): ************ database secret created successfully and schema created successfully for myserv The microservice JAR will now be deployed with the deploy command which will create, build, and push an image for the microservice and create the necessary deployment, service, secret, etc. Kubernetes resources for the microservice.\noractl:\u0026gt;help deploy NAME deploy - Deploy a service. SYNOPSIS deploy --redeploy boolean --bind String --app-name String [--service-name String] [--image-version String] --service-profile String --port String --java-version String --add-health-probe boolean [--artifact-path String] --help OPTIONS --redeploy boolean whether the service has already been deployed or not [Optional, default = false] --bind String automatically create and bind resources. possible values are [jms] [Optional] --app-name String application/namespace [Optional, default = application] --service-name String Service Name [Mandatory] --image-version String Image Version [Mandatory] --service-profile String Service Profile [Optional] --port String Service Port [Optional, default = 8080] --java-version String Java Container Base Image [ghcr.io/graalvm/jdk:ol9-java17-22.3.1] [Optional] --add-health-probe boolean Inject or not Health probes to service. [Optional, default = false] --artifact-path String Service jar location [Mandatory] --help or -h help for deploy [Optional] oractl:\u0026gt;deploy --app-name myapp --service-name myserv --image-version 0.0.1 --port 8081 --bind jms --add-health-probe true --artifact-path obaas/myserv/target/demo-0.0.1-SNAPSHOT.jar uploading: obaas/myserv/target/demo-0.0.1-SNAPSHOT.jar building and pushing image... binding resources... successful creating deployment and service... successfully deployed The list command can then be used to show details of the microservice deployed in the previous step.\noractl:\u0026gt;help list NAME list - list/show details of application services. SYNOPSIS list --app-name String --help OPTIONS --app-name String application/namespace [Optional, default = application] --help or -h help for list [Optional] oractl:\u0026gt;list --app-name myapp name:myserv-c46688645-r6lhl status:class V1ContainerStatus { containerID: cri-o://6d10194c5058a8cf7ecbd5e745cebd5e44c5768c7df73053fa85f54af4b352b2 image: \u0026lt;region\u0026gt;.ocir.io/\u0026lt;tenancy\u0026gt;/obaas03/myapp-myserv:0.0.1 imageID: \u0026lt;region\u0026gt;.ocir.io/\u0026lt;tenancy\u0026gt;/obaas03/myapp-myserv@sha256:99d4bbe42ceef97497105218594ea19a9e9869c75f48bdfdc1a2f2aec33b503c lastState: class V1ContainerState { running: null terminated: null waiting: null } name: myserv ready: true restartCount: 0 started: true state: class V1ContainerState { running: class V1ContainerStateRunning { startedAt: 2023-04-13T01:00:51Z } terminated: null waiting: null } }name:myserv kind:null The config command can be used to view and update config managed by the Spring Config Server. More information on the configuration server can be found here:\nSpring Config Server oractl:\u0026gt;help config NAME config - View and modify Service configuration. SYNOPSIS config [--action CommandConstants.ConfigActions] --service-name String --service-label String --service-profile String --property-key String --property-value String --artifact-path String --help OPTIONS --action CommandConstants.ConfigActions possible actions: add, list, update, or delete [Mandatory] --service-name String Service Name [Optional] --service-label String label for config [Optional] --service-profile String Application Profile [Optional] --property-key String the property key for the config [Optional] --property-value String the value for the config [Optional] --artifact-path String the context [Optional] --help or -h help for config [Optional] The config add allow add the application configuration to Spring Config Server following two options:\nadd a specific configuration using the set of parameters --service-name, --service-label, --service-profile, --property-key and --property-value.\noractl:\u0026gt;config add --service-name myserv --service-label 0.0.1 --service-profile default --property-key k1 --property-value value1 Property added successfully. add a set of configurations based on a config file using --artifact-path Example: myserv.json\n{ \u0026#34;application\u0026#34;: \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;spring.datasource.driver-class-name\u0026#34;: \u0026#34;oracle.jdbc.OracleDriver\u0026#34;, \u0026#34;spring.datasource.url\u0026#34;: \u0026#34;jdbc:oracle:thin:@$(db.service)?TNS_ADMIN=/oracle/tnsadmin\u0026#34; } } oractl:\u0026gt;config add --artifact-path /obaas/myserv-properties.json 2 property(s) added successfully. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.0.1 [ { \u0026#34;id\u0026#34; : 222, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;spring.datasource.driver-class-name\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;oracle.jdbc.OracleDriver\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:29:38.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; }, { \u0026#34;id\u0026#34; : 223, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;spring.datasource.url\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;jdbc:oracle:thin:@$(db.service)?TNS_ADMIN=/oracle/tnsadmin\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:29:38.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] The config list without any parameter will bring the list of services that has at least one configuration inserted Spring Config Server.\noractl:\u0026gt;config list [ { \u0026#34;name\u0026#34; : \u0026#34;apptest\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;\u0026#34; }, { \u0026#34;name\u0026#34; : \u0026#34;myapp\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;\u0026#34; }, […] The config list [parameters] can be used to list the parameters using parameters as filters:\n--service-name : will list all parameters from the specified service. --service-label: filter by label --service-profile: filter by profiel --property-key: list a specific parameter filter by key. oractl:\u0026gt;config list --service-name myserv --service-profile default --service-label 0.0.1 [ { \u0026#34;id\u0026#34; : 221, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:10:16.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] The config update allow update a specific configuration using the set of parameters:\n--service-name --service-label --service-profile --property-key --property-value oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 [ { \u0026#34;id\u0026#34; : 30, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-03-23T18:02:29.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] oractl:\u0026gt;config update --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 --property-value value1Updated Property successful modified. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 [ { \u0026#34;id\u0026#34; : 30, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1Updated\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-03-23T18:02:29.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] The config delete allow delete the application configuration from Spring Config Server following two options:\ndelete all configurations from a specific service using the filters by --service-name, --service-profile and --service-label. The CLI will inform how many configurations are present in Config Server and ask to confirm the complete deletion.\noractl:\u0026gt;config delete --service-name myserv [obaas] 7 property(ies) found, delete all (y/n)?: delete a specific configuration using the set of parameters --service-name, --service-label, --service-profile and --property-key.\noractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 [ { \u0026#34;id\u0026#34; : 224, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;ktest2\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value2\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:52:11.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] oractl:\u0026gt;config delete --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 [obaas] property successfully deleted. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 400 : \u0026#34;Couldn\u0026#39;t find any property for submitted query.\u0026#34; ","description":"The Oracle Backend for Spring Boot offers a command-line tool, oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources they use. Download the CLI here The platform specific binary can be renamed to oractl for convenience.\nUsing the CLI Expose the Oracle Backend for Spring Boot Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/obaas-admin -n obaas-admin 8080:8080 Start the CLI in interactive mode by simply running oractl from your terminal window."},{"id":25,"href":"/microservices-datadriven/spring/platform/vault/","title":"Vault","parent":"Platform","content":"Oracle Backend as a Service for Spring Cloud includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Vault uses the following Oracle OCI Services:\nObject Storage for storing Vault data OCI Vault to auto unseal the Vault Container Engine for Kubernetes for running the Vault server The Vault is unsealed using the OCI KMS key. The root token is provided during deployment of Oracle Backend as a Service for Spring Cloud.\nThe following Vault services are enabled during deployment. Other services can be enabled using the vault command and the Web User Interface.\nToken Auth Method. The token auth method is built-in and automatically available. It allows users to authenticate using a token, as well to create new tokens, revoke secrets by token, and more. AppRole Auth Method. The approle auth method allows machines or apps to authenticate with Vault-defined roles. Kubernetes Auth Method. The kubernetes auth method can be used to authenticate with Vault using a Kubernetes Service Account Token. This method of authentication makes it easy to introduce a Vault token into a Kubernetes Pod. Userpass Auth MethodThe userpass auth method allows users to authenticate with Vault using a username and password combination. KV Secrets Engine Version 2. The kv secrets engine is a generic Key-Value store used to store arbitrary secrets. Accessing Vault using using kubectl To access Vault using kubectl you need to setup Kubernetes Access\nTest access to Vault\nVault Documentation contains all the commands you can use with the Vault CLI. For example this command returns the current status of Vault:\nkubectl exec pod/vault-0 -n vault -it -- vault status The output will be similar to this:\nKey Value --- ----- Recovery Seal Type shamir Initialized true Sealed false Total Recovery Shares 5 Threshold 3 Version 1.11.3 Build Date 2022-08-26T10:27:10Z Storage Type oci Cluster Name vault-cluster-28535f69 Cluster ID 993662ee-b3ee-2a13-3354-97adae01e1ca HA Enabled true HA Cluster https://vault-0.vault-internal:8201 HA Mode active Active Since 2023-01-26T16:14:32.628291153Z Login into Vault\nTo interact with vault you need to login using a token. The root token is stored in a k8s secret. Get the token by running this command, the output is the root token. It is VERY IMPORTANT that the token is saved in multiple places, loosing the token can result in loss of access to the Vault.\nkubectl get secret vault-root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34; Login to the vault:\nkubectl exec pod/vault-0 -n vault -it -- vault login Token (will be hidden): Sample output from logging in as the root user which only should be done initial setup. As an administrator you must generate separate tokens and ACLs for the users than needs access to Vault. See Vault Documentation.\nKey Value --- ----- token hvs....... token_accessor Hcx....... token_duration ∞ token_renewable false token_policies [\u0026#34;root\u0026#34;] identity_policies [] policies [\u0026#34;root\u0026#34;] Display the enabled secret engines\nTo display the enabled secrets engines execute the following command:\nkubectl exec pod/vault-0 -n vault -it -- vault secrets list The output will look similar to this:\nPath Type Accessor Description ---- ---- -------- ----------- cubbyhole/ cubbyhole cubbyhole_a07a59ec per-token private secret storage identity/ identity identity_8b1e1a80 identity store kv-v2/ kv kv_06acc397 n/a sys/ system system_df5c39a8 system endpoints used for control, policy and debugging Display the authentication methods enabled:\nTo display the enabled authentication methods execute the following command:\nkubectl exec pod/vault-0 -n vault -it -- vault auth list The output will look similar to this:\nPath Type Accessor Description ---- ---- -------- ----------- approle/ approle auth_approle_00ffb93b n/a kubernetes/ kubernetes auth_kubernetes_c9bb0698 n/a token/ token auth_token_68b0beb2 token based credentials userpass/ userpass auth_userpass_afb2fb02 n/a Create a secret\nCreate a secret at path kv-v2/customer/acme with a nme and an email\nkubectl exec pod/vault-0 -n vault -it -- vault kv put -mount=kv-v2 customer/acme customer_name=\u0026#34;ACME Inc.\u0026#34; \\ contact_email=\u0026#34;john.smith@acme.com\u0026#34; The output will look similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 Get a secret\nGet the created secret:\nkubectl exec pod/vault-0 -n vault -it -- vault kv get -mount=kv-v2 customer/acme The output will look similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 ======== Data ======== Key Value --- ----- contact_email john.smith@acme.com customer_name ACME Inc. For more information about the Key/Value secrets engine Key/value Documentation and Versioned Key/Value Secrets Engine Tutorial.\nAccessing Vault using the Web User Interface Expose the Vault Web User Interface using port-forward\nkubectl port-forward -n vault svc/vault 8200:8200 Get the root token\nTo interact with vault you need to login using a token. The root token is stored in a k8s secret. Get the token by running this command, the output is the root token. It is VERY IMPORTANT that the token is saved in multiple places, loosing the token can result in loss of access to the Vault.\nkubectl get secret root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34; Open the Vault Web User Interface: https://localhost:8200\nVault Web User Interface Login using the root token. As an administrator you must generate separate tokens and ACLs for the users than needs access to Vault. See Vault Documentation.\nYou are presented with the home screen showing the installed secret engines\nVault Home Page Create a Key/Value secret\nClick on the k2-v2 link from the home page.\nVault K/V V2 Home Click on the Create Secret link\nVault Create Secret Create a secret\nVault Secret View the secret content by clicking on the eye icon for each value\nVault Show Secret Accessing Vault Recovery Keys Vault is configured to Auto Unseal using OCI Vault. Initializing with Auto Unseal creates five recovery keys and they are stored in k8s secrets. They MUST be retrieved and stored in a second location.\nTo extract the five recovery keys use the following commands:\n% kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.1\\\u0026#34; }}\u0026#34; % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.2\\\u0026#34; }}\u0026#34; % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.3\\\u0026#34; }}\u0026#34; % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.4\\\u0026#34; }}\u0026#34; % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.5\\\u0026#34; }}\u0026#34; ","description":"Oracle Backend as a Service for Spring Cloud includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets and other sensitive data using a UI, CLI, or HTTP API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Vault uses the following Oracle OCI Services:\nObject Storage for storing Vault data OCI Vault to auto unseal the Vault Container Engine for Kubernetes for running the Vault server The Vault is unsealed using the OCI KMS key."},{"id":26,"href":"/microservices-datadriven/spring/platform/conductor/","title":"Workflow","parent":"Platform","content":"Oracle Backend as a Service for Spring Cloud includes Netflix Conductor Server. Conductor is a popular workflow solution that works well with Spring Boot microservices and the Oracle database.\nFull documentation on Conductor can be found here:\nNetflix Conductor Documentation Accessing Server UI Expose the Oracle Spring Cloud Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor Server UI.\nhttp://localhost:8080 Access the Swagger Documentation\nhttp://localhost:8080/swagger-ui/index.html API Specification The API Specification can be found here:\nAPI Specification ","description":"Oracle Backend as a Service for Spring Cloud includes Netflix Conductor Server. Conductor is a popular workflow solution that works well with Spring Boot microservices and the Oracle database.\nFull documentation on Conductor can be found here:\nNetflix Conductor Documentation Accessing Server UI Expose the Oracle Spring Cloud Admin Server that the CLI will call by using port-forward\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor Server UI.\nhttp://localhost:8080 Access the Swagger Documentation"}]