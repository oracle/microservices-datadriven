[{"id":0,"href":"/microservices-datadriven/spring/observability/tracing/","title":"Tracing","parent":"Observability","content":" Overview In a distributed system, it’s expected that occasional errors are bound to happen when serving requests. A central observability platform helps by capturing application traces/logs and provides an interface to query for a specific request. OpenTelemetry helps in standardizing the process of capturing and exporting telemetry data.\nOpenTelemetry (OTEL) is a collection of standardized vendor-agnostic tools, APIs, and SDKs. It’s a CNCF incubating project and is a merger of the OpenTracing and OpenCensus projects.\nOpenTracing is a vendor-neutral API for sending telemetry data over to an observability backend. The OpenCensus project provides a set of language-specific libraries that developers can use to instrument their code and send it to any supported backends. OTEL uses the same concept of trace and span to represent the request flow across microservices as used by its predecessor projects.\nOTEL allows us to instrument, generate, and collect telemetry data, which helps in analyzing application behavior or performance. Telemetry data can include logs, metrics, and traces. We can either automatically or manually instrument the code for HTTP, DB calls, and more.\nOverview How to enable tracing for your applications To enable tracing for your application you must include the following dependencies to your Maven POM or equivalent.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing-bridge-otel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-exporter-otlp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; If you want to enable tracing for your database calls (Micrometer observability instrumentation for JDBC DataSource) you must include the following dependency too. You can find the latest version here.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.ttddyy.observation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;datasource-micrometer-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; You must also add the following to your applications application.yaml file.\nspring: application: name: customer management: endpoint: health: show-details: always endpoints: web: exposure: include: \u0026#34;*\u0026#34; metrics: tags: application: ${spring.application.name} tracing: sampling: probability: 1.0 info: os: enabled: true env: enabled: true java: enabled: true otlp: tracing: endpoint: ${otel.exporter.otlp.endpoint} How to enable tracing in APISIX routes The OpenTelemetry plugin is enabled by default in APISIX. To enable tracing for your routes add the following to the route configuration:\n\u0026#34;plugins\u0026#34;: { \u0026#34;opentelemetry\u0026#34;: { \u0026#34;sampler\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;always_on\u0026#34; } } } For more configuration option for the OpenTelemetry plugin; APISIX Documentation\nView Application Traces in Jaeger Web User Interface Jaeger is a distributed tracing system used for monitoring and troubleshooting Microservices. For more information on Jaeger, see the Jaeger website.\nExpose the Jaeger web user interface using this command:\nkubectl -n observability port-forward svc/jaegertracing-query 16686:16686 Open the Jaeger web user interface URL: http://localhost:16686\nJaeger UI In the Jaeger web user interface, click the Search tab to find tracings using various search criteria. For example, to find traces for the customer Microservice included in the Sample Application:\na. If you deployed the Sample Applications and have accessed the REST endpoints you can find traces for it in Jaeger. For example:\nb. Select the Service customer32 and the Operation /api/v2/customers .\nc. Click on Find Traces. Several traces appear (one for each time that you invoked the service). Jaeger Customer Tracing d. Click on any one of them to view the trace that includes multiple services and extends into Oracle Database. For example: Jaeger Customer Tracing Details ","description":"Overview In a distributed system, it’s expected that occasional errors are bound to happen when serving requests. A central observability platform helps by capturing application traces/logs and provides an interface to query for a specific request. OpenTelemetry helps in standardizing the process of capturing and exporting telemetry data.\nOpenTelemetry (OTEL) is a collection of standardized vendor-agnostic tools, APIs, and SDKs. It’s a CNCF incubating project and is a merger of the OpenTracing and OpenCensus projects."},{"id":1,"href":"/microservices-datadriven/spring/platform/apigw/","title":"Apache APISIX Gateway","parent":"Platform Services","content":"Apache APISIX is an open source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nAccessing Apache APISIX dashboard Oracle Backend for Spring Boot and Microservices deploys Apache APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the Apache APISIX Dashboard, you must use the kubectl port-forward command to create a secure channel to service/apisix-dashboard. Process the following steps:\nTo expose the Apache APISIX Dashboard using this command:\nkubectl port-forward -n apisix svc/apisix-dashboard 8080:80 Open the Apache APISIX Dashboard URL: http://localhost:8080\nusername: admin Password is retrieved using the following command: kubectl get secret -n apisix apisix-dashboard -o jsonpath=\u0026#39;{.data.conf\\.yaml}\u0026#39; | base64 -d | grep \u0026#39;password:\u0026#39;; echo NOTE: Oracle recommends that you change the default password when you log in the first time. Even though the dashboard is not accessible externally, Oracle still recommends using strong passwords to maximize security.\nAPISIX Login Enable tracing in APISIX routes The OpenTelemetry plugin is enabled by default in APISIX. To enable tracing for your routes add the following to the route configuration:\n\u0026#34;plugins\u0026#34;: { \u0026#34;opentelemetry\u0026#34;: { \u0026#34;sampler\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;always_on\u0026#34; } } } For more configuration option for the OpenTelemetry plugin; APISIX Documentation\nExposing a Spring Application Through the API Gateway and Load Balancer Once you have your application deployed and running, you may want to expose it to the outside world. Some applications may not need to be exposed if they are only called by other applications in the platform. To expose your application, create a \u0026ldquo;route\u0026rdquo; in the Apache APISIX API Gateway by processing these steps:\nCreate a route to the service. For example:\nIn the Apache APISIX Dashboard, click Routes in the menu on the left side. APISIX Routes Click Create to create a new route.\nFill out the necessary details (anything not mentioned here can be left at the default value). For example, for the \u0026ldquo;slow service\u0026rdquo; to be included in the Sample Applications, provide these details:\nname = slow\npath = /fruit*\nmethod = get, options\nupstream type = service discovery\ndiscovery type = eureka\nservice name = SLOW (note that this is case sensitive, this is the key from the Eureka dashboard)\nNOTE: The API Gateway is pre-configured with both \u0026ldquo;Eureka\u0026rdquo; and \u0026ldquo;Kubernetes\u0026rdquo; discovery types. For Eureka, the service name is the key used to deploy the service in Eureka, which is normally the value from spring.application.name in the Spring Boot configuration file (src/main/resources/application.yaml), in uppercase characters. For Kubernetes, the service name is in the format namespace/service:port where namespace is the Kubernetes namespace in which the Spring Boot application is deployed, service is the name of the Kubernetes service for that application, and port is the name of the port in that service. If you deployed your Spring Boot application with the Oracle Backend for Spring Boot and Microservices CLI, the port name will be spring. For example, an application called slow-service deployed in the my-apps namespace would be my-apps/slow-service:spring.\nAPISIX Routes Step1 APISIX Routes Step2 APISIX Routes Step3 Save the route that you created. APISIX Routes Step4 APISIX Routes Step5 Test a route to the service. For example:\nGet the Apache APISIX Gateway external IP using this command: kubectl -n ingress-nginx get svc ingress-nginx-controller The result of the command should look similar to this:\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller LoadBalancer 10.96.172.148 146.235.207.230 80:31393/TCP,443:30506/TCP 25h Call the API using the Apache APISIX Gateway address plus path. For example: curl http://APISIX_IP/fruit You should get \u0026ldquo;banana\u0026rdquo; or \u0026ldquo;fallback fruit is apple\u0026rdquo; back as the response.\n","description":"Apache APISIX is an open source cloud native API platform that supports the full lifecycle of API management including publishing, traffic management, deployment strategies, and circuit breakers.\nAccessing Apache APISIX dashboard Oracle Backend for Spring Boot and Microservices deploys Apache APISIX Gateway and Dashboard in the apisix namespace. The gateway is exposed through the external load balancer and ingress controller. To access the Apache APISIX Dashboard, you must use the kubectl port-forward command to create a secure channel to service/apisix-dashboard."},{"id":2,"href":"/microservices-datadriven/spring/security/azn-server/","title":"Authentication and Authorization Server","parent":"Security","content":"The Authorization Server is an engine to authenticate and authorize requests to various components in Oracle Backend for Spring Boot and Microservices. The end user can manage users using REST Endpoints.\nNOTE: Oracle recommends that you change the default passwords for the default created users.\nUsers \u0026amp; Roles User Management REST endpoints overview User Management REST Endpoints Architecture Users \u0026amp; Roles When deploying Oracle Backend for Spring Boot and Microservices, two users are created with the following roles:\nUser Name Assigned Roles obaas-admin ROLE_ADMIN, ROLE_USER obaas-user ROLE_USER All users are stored in the database are deployed when installing Oracle Backend for Spring Boot and Microservices. The roles determine what the user is allowed to do in the environment. The allowed roles are ROLE_ADMIN and ROLE_USER.\nNOTE: See each components documentation about the roles and authorities.\nThe assigned passwords (either auto generated or provided by the installer) can be viewed in the OCI Console (ORM homepage). Click on Application Information.\nApplication Information If you click on Unlock, the password for the obaas-admin and obaas-user can be displayed.\nAZN User passwords The passwords can also be obtained from k8s secrets using the kubectl command.\nFor obaas-admin:\nkubectl get secret -n azn-server oractl-passwords -o jsonpath=\u0026#39;{.data.admin}\u0026#39; | base64 -d; echo For obaas-user:\nkubectl get secret -n azn-server oractl-passwords -o jsonpath=\u0026#39;{.data.user}\u0026#39; | base64 -d; echo User Management REST endpoints overview The following REST Endpoints are available to manage users. The table lists which minimum required role that is needed to perform the operation.\nEnd point Method Description Minimum required Role /user/api/v1/connect GET Authorize All Roles /user/api/v1/findUser GET Find all users ROLE_ADMIN /user/api/v1/findUser?username=\u0026lt;username\u0026gt; GET Find a user with the username \u0026lt;username\u0026gt; ROLE_ADMIN /user/api/v1/createUser POST Create a user ROLE_ADMIN /user/api/v1/updatePassword PUT Update a password for a user. A user with Role ROLE_ADMIN can update any users password ROLE_USER /user/api/v1/changeRole PUT Change role(s) for a user ROLE_ADMIN /user/api/v1/deleteUsername?username=\u0026lt;username\u0026gt; DELETE Delete a user with username \u0026lt;username\u0026gt; ROLE_ADMIN /user/api/v1/deleteId?id=\u0026lt;id\u0026gt; DELETE Delete a user with the id \u0026lt;id\u0026gt; ROLE_ADMIN User Management REST Endpoints In all examples below you need to replace \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; with your username and password. The examples are using curl to interact with the REST endpoints. They also requires that you have opened a tunnel on port 8080 to either the azn-server or obaas-admin service. For example, this command opens a tunnel to the obaas-admin service.\nkubectl port-forward -n obaas-admin svc/obaas-admin 8080 /user/api/v1/findUser curl -i -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; http://localhost:8080/user/api/v1/findUser /user/api/v1/findUser?username=\u0026lt;username\u0026gt; curl -i -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; \u0026#39;http://localhost:8080/user/api/v1/findUser?username=obaas-admin\u0026#39; /user/api/v1/createUser When creating a user the following Roles are allowed: ROLE_ADMIN and ROLE_USER.\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -i -X POST \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;a-new-user\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;top-secret-password\u0026#34;, \u0026#34;roles\u0026#34; : \u0026#34;ROLE_ADMIN,ROLE_USER\u0026#34;}\u0026#39; \\ http://localhost:8080/user/api/v1/createUser /user/api/v1/updatePassword curl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -i -X PUT \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;current-user\u0026#34;, \u0026#34;password\u0026#34;: \u0026#34;more-top-secret-password\u0026#34;}\u0026#39; \\ http://localhost:8080/user/api/v1/updatePassword /user/api/v1/changeRole curl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -i -X PUT \\ -H \u0026#39;Content-Type: application/json\u0026#39; \\ -d \u0026#39;{\u0026#34;username\u0026#34;: \u0026#34;current-user\u0026#34;, \u0026#34;roles\u0026#34;: \u0026#34;changed-roles\u0026#34;}\u0026#39; \\ http://localhost:8080/user/api/v1/changeRole /user/api/v1/deleteUsername?username=\u0026lt;username\u0026gt; curl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -i -X DELETE \\ http://localhost:8080/user/api/v1/deleteUsername?username=\u0026lt;username_to_be_deleted\u0026gt; /user/api/v1/deleteId?id=\u0026lt;id\u0026gt; curl -u obaas-admin:password -i -X DELETE \\ http://localhost:8080/user/api/v1/deleteId?id=\u0026lt;userid_to_be_deleted\u0026gt; Architecture The following picture shows how the Authentication Server is used for AuthZ for the following modules:\nOBaaS Admin (OBaaS CLI server module) Config Server (Manages Config Server Entries) AZN Server (AUthentication Server User Management) GraalVM Compiler (GraalVM Native Compiler module) Authorization Server Architecture ","description":"The Authorization Server is an engine to authenticate and authorize requests to various components in Oracle Backend for Spring Boot and Microservices. The end user can manage users using REST Endpoints.\nNOTE: Oracle recommends that you change the default passwords for the default created users.\nUsers \u0026amp; Roles User Management REST endpoints overview User Management REST Endpoints Architecture Users \u0026amp; Roles When deploying Oracle Backend for Spring Boot and Microservices, two users are created with the following roles:"},{"id":3,"href":"/microservices-datadriven/spring/azure/","title":"Azure/OCI Multicloud Installation","parent":"Oracle Backend for Spring Boot and Microservices","content":"The Oracle Backend for Spring Boot and Microservices is available to install in Multicloud (Microsoft Azure (Azure) and Oracle Cloud Infrastructure (OCI)). This installation deploys the Oracle Backend for Spring Boot and Microservices in Azure with an Oracle Autonomous Database running in OCI.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot Multicloud (Azure and OCI). You need:\nAn account on Azure. An account on OCI. Overview of the Setup Process Watch this video for a quick overview of the setup process.\nDownload Download Oracle Backend for Spring Boot and Microservices.\nSetup A few setup steps are required in both OCI and Azure to deploy the Oracle Backend for Spring Boot and Microservices application.\nOCI The Multicloud installation provisions an Oracle Autonomous Database in OCI using the Oracle Database Operator for Kubernetes (OraOperator).\nTo allow the OraOperator access to OCI, an API Key must be generated using these steps:\nLog in to OCI. Open the Profile menu and click User settings. In the Resources section at the lower left, click API Keys. Click Download Private Key and save the key as private_key.pem. You do not need to download the public key. Click Add. The key is added and the Configuration File Preview is displayed. The file snippet includes the required parameters and values. Copy and paste the configuration file snippet from the text box and save for later steps.\nAzure The Multicloud installation is done using the Azure Cloud Shell. The following steps are required in Azure to prepare for the installation:\nLog in to Azure.\nOpen the Azure Cloud Shell. For example:\nUpload the Oracle Backend for Spring Boot and Microservices stack. For example:\nUpload the API Private Key (private_key.pem).\nUnzip the stack to a directory called obaas. For example:\nunzip azure-ebaas_latest.zip -d ~/obaas\nMove the private_key.pem file to the obaas directory. For example:\nmv private_key.pem ~/obaas/\nRun the configuration Helper script using the values from the API Key. For example:\ncd ~/obaas ./obaas_configure.py Install Ansible Install Ansible to run the Configuration Management Playbook. The Helper script creates a Python virtual environment and installs Ansible and some additional modules. For example:\ncd ~/obaas/ansible ./setup_ansible.sh /tmp source ./activate.env /tmp Deploy the Infrastructure From the Azure Cloud Shell, run these commands to deploy the infrastructure:\ncd ~/obaas terraform init terraform plan -out=multicloud.plan terraform apply \u0026#34;multicloud.plan\u0026#34; ","description":"The Oracle Backend for Spring Boot and Microservices is available to install in Multicloud (Microsoft Azure (Azure) and Oracle Cloud Infrastructure (OCI)). This installation deploys the Oracle Backend for Spring Boot and Microservices in Azure with an Oracle Autonomous Database running in OCI.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot Multicloud (Azure and OCI). You need:\nAn account on Azure. An account on OCI."},{"id":4,"href":"/microservices-datadriven/spring/on-premises/","title":"Custom Installations","parent":"Oracle Backend for Spring Boot and Microservices","content":"The Oracle Backend for Spring Boot and Microservices is available to install in your own \u0026ldquo;custom\u0026rdquo; environment, which may be an on-premises data center environment, a different cloud provider, or a developer\u0026rsquo;s desktop.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot and Microservices On-Premises. You need:\nAccess to Oracle Database Enterprise Edition 19.3.0.0 Access to a Container Repository Access to a Kubernetes cluster Python 3+ When installing in a desktop environment, for example a developer\u0026rsquo;s desktop, the previously mentioned pre-requisites may be met through an additional setup task, but there are additional desktop system or software requirements. For example:\n2 CPUs or more 8 GB of free memory 60 GB of free disk space (40 GB minikube and container images, 20 GB database) Internet connection Minikube or similar Podman1 or similar Oracle Single Sign-On (SSO) account to download the database image Download Download the latest release of Oracle Backend for Spring Boot and Microservices.\nSetup A custom installation consists of defining the infrastructure followed by running the Configuration Management Playbook to build images and deploy the Microservices.\nFor a custom installation, you need to have a Kubernetes cluster and the kubectl command-line interface must be configured to communicate with your cluster.\nA Helper Playbook has been provided for desktop installations to assist in defining a specific infrastructure consisting of podman and minikube as outlined in the example documentation:\nmacOS Ventura (x86) Oracle Linux 8 (x86) If your infrastructure does not match that defined in the above examples, do not run the Helper Playbook.\nDownload the Database or Oracle REST Data Services (ORDS) Images (Desktop Installation) The desktop installation provisions an Oracle database to the Kubernetes cluster. The images must be downloaded from Oracle\u0026rsquo;s Container Registry before continuing.\nAfter installing Podman, process these steps:\nLog in to Oracle Cloud Infrastructure Registry (Container Registry). For example:\npodman login container-registry.oracle.com\nPull the database image. For example:\npodman pull container-registry.oracle.com/database/enterprise:19.3.0.0\nPull the ORDS image. For example:\npodman pull container-registry.oracle.com/database/ords:21.4.2-gh\nDefining the Application The application is defined in ansible/vars/ebaas.yaml. For example:\n--- ebaas_edition: \u0026#34;COMMUNITY\u0026#34; vault: \u0026#34;\u0026#34; vault_key: \u0026#34;\u0026#34; vault_crypto_endpoint: \u0026#34;\u0026#34; vault_management_endpoint: \u0026#34;\u0026#34; vault_storage_account_name: \u0026#34;N/A\u0026#34; vault_storage_account_key: \u0026#34;N/A\u0026#34; vault_storage: \u0026#34;\u0026#34; vault_storage_lock: \u0026#34;\u0026#34; apisix_admin_password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; grafana_admin_password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; oractl_admin_password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; oractl_user_password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; ... Create the ansible/vars/ebaas.yaml file, setting values as required. If this is a desktop installation, this file will be created for you by the Desktop Helper playbook.\nDefining the Database The database is defined in ansible/roles/database/vars/main.yaml. For example:\n--- database_oracle_dbs: [\u0026#34;BAASPDB\u0026#34;] database_default_db: BAASPDB BAASPDB: # noqa: var-naming[pattern] username: \u0026#34;PDBADMIN\u0026#34; password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; type: \u0026#34;EXTERNAL\u0026#34; service: \u0026#34;(DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=localhost)(PORT=1521))(CONNECT_DATA=(SERVICE_NAME=BAASPDB)))\u0026#34; ocid: \u0026#34;\u0026#34; ... Create the ansible/roles/database/vars/main.yaml file, setting values as required. If this is a desktop installation, this file will be created for you by the Desktop Helper playbook.\nThe database_oracle_dbs and database_default_db key values should be the name of your Pluggable Database (PDB). These are followed by the PDB name and Key/Values defining how to access the PDB.\nThe type can be either:\nEXTERNAL: A Pre-existing Oracle Database. Define service and leave ocid blank. ADB-S: A Pre-Existing Oracle Autonomous Serverless (ADB-S) database; provide the ocid for the ADB-S. Leave service blank. SIDB_CONTAINER: This will create a 19c containerized database inside the Kubernetes Cluster as part of the deployment. Leave ocid and service blank. Defining the Container Repository The Container Repository is defined in ansible/roles/registry/vars/main.yaml. For example:\n--- registry_username: \u0026#34;oracle\u0026#34; registry_password: \u0026#34;Correct-horse-Battery-staple-35\u0026#34; registry_push_url: \u0026#34;docker.io/myorg\u0026#34; registry_push_auth: auths: docker.io/myorg: auth: \u0026#34;b3JhY2xlOjdaUVgxLXhhbFR0NTJsS0VITlA0\u0026#34; registry_pull_url: \u0026#34;docker.io/myorg\u0026#34; registry_pull_auth: auths: docker.io/myorg: auth: \u0026#34;b3JhY2xlOjdaUVgxLXhhbFR0NTJsS0VITlA0\u0026#34; ... Create the ansible/roles/registry/vars/main.yaml file, setting values as required. If this is a desktop installation, this file will be created for you by the Desktop Helper playbook.\nSpecify the URL or authentication credentials for your Container Repository in registry_pull_url, registry_push_url, registry_username, and registry_password.\nFor the registry_pull_auth and registry_push_auth sections, manually log into your repository and copy the values found in the created file, located in $HOME/.config/containers/auth.json\nThere may be duplication between the push and pull URL\u0026rsquo;s. The pull URL is used inside the Pods while the push URL is used from the deployment machine. If you have a private registry inside the Kubernetes cluster, these URL\u0026rsquo;s could be different. This is the case for the Desktop installation. For example, the push URL is localhost:5000, while the pull URL is \u0026lt;Registry Pod ClusterIP\u0026gt;:5000.\nConfiguration Management Playbook From the source package, run the Configuration Management Playbook.\nInstall Ansible Using Python, install Ansible to run the Configuration Management Playbook. The Helper script creates a Python virtual environment and installs Ansible along with other additional modules. For example:\n./setup_ansible.sh source ./activate.env Desktop Helper Playbook If this is a desktop installation, then a Helper Playbook can be used to help define the infrastructure. Note that this playbook should only be run if following the desktop installation examples:\nmacOS Ventura (x86) Oracle Linux 8 (x86) Run the Desktop Helper Playbook to define the infrastructure. For example:\nansible-playbook ansible/desktop-apply.yaml Copy kubeconfig For the desktop installation, this step will have been performed by the Desktop Helper playbook.\nCopy the kubeconfig file to ansible/roles/kubernetes/files\nBuild and Push Images to the Container Repository For the desktop installation, start a new terminal and tunnel or port-forward to the Minikube cluster. Refer to the specific platform details for more information.\nFor both installations, run the Images Playbook on the original terminal. For example:\nansible-playbook ansible/images_build.yaml Install the Microservices Install the Microservices by running this command:\nansible-playbook ansible/k8s_apply.yaml -t full Footnotes Certification has been performed against Podman. However, other container or virtual machine managers are available and may be substituted.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","description":"The Oracle Backend for Spring Boot and Microservices is available to install in your own \u0026ldquo;custom\u0026rdquo; environment, which may be an on-premises data center environment, a different cloud provider, or a developer\u0026rsquo;s desktop.\nPrerequisites You must meet the following prerequisites to use the Oracle Backend for Spring Boot and Microservices On-Premises. You need:\nAccess to Oracle Database Enterprise Edition 19.3.0.0 Access to a Container Repository Access to a Kubernetes cluster Python 3+ When installing in a desktop environment, for example a developer\u0026rsquo;s desktop, the previously mentioned pre-requisites may be met through an additional setup task, but there are additional desktop system or software requirements."},{"id":5,"href":"/microservices-datadriven/spring/infrastructure/database/","title":"Database","parent":"Infrastructure","content":"The Oracle Backend for Spring Boot and Microservices uses the Oracle Database as a persistent data store for metadata and the Spring Cloud Config Server. This documentation will refer to this database as the Metadata Database.\nNOTE: Oracle recommends that you install an addition Container Database (CDB) and Pluggable Databases (PDBs) for your production applications inline with the Database-Per-Service pattern. This document will refer to these databases as the Application Database.\nBy default, the Oracle Autonomous Database - Serverless (ADB-S) is used for the Metadata Database, however, there are other options including Bring Your Own (BYO).\nThe following chart presents the options for the Metadata Database, based on the installation type:\nInstallation ADB-S BYO ADB-S BYO BaseDB BYO Containerized BYO External OCI Community x OCI Standard x x x x Custom x x x x x For custom installations, including on-premises, it is the responsibility of the user to ensure network access controls to provide both operational access and security. The Oracle Cloud Infrastructure (OCI) Networking setup can be used as a general template.\nBring Your Own Database - Standard Edition If you select the Standard Edition during installation, you can use a pre-created Oracle Database for the Oracle Backend for Spring Boot and Microservices Metadata Database.\nThe following are the minimum requirements for a BYO Oracle Database:\nVersion: 19c+ Bring Your Own Network with access to the Database Listener Database User with appropriate privileges (see below) Database User Privileges The database user for the the Oracle Backend for Spring Boot and Microservices Metadata Database is used to create other users and allow them to proxy through this user for database access. While the SYSTEM or ADMIN (for ADB-S) will work, they are over-privileged and should not be used in production environments.\nIt is recommended to create a user, in this example, named OBAAS with a default tablespace of DATA:\nCREATE USER OBAAS IDENTIFIED BY \u0026#34;Welcome_12345\u0026#34;; ALTER USER OBAAS QUOTA UNLIMITED ON DATA; GRANT ALTER USER TO OBAAS; GRANT CREATE USER TO OBAAS; GRANT CONNECT TO OBAAS WITH ADMIN OPTION; GRANT CREATE SESSION TO OBAAS WITH ADMIN OPTION; GRANT RESOURCE TO OBAAS WITH ADMIN OPTION; GRANT SELECT ON DBA_USERS TO OBAAS; GRANT CREATE ANY INDEX TO OBAAS; GRANT ALTER ANY TABLE TO OBAAS; GRANT COMMENT ANY TABLE TO OBAAS; GRANT CREATE ANY TABLE TO OBAAS; GRANT INSERT ANY TABLE TO OBAAS; GRANT SELECT ANY TABLE TO OBAAS; GRANT UPDATE ANY TABLE TO OBAAS; GRANT CREATE ANY SEQUENCE TO OBAAS; GRANT SELECT ANY SEQUENCE TO OBAAS; GRANT CREATE ANY TRIGGER TO OBAAS; -- Additional AQ perms GRANT AQ_USER_ROLE TO OBAAS WITH ADMIN OPTION; GRANT EXECUTE ON DBMS_AQ TO OBAAS WITH GRANT OPTION; GRANT EXECUTE ON DBMS_AQADM TO OBAAS WITH GRANT OPTION; GRANT EXECUTE ON DBMS_AQIN TO OBAAS WITH GRANT OPTION; GRANT EXECUTE ON DBMS_AQJMS TO OBAAS WITH GRANT OPTION; GRANT EXECUTE ON DBMS_AQJMS_INTERNAL TO OBAAS WITH GRANT OPTION; -- Additional for PARSE GRANT SODA_APP TO OBAAS WITH ADMIN OPTION; GRANT CREATE TABLE TO OBAAS WITH ADMIN OPTION; Configuration During the configuration of the Oracle Backend for Spring Boot and Microservices, ensure that the Edition is set to Standard:\nEnable and Configure Bring Your Own Virtual Network\nTick the \u0026ldquo;Bring Your Own Database\u0026rdquo; checkbox and, depending on the Bring Your Own Database - Type, provide the appropriate values.\nAutonomous Database - Serverless (ADB-S) BYO ADB-S Compartment : The compartment of the existing ADB-S.\nBring Your Own Database - Autonomous Database : The ADB-S name (this will automatically translate the name to an OCID).\nBring Your Own Database - Username : The existing database user with the appropriate privileges.\nBring Your Own Database - Password : The password for the existing database user.\nOther Bring Your Own Database - Connect String : The connect string for the database (PDB) in Long Format.\nBring Your Own Database - Username : The existing database user with the appropriate privileges.\nBring Your Own Database - Password : The password for the existing database user.\nThe Connect String should be in Long Format, for example:\n(DESCRIPTION=(ADDRESS=(host=oracle://somedb.example.com)(protocol=TCP)(port=1521)) (CONNECT_DATA=(SERVICE_NAME=orclpdb))) Application Databases Oracle recommends that additional pluggable databases are used for your applications, following the database-per-service microservice pattern. However, the Metadata Database can be used, especially for development purposes, with a schema-per-service model.\nThe Oracle Database Operator for Kubernetes is provided with the Oracle Backend for Spring Boot and Microservices and can be used:\nBind to additional ADB-S Bind to an OCI BaseDB and create PDBs Create a Single Instance Container Database in the Kubernetes Cluster ","description":"The Oracle Backend for Spring Boot and Microservices uses the Oracle Database as a persistent data store for metadata and the Spring Cloud Config Server. This documentation will refer to this database as the Metadata Database.\nNOTE: Oracle recommends that you install an addition Container Database (CDB) and Pluggable Databases (PDBs) for your production applications inline with the Database-Per-Service pattern. This document will refer to these databases as the Application Database."},{"id":6,"href":"/microservices-datadriven/spring/infrastructure/databaseaccess/","title":"Database Access","parent":"Infrastructure","content":"The Oracle Backend for Spring Boot and Microservices includes an Oracle database. An instance of Oracle Autonomous Database Serverless (ADB-S) is created during installation. The ADB-S is used for Oracle Backend for SPring Boot and Microservices metadata and Spring Cloud Config Server.\nIf you selected the PRIVATE_ENDPOINT_ACCESS option, you need to use a Bastion to access the database.\nNOTE: Oracle recommends that you install your own database and PDBs for your production applications. The database provisioned is used for Oracle Backend for Spring Boot metadata and can be used for development.\nAccessing the Database NOTE: Oracle recommends that you install SQLcl to access the database from a local machine. SQLcl installation guide. Other tools can be used but is not documented here.\nUsing Database Actions from the OCI Console Local access using Database Wallet and SQLcl (SECURE_ACCESS installation) Local access using Wallet and SQLcl using a Bastion (PRIVATE_ENDPOINT_ACCESS installation) Access the Oracle ADB-S using Database Actions You can use the Database Actions web user interface, which can be accessed from the Oracle Cloud Infrastructure Console (OCI Console) to access the database. The Oracle database is created in the compartment specified during installation of Oracle Backend for Spring Boot and Microservices.\nIn the OCI Console, navigate to Oracle Autonomous Database (ADB) in the main menu.\nOracle Autonomous DB Cloud Portal Click on the link Autonomous Transaction Processing, and then select the database with the application name that you configured during installation with the suffix DB. In this example the Database name is CALFDB (make sure that you have selected the correct Compartment).\nSelect ADB Database Click on Database Actions. This opens the Database Actions page where you have access to many database functions, including the ability to work with data stored by Oracle Backend for Spring Boot and Microservices.\nOracle Autonomous DB Details Accessing the ADB-S From a Local Machine using Database Wallet and SQLcl If SECURE_ACCESS was selected during installation you can access the database using the following steps.\nDownload the ADB-S Wallet If you chose the SECURE_ACCESS option for database access during installation (or accepted this default), then you have to download the wallet to access the database from your local machine.\nThe wallet can be downloaded from the OCI Console, by clicking Database Connection, followed by Download Wallet. Store the wallet in a safe place.\nDownload ADB client credential You have to enter a password for the Wallet.\nWallet Password Connect to the ADB-S using SQLcl Get the ADMIN user password from k8s secret. in the exa,ple below calfdb needs to be replaced with the name of database in the installation.\nkubectl -n application get secret calfdb-db-secrets -o jsonpath=\u0026#39;{.data.db\\.password}\u0026#39; | base64 -d; echo Open a terminal Window and start SQLcl with the /nolog option.\nsql /nolog Load the Wallet using the command set cloudconfig.... In this example the wallet name is Wallet_CALFDB.zip.\nLoad the Wallet Get the TNS name connection names from the wallet by executing this command:\nshow tns Load the Wallet Connect as the ADMIN user to the database using the password you obtained from the k8s secret previously using the command connect followed by ADMIN, password collected and the TNS Name.\nLoad the Wallet You are now connected to the database that is provided when installing Oracle Backend for Spring Boot and Microservices on OCI.\nNOTE: Oracle recommends that you install your own databases, PDBs for your production applications. The database provisioned is used for Oracle Backend for Spring Boot metadata and can be used for development.\nAccessing the ADB-S From a Local Machine using Database Wallet and SQLcl using a Bastion If PRIVATE_ENDPOINT_ACCESS was selected during installation you can access the database using the following steps. You are going to need a Private Key pair to be able to use the Bastion Service to access the ADB-S.\nDownload and modify the Wallet the ADB-S Wallet using Private Access If you chose the PRIVATE_ENDPOINT_ACCESS option for database access during installation (or accepted this default), then you have to download the wallet to access the database from your local machine.\nThe wallet can be downloaded from the OCI Console, by clicking Database Connection, followed by Download Wallet. Store the wallet in a safe place.\nDownload ADB client credential You have to enter a password for the Wallet.\nWallet Password Go to the directory where you stored the Wallet and execute the following command. Replace \u0026lt;Wallet-File\u0026gt; with the name of your Wallet file including .zip:\nzip -oq \u0026lt;Wallet-File\u0026gt; tnsnames.ora \u0026amp;\u0026amp; \\ sed -i \u0026#39;\u0026#39; \u0026#39;s/host=[^)]*/host=localhost/\u0026#39; tnsnames.ora \u0026amp;\u0026amp; \\ zip -uq \u0026lt;Wallet-File\u0026gt; tnsnames.ora NOTE: On certain platforms you may need to use unzip instead of zip as the command.\nConnect to the ADB-S using SQLcl via a Bastion Get the IP address of the deployed Autonomous Database. T=You can find the IP address in the OCI Console:\nADB-S Private IP Address Create a SSH Port Forwarding Session using the Bastion service.\nA Bastion service is deployed when selecting PRIVATE_ENDPOINT_ACCESS during installation. To access the Oracle Autonomous Database you need to create a session between your local machine and the Oracle Autonomous Database using the Bastion Service. Create a Dynamic Port Forwarding (SOCKS5) Session.\nSelect the Bastion Service in the Identity \u0026amp; Security Menu:\nLoad the Wallet Select the Bastion service for your deployment and click Create Session. This will bring up a dialog box where you need to fill in the values for your installation.\nSession Type : Select SSH port forwarding session. Session Name : Enter a name for the session. IP Address : Enter the Private IP Address for the ADB-S. Port : Enter 1522 as the port number SSH Key : Add a Public SSH Key that will be used for the session. Download ADB client credential After the session is created, establish a SSH tunnel your your ADB instance by issuing an ssh command in a terminal window. The SSH is obtained obtain by clicking on the three dots symbol on right side of the created session in the OCI COnsole. The session will run until you close the terminal window.\nReplace \u0026lt;privateKey\u0026gt; with path to your Private Key and \u0026lt;localPort\u0026gt; with the local port you want to use. For example:\nssh -i \u0026lt;privateKey\u0026gt; -N -L \u0026lt;localPort\u0026gt;:10.113.0.28:1522 -p 22 ocid1.bastionsession.oc1.....@host.bastion...... Get the ADMIN user password from k8s secret. in the exa,ple below bluegilldb needs to be replaced with the name of database in the installation.\nkubectl -n application get secret bluegilldb-db-secrets -o jsonpath=\u0026#39;{.data.db\\.password}\u0026#39; | base64 -d; echo Open a terminal Window and start SQLcl with the /nolog option.\nsql /nolog Load the Wallet using the command set cloudconfig.... In this example the wallet name is Wallet_CALFDB.zip.\nLoad the Wallet Get the TNS name connection names from the wallet by executing this command:\nshow tns Load the Wallet Connect as the ADMIN user to the database using the password you obtained from the k8s secret previously using the command connect followed by ADMIN, password collected and the TNS Name.\nLoad the Wallet You are now connected to the database that is provided when installing Oracle Backend for Spring Boot and Microservices on OCI.\nNOTE: Oracle recommends that you install your own databases, PDBs for your production applications. The database provisioned is used for Oracle Backend for Spring Boot metadata and can be used for development.\n","description":"The Oracle Backend for Spring Boot and Microservices includes an Oracle database. An instance of Oracle Autonomous Database Serverless (ADB-S) is created during installation. The ADB-S is used for Oracle Backend for SPring Boot and Microservices metadata and Spring Cloud Config Server.\nIf you selected the PRIVATE_ENDPOINT_ACCESS option, you need to use a Bastion to access the database.\nNOTE: Oracle recommends that you install your own database and PDBs for your production applications."},{"id":7,"href":"/microservices-datadriven/spring/on-premises/macos_ventura/","title":"Developer Installation - macOS Ventura (x86)","parent":"Custom Installations","content":"This is a discussion of a non-production (developer desktop) installation on a macOS Ventura desktop.\nRead the On-Premises documentation and ensure that your desktop meets the minimum system requirements.\nInstall Podman To install Podman, process these commands:\nbrew install podman PODMAN_VERSION=$(podman -v |awk \u0026#39;{print $NF}\u0026#39;) sudo /usr/local/Cellar/podman/${PODMAN_VERSION}/bin/podman-mac-helper install podman machine init --cpus 4 --disk-size 60 --memory 8192 --rootful --now podman system connection default podman-machine-default-root Download the Database or Oracle REST Data Services (ORDS) Images The non-production installation provisions an Oracle database into the Kubernetes cluster. The images must be downloaded from Oracle Cloud Infrastructure Registry (Container Registry) before continuing.\nLog in to the Container Registry. For example:\npodman login container-registry.oracle.com\nPull the database image. For example:\npodman pull container-registry.oracle.com/database/enterprise:21.3.0.0\nPull the ORDS image. For example:\npodman pull container-registry.oracle.com/database/ords:21.4.2-gh\nMinikube To install Minikube, process these commands:\nbrew install minikube minikube config set driver podman minikube start --cpus 4 --memory max --container-runtime=containerd minikube addons enable ingress If Minikube fails to start and returns this Failed kubeconfig update: could not read config error, process this command and retry:\nmv ~/.kube ~/.kube.bak\nDownload Oracle Backend for Spring Boot and Microservices Download the latest version of Oracle Backend for Spring Boot and Microservices and unzip into a new directory.\nInstall Ansible To install Ansible, process these commands:\n./setup_ansible.sh source ./activate.env Define the Infrastructure Use the Helper Playbook to define the infrastructure. This Playbook also:\nCreates additional namespaces for the Container Registry and the database. Creates a private Container Registry in the Kubernetes cluster. Modifies the Microservices application to be desktop compatible. Run this command:\nansible-playbook ansible/desktop_apply.yaml\nOpen a Tunnel In order to push the images to the Container Registry in the Kubernetes cluster, open a new terminal and start a tunnel by running this command:\nminikube tunnel\nTo test access to the registry, process this command:\ncurl -X GET -k https://localhost:5000/v2/_catalog\nThis curl command should result in the following:\n{\u0026#34;errors\u0026#34;:[{\u0026#34;code\u0026#34;:\u0026#34;UNAUTHORIZED\u0026#34;,\u0026#34;message\u0026#34;:\u0026#34;authentication required\u0026#34;,\u0026#34;detail\u0026#34;:[{\u0026#34;Type\u0026#34;:\u0026#34;registry\u0026#34;,\u0026#34;Class\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;Name\u0026#34;:\u0026#34;catalog\u0026#34;,\u0026#34;Action\u0026#34;:\u0026#34;*\u0026#34;}]}]} Build the Images Build and push the images to the Container Registry in the Kubernetes cluster by running this command:\nansible-playbook ansible/images_build.yaml\nAfter the images are built and pushed, the tunnel is no longer required and can be stopped.\nDeploy Oracle Backend for Spring Boot and Microservices Deploy the database and Microservices by running this command:\nansible-playbook ansible/k8s_apply.yaml -t full\nNotes VPN and Proxies If you are behind a virtual private network (VPN) or proxy, see minikube VPN or Proxy for more details on additional tasks.\n","description":"This is a discussion of a non-production (developer desktop) installation on a macOS Ventura desktop.\nRead the On-Premises documentation and ensure that your desktop meets the minimum system requirements.\nInstall Podman To install Podman, process these commands:\nbrew install podman PODMAN_VERSION=$(podman -v |awk \u0026#39;{print $NF}\u0026#39;) sudo /usr/local/Cellar/podman/${PODMAN_VERSION}/bin/podman-mac-helper install podman machine init --cpus 4 --disk-size 60 --memory 8192 --rootful --now podman system connection default podman-machine-default-root Download the Database or Oracle REST Data Services (ORDS) Images The non-production installation provisions an Oracle database into the Kubernetes cluster."},{"id":8,"href":"/microservices-datadriven/spring/on-premises/ol8/","title":"Developer Installation - Oracle Linux 8 (x86)","parent":"Custom Installations","content":"This is an description of installing on a Oracle Linux 8 desktop.\nRead the On-Premises documentation and ensure that your desktop meets the minimum system requirements.\nSetup Create a Non-Root User Create a new user. While any user name can be created, the rest of this documentation refers to the non-root user as obaas:\nAs root, process the following:\nuseradd obaas Download Oracle Backend for Spring Boot and Microservices Download the latest version of Oracle Backend for Spring Boot and unzip into a new directory.\nAs the obaas user, run this command:\nunzip onprem-ebaas_latest.zip -d ~/obaas Setup SSH-Key Access for obaas user Future access to the obaas user requires a direct login (not sudo or su). To setup ssh-key access as obaas, run the following commands:\nmkdir ~/.ssh vi ~/.ssh/authorized_keys Paste the public key of your client machines into the ~/.ssh/authorized_keys file, and change the permissions as follows:\nchmod 700 .ssh chmod 600 .ssh/authorized_keys Update the operating system Assuming the source was unzipped to ~obaas/obaas, as the root user, update the operating system by running the ol8_onprem.sh script from the unzipped package:\n~obaas/obaas/ol8_onprem.sh This script performs the following actions:\nInstall required operating system Packages Install Minikube Set Python3 as the default python Enable cgroup v2 Enable IP Tables Update the container runtime configuration (Optional) OCI Host Filesystem If this is being installed on an OCI Compute instance, grow the filesystem:\nAs root:\n/usr/libexec/oci-growfs Reboot IMPORTANT After the operating system has been updated, reboot the host.\nInstall The remaining steps require direct login as the obaas user without using sudo or su.\nDownload the Database or Oracle REST Data Services (ORDS) Images The non-production installation provisions an Oracle database into the Kubernetes cluster. The images must be downloaded from Oracle Cloud Infrastructure Registry (Container Registry) before continuing.\nWhile directly logged into the obaas user, process these steps:\nLog in to the Container Registry. For example:\npodman login container-registry.oracle.com\nPull the database image. For example:\npodman pull container-registry.oracle.com/database/enterprise:19.3.0.0\nPull the ORDS image. For example:\npodman pull container-registry.oracle.com/database/ords:21.4.2-gh\nTroubleshooting If the podman pull command fails, navigate in a web browser to Oracle container registry, click the \u0026ldquo;database\u0026rdquo; tile and select \u0026ldquo;enterprise\u0026rdquo;. On the right hand side of the page, if prompted, sign-in. Select \u0026ldquo;Language\u0026rdquo; and accept the Terms. Try the podman pull command again.\nStart MiniKube While directly logged into the obaas user, run these commands:\nminikube config set rootless true minikube config set driver podman minikube start --cpus max --memory 16G --disk-size=\u0026#39;40g\u0026#39; --container-runtime=containerd minikube addons enable ingress echo \u0026#34;KUBECONFIG=~/.kube/config\u0026#34; \u0026gt;\u0026gt; ~/.bashrc Install Ansible While directly logged into the obaas user, change to the source directory and install Ansible by running these commands:\ncd ~/obaas ./setup_ansible.sh source ./activate.env Define the Infrastructure Use the Helper Playbook to define the infrastructure. This Playbook also:\nCreates additional namespaces for the Container Registry and database. Creates a private Container Registry in the Kubernetes cluster. Modifies the Microservices application to be desktop compatible. Assuming the source was unzipped to ~/obaas, run the following command as the obaas user:\nansible-playbook ~/obaas/ansible/desktop_apply.yaml\nOpen a Tunnel In order to push the images to the Container Registry in the Kubernetes cluster, open a new terminal and process this command while being directly logged into the obaas user:\ncd ~/obaas source ./activate.env kubectl port-forward service/private -n container-registry 5000:5000 \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 \u0026amp; Build the Images Build and push the images to the Container Registry in the Kubernetes cluster.\nAssuming the source was unzipped to ~/obaas, run the following command as the obaas user:\ncd ~/obaas source ./activate.env ansible-playbook ~/obaas/ansible/images_build.yaml After the images are built and pushed, the port-forward is no longer required and can be stopped.\nDeploy Microservices Assuming the source was unzipped to ~/obaas, run this command as the obaas user:\ncd ~/obaas source ./activate.env ansible-playbook ~/obaas/ansible/k8s_apply.yaml -t full Notes config-server and obaas-admin Pod Failures The Pods in the azn-server, config-server, and obaas-admin namespaces rely on the database that is created in the oracle-database-operator-system. During the initial provisioning, these Pods start well before the database is available resulting in initial failures. They resolve themselves once the database becomes available.\nYou can check on the status of the database by running this command:\nkubectl get singleinstancedatabase baas -n oracle-database-operator-system -o \u0026quot;jsonpath={.status.status}\u0026quot;\nVPN and Proxies If you are behind a Virtual Private Network (VPN) or proxy, see Minikube Proxies and VPNs for more details on additional tasks.\nNext, go to the Getting Started page to learn more.\n","description":"This is an description of installing on a Oracle Linux 8 desktop.\nRead the On-Premises documentation and ensure that your desktop meets the minimum system requirements.\nSetup Create a Non-Root User Create a new user. While any user name can be created, the rest of this documentation refers to the non-root user as obaas:\nAs root, process the following:\nuseradd obaas Download Oracle Backend for Spring Boot and Microservices Download the latest version of Oracle Backend for Spring Boot and unzip into a new directory."},{"id":9,"href":"/microservices-datadriven/spring/development/","title":"Development","parent":"Oracle Backend for Spring Boot and Microservices","content":"This section provides information about how to develop and deploy Spring Boot applications with the Oracle Backend for Spring Boot and Microservices.\nSpring Boot applications can be developed with no special requirements and be deployed into Oracle Backend for Spring Boot and Microservices. However, if you do opt-in to the platform services provided and the CLI, you can shorten your development time and avoid unnecessary work.\nOracle Backend for Spring Boot provides the following services that applications can use:\nAn Oracle Autonomous Database instance in which applications can manage relational, document, spatial, graph and other types of data, can use Transactional Event Queues for messaging and events using Java Message Service (JMS), Apache Kafka or Representational State Transfer (REST) interfaces, and even run machine learning (ML) models. A Kubernetes cluster in which applications can run with namespaces pre-configured with Kubernetes Secrets and ConfigMaps for access to the Oracle Autonomous Database instance associated with the backend. An Apache APISIX API Gateway that can be used to expose service endpoints outside the Kubernetes cluster, to the public internet. All standard Apache APISIX features like traffic management, monitoring, authentication, and so on, are available for use. Spring Boot Eureka Service Registry for service discovery. The API Gateway and monitoring services are pre-configured to use this registry for service discovery. Spring Cloud Config Server to serve externalized configuration information to applications. This stores the configuration data in the Oracle Autonomous Database instance associated with the backend. Netflix Conductor OSS for running workflows to orchestrate your services. Hashicorp Vault for storing sensitive information. Spring Admin for monitoring your services. Prometheus and Grafana for collecting and visualizing metrics and for alerting. Jaeger and Open Telemetry (OTEL) for distributed tracing. Applications deployed to the Oracle Backend for Spring Boot may use Jaeger or OTEL for distributed tracing. See the Environment Variables page for variables that can be used. An integrated development environment is recommended for developing applications. Oracle recommends Visual Studio Code or IntelliJ.\nJava, Maven or Gradle, a version control system (Oracle recommends git), and other tools may be required during development.\n","description":"This section provides information about how to develop and deploy Spring Boot applications with the Oracle Backend for Spring Boot and Microservices.\nSpring Boot applications can be developed with no special requirements and be deployed into Oracle Backend for Spring Boot and Microservices. However, if you do opt-in to the platform services provided and the CLI, you can shorten your development time and avoid unnecessary work.\nOracle Backend for Spring Boot provides the following services that applications can use:"},{"id":10,"href":"/microservices-datadriven/spring/development/setup/","title":"Development Environment Setup","parent":"Development","content":"This page provides details on how to set up your development environment to work with Oracle Backend for Spring Boot and Microservices.\nThe following platforms are recommended for a development environment:\nMicrosoft Windows 10 or 11, preferably with Windows Subsystem for Linux 2 macOS (11 or later recommended) on Intel or Apple silicon Linux, for example Oracle Linux, Ubuntu, and so on. The following tools are recommended for a development environment:\nIntegrated Development Environment, for example Visual Studio Code Java Development Kit, for example Oracle, OpenJDK, or GraalVM Maven or Gradle for build and testing automation Spring CLI (optional) for project creation If you wish to test locally or offline, then the following additional tools are recommended:\nA container platform, for example Rancher Desktop An Oracle database (in a container) Integrated Development Environment Oracle recommends Visual Studio Code, which you can download here, and the following extensions to make it easier to write and build your code:\nSpring Boot Extension Pack Extension Pack for Java Oracle Developer Tools You can install these by opening the extensions tab (Ctrl-Shift-X or equivalent) and using the search bar at the top to find and install them.\nJava Development Kit Oracle recommends the Java SE Development Kit or GraalVM. Java 17 or 21 are recommended, note that Spring Boot 3.0 requires at least Java 17. If you want to use JVM Virtual Threads, then Java 21 is required.\nNote: If you are using Spring Boot 2.x, then Oracle encourages you to use at least Java 17, unless you have a specific reason to stay on Java 11. Refer to the Spring Boot Support page for information on support dates for Spring Boot 2.x.\nYou can download the latest x64 Java 17 Development Kit from this permalink.\nDecompress the archive in your chosen location (for example your home directory) and then add it to your path:\nexport JAVA_HOME=$HOME/jdk-17.0.3 export PATH=$JAVA_HOME/bin:$PATH Use the following command to verify it is installed:\n$ java -version java version \u0026#34;17.0.3\u0026#34; 2022-04-19 LTS Java(TM) SE Runtime Environment (build 17.0.3+8-LTS-111) Java HotSpot(TM) 64-Bit Server VM (build 17.0.3+8-LTS-111, mixed mode, sharing) Note: Native Images: If you want to compile your Spring Boot microservices into native images (which was officially supported from Spring Boot 3.0), then you must use GraalVM, which can be downloaded from here.\nMaven You can use either Maven or Gradle to build your Spring Boot applications. If you prefer Maven, then follow the steps in this section. If you prefer Gradle, then refer to the next section.\nDownload Maven from the Apache Maven website.\nDecompress the archive in your chosen location (for example your home directory) and then add it to your path:\n$ export PATH=$HOME/apache-maven-3.8.6/bin:$PATH Use the following command to verify it is installed (note that your version may give slightly different output):\n$ mvn -v Apache Maven 3.8.6 (84538c9988a25aec085021c365c560670ad80f63) Maven home: /home/mark/apache-maven-3.8.6 Java version: 17.0.3, vendor: Oracle Corporation, runtime: /home/mark/jdk-17.0.3 Default locale: en, platform encoding: UTF-8 OS name: \u0026#34;linux\u0026#34;, version: \u0026#34;5.10.102.1-microsoft-standard-wsl2\u0026#34;, arch: \u0026#34;amd64\u0026#34;, family: \u0026#34;unix\u0026#34; Gradle Download Gradle using the instructions on the Gradle website. Spring Boot is compatible with Gradle version 7.5 or later.\nRun the following command to verify that Gradle is installed correctly\n$ gradle -v ------------------------------------------------------------ Gradle 7.6 ------------------------------------------------------------ Build time: 2022-11-25 13:35:10 UTC Revision: daece9dbc5b79370cc8e4fd6fe4b2cd400e150a8 Kotlin: 1.7.10 Groovy: 3.0.13 Ant: Apache Ant(TM) version 1.10.11 compiled on July 10 2021 JVM: 17.0.3 (Oracle Corporation 17.0.3+8-LTS-111) OS: Linux 5.10.102.1-microsoft-standard-WSL2 amd64 Spring CLI for project creation You can create projects with Spring CLI. To use this feature, install Spring CLI following the instructions provided in that repository, and then import the Oracle Project Catalog as follows:\nspring project catalog add --name oracle --url https://github.com/oracle/spring-cloud-oci/tree/obaas-starter/database/spring-cli/catalog To create a new project, for example called test2 with specific Maven group and artifact IDs, use a command similar to this, substituting your desired coordinates:\nspring boot new --name test2 --from obaas --group-id com.example --artifact-id test2 --version 0.0.1 Review the README file in the created project for details of next steps.\nOracle Database in a container for local testing If you want to run an instance of Oracle Database locally for development and testing, then Oracle recommends Oracle Database 23c Free. You can start the database in a container with this command specifying a secure password:\ndocker run --name free23c -d \\ -p 1521:1521 \\ -e ORACLE_PWD=Welcome12345 \\ container-registry.oracle.com/database/free:latest Note: If you are using testcontainers, then add the following dependency to your application:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.testcontainers\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-free\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.19.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; ","description":"This page provides details on how to set up your development environment to work with Oracle Backend for Spring Boot and Microservices.\nThe following platforms are recommended for a development environment:\nMicrosoft Windows 10 or 11, preferably with Windows Subsystem for Linux 2 macOS (11 or later recommended) on Intel or Apple silicon Linux, for example Oracle Linux, Ubuntu, and so on. The following tools are recommended for a development environment:"},{"id":11,"href":"/microservices-datadriven/spring/platform/eureka/","title":"Eureka Service Discovery","parent":"Platform Services","content":"Oracle Backend for Spring Boot and Microservices includes the Spring Boot Eureka service registry, which is an application that stores information about client services or applications. Typically, each Microservice registers with the Eureka server at startup and the Eureka server maintains a list of all active instances of the service, including their ports and IP addresses. This information can be accessed by other services using a well-known key. This allows services to interact with each other without needing to know the other addresses at development or deployment time.\nAccess the Eureka Web User Interface To access the Eureka web user interface, process these steps:\nExpose the Eureka web user interface using this command:\nkubectl port-forward -n eureka svc/eureka 8761 Open the Eureka web user interface URL http://localhost:8761\nEureka web user interface On the dashboard you will see all the internal services registered with Eureka. If you have deployed the sample application CloudBank or done the LiveLab for Oracle Backend for Spring Boot and Microservices you will see those services.\n","description":"Oracle Backend for Spring Boot and Microservices includes the Spring Boot Eureka service registry, which is an application that stores information about client services or applications. Typically, each Microservice registers with the Eureka server at startup and the Eureka server maintains a list of all active instances of the service, including their ports and IP addresses. This information can be accessed by other services using a well-known key. This allows services to interact with each other without needing to know the other addresses at development or deployment time."},{"id":12,"href":"/microservices-datadriven/spring/get-help/","title":"Get Help","parent":"Oracle Backend for Spring Boot and Microservices","content":"If you need help with Oracle Backend for Spring Boot and Microservices you can seek help at the following channels:\nE-mail: obaas_ww@oracle.com Slack: https://oracledevs.slack.com/archives/C06L9CDGR6Z GitHub Issue: https://github.com/oracle/microservices-datadriven/issues When asking for help please provide the following:\nWhich version of Oracle Backend for Spring Boot and Microservices are you using? Which component(s) do you have an issue with? If possible, provide a testcase that shows the issue. Diagnostics Collection Two utilities will help Oracle diagnose and fix issues you may experience.\nBaseline The baseline command (Linux only) will collect non-sensitive information about your cluster and can be used to compare the current cluster state with a baseline state. This will help to quickly identify any discrepancies between a stable deployment and the current deployments.\nThe baseline utility can be run in one of three modes:\nGather baseline\nThis will write out a file \u0026lt;VERSION\u0026gt;.json by connecting to a kubernetes cluster and evaluating the current configuration. Use the gather option to establish a baseline of a working deployment.\nGather and Compare baseline --compare\nThis will look for a file called \u0026lt;OBAAS_VERSION\u0026gt;.json and write out a new file \u0026lt;OBAAS_VERSION\u0026gt;_current.json of the current configuration. The two files will be compared for differences.\nCompare baseline --compare \u0026lt;baselineFile\u0026gt; \u0026lt;currentFile\u0026gt;\nThis will compare two existing files, generated by the utility.\nCluster Dump A script is provided which can help to collect information about the configuration of your environment, logs of platform services, and various other information that may be helpful to diagnose and fix issues. Usage of this script is optional, and you should be aware that it is possible, and likely, that the output of this script may contain private or sensitive information. If you choose to run the script, you must review the contents of the output before providing that output to Oracle or anyone else.\n","description":"If you need help with Oracle Backend for Spring Boot and Microservices you can seek help at the following channels:\nE-mail: obaas_ww@oracle.com Slack: https://oracledevs.slack.com/archives/C06L9CDGR6Z GitHub Issue: https://github.com/oracle/microservices-datadriven/issues When asking for help please provide the following:\nWhich version of Oracle Backend for Spring Boot and Microservices are you using? Which component(s) do you have an issue with? If possible, provide a testcase that shows the issue. Diagnostics Collection Two utilities will help Oracle diagnose and fix issues you may experience."},{"id":13,"href":"/microservices-datadriven/spring/getting-started/","title":"Getting Started","parent":"Oracle Backend for Spring Boot and Microservices","content":"There are a number of demonstrations (videos) and hands-on labs (Live Lab) that show how to use Oracle Backend for Spring Boot and Microservices (Spring Boot).\nPrerequisites Deployed Oracle Backend for Spring Boot and Microservices. Introduction Video Watch this video for more information.\nBuild a Spring Boot Application With the Oracle Spring Boot Starters for UCP and Wallet In this video (18 minutes), Andy shows you how to:\nBuild a Phonebook application using Spring Boot with the Oracle Spring Boot Starters for Universal Connection Pools (UCP) and wallet. Deploy the applications to the Oracle Backend for Spring Boot and Microservices. Run tests. CloudBank - Building an Application with Spring Boot and Mobile APIs with Oracle Database and Kubernetes In this workshop (~ 2 hours), you learn how to build Microservices using Spring Boot and deploy them to the Oracle Backend for Spring Boot and Microservices. You learn about accessing the database using the Java Persistence API (JPA), service discovery, exposing services with the API Gateway, managing transactions across Microservices, workflow, and using observability tools to monitor your services and diagnose issues.\nIf you have already deployed Oracle Backend for Spring Boot and Microservices, you can skip Lab 1 (Provision an Instance).\nMore Learning There are more channels to learn about Oracle Backend for Spring Boot and Microservices:\nCheck out our blogs Join our Youtube Channel Next, go to the Platform Services page to learn more.\n","description":"There are a number of demonstrations (videos) and hands-on labs (Live Lab) that show how to use Oracle Backend for Spring Boot and Microservices (Spring Boot).\nPrerequisites Deployed Oracle Backend for Spring Boot and Microservices. Introduction Video Watch this video for more information.\nBuild a Spring Boot Application With the Oracle Spring Boot Starters for UCP and Wallet In this video (18 minutes), Andy shows you how to:\nBuild a Phonebook application using Spring Boot with the Oracle Spring Boot Starters for Universal Connection Pools (UCP) and wallet."},{"id":14,"href":"/microservices-datadriven/spring/platform/vault/","title":"HashiCorp Vault","parent":"Platform Services","content":"Oracle Backend as a Service for Spring Cloud and Microservices includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets, and other sensitive data using a user interface (UI), command-line interface (CLI), or Hypertext Transfer Protocol (HTTP) API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Accessing the root Token Production Mode Accessing the root Token Development Mode Accessing Vault Recovery Keys Production Mode Accessing Vault Using kubectl Accessing the Vault Using the Web User Interface Audit Logs Grafana dashboard for HashiCorp Vault Setup Information The Vault can be deployed in two different ways. See the Setup:\nDevelopment mode Production mode Warning Never run a Development mode server in production. It is insecure and will lose data on every restart (since it stores data in-memory). It is only intended for development or experimentation. Vault uses the following Oracle Cloud Infrastructure (OCI) services when running in Production mode. When running in Development mode, only the OCI Container Engine for Kubernetes (OKE) is used.\nObject storage for storing Vault data. OCI Vault to automatically unseal the Vault. OCI Container Engine for Kubernetes for running the Vault server. When running in Production mode, the Vault is unsealed using the OCI Key Management Service (KMS) key. The root token can be accessed using the kubectl command-line interface. The root token in Development mode is root.\nThe following Vault services are enabled during deployment. Other services can be enabled using the vault command and the web user interface:\nToken Authentication Method. The token authentication method is built-in and automatically available. It allows users to authenticate using a token, as well as create new tokens, revoke secrets by token, and more. AppRole Authentication Method. The approle authentication method allows machines or applications to authenticate with Vault-defined roles. Kubernetes Authentication Method. The kubernetes authentication method can be used to authenticate with Vault using a Kubernetes service account token. This method of authentication makes it easy to introduce a Vault token into a Kubernetes Pod. Userpass Authentication Method. The userpass authentication method allows users to authenticate with Vault with a user name and password combination. Key/Value Secrets Engine. The non-versioned Key/Value secrets engine is a generic Key/Value store used to store arbitrary secrets. Key/Value Secrets Engine Version 2. The Key/Value secrets engine is a generic Key/Value store used to store arbitrary secrets. Accessing the root Token Production Mode root tokens have the root policy attached to them. root tokens can do anything in Vault and are useful in Development mode but should be restricted in Production mode. In fact, the Vault team recommends that root tokens only be used for the initial setup. Be sure to save the initial root token in a secure way. For example:\nkubectl get secret vault-root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34;; echo Warning It is very important that the token is saved in multiple places. Losing the token can result in loss of access to the Vault. Accessing the root Token Development Mode The root token is set to root in Development mode. There are no recovery keys when running in Development mode.\nAccessing Vault Recovery Keys Production Mode Vault is configured to automatically unseal (auto unseal) using OCI Vault. Initializing with auto unseal creates five recovery keys that are stored in K8s Secrets. They MUST be retrieved and stored in a second location.\nWarning It is very important that recovery keys are saved in multiple places. Losing the recovery keys can result in loss of Vault. To extract the five recovery keys, use the following commands:\n% kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.1\\\u0026#34; }}\u0026#34;; echo % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.2\\\u0026#34; }}\u0026#34;; echo % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.3\\\u0026#34; }}\u0026#34;; echo % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.4\\\u0026#34; }}\u0026#34;; echo % kubectl get secret vault-recovery-keys -n vault --template=\u0026#34;{{index .data \\\u0026#34;recovery.key.5\\\u0026#34; }}\u0026#34;; echo Accessing Vault Using kubectl To access the Vault using the kubectl command-line interface, you need to set up Access Kubernetes Cluster.\nTest access to the Vault.\nVault Documentation contains all of the commands that you can use with the Vault CLI. For example, this command returns the current status of Vault on one of the pods:\nkubectl exec pod/vault-0 -n vault -it -- vault status The output looks similar to this:\nKey Value --- ----- Recovery Seal Type shamir Initialized true Sealed false Total Recovery Shares 5 Threshold 3 Version 1.11.3 Build Date 2022-08-26T10:27:10Z Storage Type oci Cluster Name vault-cluster-28535f69 Cluster ID 993662ee-b3ee-2a13-3354-97adae01e1ca HA Enabled true HA Cluster https://vault-0.vault-internal:8201 HA Mode active Active Since 2023-01-26T16:14:32.628291153Z Get the token and log in to the Vault.\nTo interact with the Vault in Production mode, you need to log in using a token that is stored in a K8s Secret. Get the token by running the following command. The output is the root token. It is very important that the token is saved in multiple places. Losing the token can result in loss of access to the Vault. In Development mode, the root token is root.\nGet the token with this command:\nkubectl get secret vault-root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34;; echo Log in to the Vault and provide the token with this command:\nkubectl exec pod/vault-0 -n vault -it -- vault login The following is sample output from logging in as the root user which should only be done during the initial set up. As an administrator, you must generate separate tokens and access control lists (ACLs) for the users that need access to the Vault. See Vault Documentation. For example:\nKey Value --- ----- token hvs....... token_accessor Hcx....... token_duration ∞ token_renewable false token_policies [\u0026#34;root\u0026#34;] identity_policies [] policies [\u0026#34;root\u0026#34;] To display the enabled secret engines, process this command:\nkubectl exec pod/vault-0 -n vault -it -- vault secrets list The output looks similar to this:\nPath Type Accessor Description ---- ---- -------- ----------- cubbyhole/ cubbyhole cubbyhole_a07a59ec per-token private secret storage identity/ identity identity_8b1e1a80 identity store kv-v2/ kv kv_06acc397 n/a sys/ system system_df5c39a8 system endpoints used for control, policy and debugging To display the enabled authentication methods, process this command:\nkubectl exec pod/vault-0 -n vault -it -- vault auth list The output looks similar to this:\nPath Type Accessor Description ---- ---- -------- ----------- approle/ approle auth_approle_00ffb93b n/a kubernetes/ kubernetes auth_kubernetes_c9bb0698 n/a token/ token auth_token_68b0beb2 token based credentials userpass/ userpass auth_userpass_afb2fb02 n/a Create a secret at path kv-v2/customer/acme with a customer_name and a customer_email. For example:\nkubectl exec pod/vault-0 -n vault -it -- vault kv put -mount=kv-v2 \\ customer/acme customer_name=\u0026#34;ACME Inc.\u0026#34; contact_email=\u0026#34;john.smith@acme.com\u0026#34; The output looks similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 Retrieve the created secret:\nkubectl exec pod/vault-0 -n vault -it -- vault kv get -mount=kv-v2 customer/acme The output looks similar to this:\n====== Secret Path ====== kv-v2/data/customer/acme ======= Metadata ======= Key Value --- ----- created_time 2023-01-30T15:53:41.85529383Z custom_metadata \u0026lt;nil\u0026gt; deletion_time n/a destroyed false version 1 ======== Data ======== Key Value --- ----- contact_email john.smith@acme.com customer_name ACME Inc. For more information about the Key/Value secrets engine, see the Key/Value Documentation and Versioned Key/Value Secrets Engine Tutorial.\nAccessing the Vault Using the Web User Interface To access the Vault, process these steps:\nExpose the Vault web user interface (UI) using this command:\nkubectl port-forward -n vault svc/vault 8200 Get the root token.\nTo interact with the Vault in Production mode, you need to log in using a token that is stored in a K8s Secret. Get the token by running the following command. The output is the root token. It is very important that the token is saved in multiple places. Losing the token can result in loss of access to the Vault. In Development mode, the root token is root. For example:\nkubectl get secret vault-root-token -n vault --template=\u0026#34;{{index .data \\\u0026#34;root.token\\\u0026#34; | base64decode}}\u0026#34;; echo Open the Vault web user interface URL: https://localhost:8200\nVault Web User Interface Log in using the root token. As an administrator, you must generate separate tokens and access control lists (ACLs) for the users that need access to the Vault. See Vault Documentation.\nYou are presented with the Home screen:\nVault Home Page Audit logs Important Audit logging is blocking, if the file is bigger than allowed space HashiCorp Vault will stop taking requests. If you deployed Oracle Backend for Spring Boot and Microservices using STANDARD edition, HashiCorp Vault will be deployed in production mode and you have the option of turing on audit logs. Note, you must be authenticated to turn on audit logs.\nTo turn on audit logs execute the following command:\nkubectl exec pod/vault-0 -n vault -it -- vault audit enable file file_path=/vault/audit/vault-audit.log You can to list enabled audit devices using the following command. The file_path is pointing to a directory on the pods where Vault is running.\nkubectl exec pod/vault-0 -n vault -it -- vault audit list -detailed If audit is enabled the output should look like this:\nPath Type Description Replication Options ---- ---- ----------- ----------- ------- file/ file n/a replicated file_path=/vault/audit/vault-audit.log To disable audit execute the following command:\nkubectl exec pod/vault-0 -n vault -it -- vault audit disable file Learn how to query audit logs here.\nGrafana dashboard for HashiCorp Vault Oracle Backend for Spring Boot and Microservices includes a Grafana dashboard for HashiCorp Vault.\nVault Grafana Dashboard ","description":"Oracle Backend as a Service for Spring Cloud and Microservices includes HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets, and other sensitive data using a user interface (UI), command-line interface (CLI), or Hypertext Transfer Protocol (HTTP) API.\nTip For more information about working with the HashiCorp Vault, see the HashiCorp Vault Documentation and Tutorials Library. Setup Information Accessing the root Token Production Mode Accessing the root Token Development Mode Accessing Vault Recovery Keys Production Mode Accessing Vault Using kubectl Accessing the Vault Using the Web User Interface Audit Logs Grafana dashboard for HashiCorp Vault Setup Information The Vault can be deployed in two different ways."},{"id":15,"href":"/microservices-datadriven/spring/infrastructure/","title":"Infrastructure","parent":"Oracle Backend for Spring Boot and Microservices","content":" Infrastructure Architecture Considerations The following points are considered when designing the infrastructure:\nPerformance The ability to scale both vertically on all tiers and horizontally on the web tier. Resources should be able automatically scale vertically based unpredictable, changing workloads.\nSecurity The database should not be accessible directly from the internet. Data should be encrypted at rest and, when traversing networks, in motion. The Kubernetes control plane and worker nodes should not be accessible directly from the internet.\nA Bastion Service should be use for directly accessing the Database and Kubernetes when required.\nAvailability Remove a single point of failure by introducing redundancy via Availability and Fault Domains and native ADB solutions.\nExtensibility and Flexibility Designed to seamlessly cater for the addition or removal of resources, capabilities and/or functionality.\nComponents The infrastructure has the following components:\nRegion An Oracle Cloud Infrastructure region is a localized geographic area that contains one or more data centres, called availability domains.\nAvailability domains Availability domains are stand-alone, independent data centres within a region. The physical resources in each availability domain are isolated from the resources in the other availability domains, which provides fault tolerance.\nFault domains A fault domain is a grouping of hardware and infrastructure within an availability domain. Each availability domain has three fault domains with independent power and hardware. Applications can tolerate physical server failure, system maintenance, and power failures inside a fault domain.\nVirtual cloud network (VCN), Public and Private Subnets A VCN is a customizable, software-defined network. Like traditional data centre networks, VCNs give complete control over the network environment. A VCN can have multiple non-overlapping CIDR blocks which can be segmented into subnets. A subnet can be public or private.\nService gateway The service gateway provides access from a VCN to other services, such as Oracle Cloud Infrastructure Object Storage. The traffic from the VCN to the Oracle service travels over the Oracle network fabric and never traverses the internet.\nSecurity List/Network Security Group (NSG) For each subnet, Security Lists and/or Network Security Groups are used to specify the source, destination, and type of traffic that must be allowed in and out of the subnet.\nLoad Balancer The Oracle Cloud Infrastructure Load Balancing service provides automated traffic distribution from a single entry point to one or multiple servers in the back end.\nBastion Services The Bastion as a Service provides restricted and time-limited secure access to the ORDS Server(s) and the Autonomous Data Warehouse. These resources do not have public endpoints and require strict resource access controls.\nAutonomous Transaction Processing Database (ATP) By default, Autonomous Databases are highly available, incorporating a multi-node configuration to protect against localized hardware failures that do not require fast disaster recovery.\nContainer Engine for Kubernetes Oracle Cloud Infrastructure Container Engine for Kubernetes is a fully managed, scalable, and highly available service that you can use to deploy your containerized applications to the cloud. You specify the compute resources that your applications require, and Container Engine for Kubernetes provisions them on Oracle Cloud Infrastructure in an existing tenancy. Container Engine for Kubernetes uses Kubernetes to automate the deployment, scaling, and management of containerized applications across clusters of hosts.\nControl Plane Services \u0026amp; Pods The Control Plane manages the worker nodes and the Pods in the Kubernetes cluster. The worker nodes run the containerized applications. Every cluster has at least one worker node. The worker node(s) host the Pods that are the components of the application workload.\nObject Storage Object Storage offers reliable and cost-efficient data durability, it provides quick access to large amounts of structured and unstructured data of any content type, including database data, analytic data, images, videos and more. We recommend using standard storage to ingest data from external sources because applications and users can access it quickly. You can build a lifecycle policy to move the data from standard storage to archive storage when it’s no longer required to be accessed frequently.\nRegistry Oracle Cloud Infrastructure Registry is an Oracle-managed registry that enables you to simplify your development-to-production workflow. Registry makes it easy for you to store, share, and manage development artifacts, like Docker images. The highly available and scalable architecture of Oracle Cloud Infrastructure ensures that you can deploy and manage your applications reliably.\nRecommendations Requirements might differ or change from the architecture proposed. Use the following recommendations as a starting point to adjusting the architecture; changes may impact pricing:\nDedicated Networking (Chargeable) Access to/from an On-Premise data centre will require additional networking configuration including but not limited to FastConnect and Dynamic Routing Gateways.\nSecurity Zones (Free) For resources that require maximum security, Oracle recommends to use security zones. A security zone is a compartment associated with an Oracle-defined recipe of security policies that are based on best practices. For example, the resources in a security zone must not be accessible from the public internet and they must be encrypted using customer-managed keys. When creating or updating resources in a security zone, OCI validates the operations against the policies in the security-zone recipe, and denies operations that violate any of the policies.\nWeb Application Firewall (Chargeable) Web Application Firewall (WAF) protects applications from malicious and unwanted internet traffic. WAF can protect any internet facing endpoint, providing consistent rule enforcement across a customer\u0026rsquo;s applications. WAF provides the ability to create and manage rules for internet threats including Cross-Site Scripting (XSS), SQL Injection and other OWASP-defined vulnerabilities. Unwanted bots can be mitigated while tactically allowed desirable bots to enter. Access rules can limit based on geography or the signature of the request.\nATP CPU Auto-Scaling (Chargeable) It is recommend to leave auto-scaling enabled; this will allow the increase and decrease of the databases CPU and I/O resources. Use Apache JMeter to load test functional behavior and measure the performance.\nAutonomous Data Guard (Chargeable) Autonomous Data Guard monitors the primary database and if the Autonomous Database instance goes down, then the standby instance assumes the role of the primary instance adding additional fault tolerance.\nData Catalog (Chargeable) OCI Data Catalog is a fully managed, self-service data discovery and governance solution for your enterprise data. Data Catalog provides a single collaborative environment to manage technical, business, and operational metadata\n","description":"Infrastructure Architecture Considerations The following points are considered when designing the infrastructure:\nPerformance The ability to scale both vertically on all tiers and horizontally on the web tier. Resources should be able automatically scale vertically based unpredictable, changing workloads.\nSecurity The database should not be accessible directly from the internet. Data should be encrypted at rest and, when traversing networks, in motion. The Kubernetes control plane and worker nodes should not be accessible directly from the internet."},{"id":16,"href":"/microservices-datadriven/spring/infrastructure/kubernetes/","title":"Kubernetes Access","parent":"Infrastructure","content":"The Oracle Backend for Spring Boot and Microservices requires a Kubernetes cluster where the components are deployed. You can bring your own cluster or, in OCI, have a Oracle Kubernetes Engine (OKE) deployed for you.\nOKE Access At the end of setup, you are provided with a command in the log of the apply job to create a Kubernetes configuration file to access that cluster:\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the Oracle Cloud Infrastructure documentation. kubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; NOTE: The generated kubeconfig file works if you are using the DEFAULT profile in your Oracle Cloud Infrastructure (OCI) CLI configuration file. If you are using a different OCI CLI profile, you must add --profile \u0026lt;PROFILE-NAME\u0026gt; to the command. For example:\nkubeconfig_cmd = \u0026#34;oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT\u0026#34; --profile \u0026lt;PROFILE-NAME\u0026gt; You must also edit the the generated Kubernetes configuration file and add the following lines:\n- name: user-xxxx user: exec: apiVersion: client.authentication.k8s.io/v1beta1 args: - ce - cluster - generate-token - --cluster-id - ocid1.cluster....xxxx - --region - us-ashburn-1 - --profile - \u0026lt;PROFILE-NAME\u0026gt; command: oci Using OCI Cloud Shell A simple alternative is to use the OCI Cloud Shell, which is provided in the OCI Console. You can open the OCI Cloud Shell by clicking Developer Tools in the upper right corner of the OCI Console. For example:\nOCI Cloud Shell icon Run the provided command to create your Kubernetes configuration file after which you can access the Kubernetes cluster. For example, you can list the Pods in your cluster:\nWelcome to Oracle Cloud Shell. Update: Cloud Shell will now use Oracle JDK 11 by default. To change this, see Managing Language Runtimes in the Cloud Shell documentation. Your Cloud Shell machine comes with 5GB of storage for your home directory. Your Cloud Shell (machine and home directory) are located in: US East (Ashburn). You are using Cloud Shell in tenancy xxxx as an OCI user xxxx Type `help` for more info. user@cloudshell:~ (us-ashburn-1)$ oci ce cluster create-kubeconfig --cluster-id ocid1.cluster.oc1.iad.xxx --file $HOME/.kube/config --region us-ashburn-1 --token-version 2.0.0 --kube-endpoint PUBLIC_ENDPOINT Existing Kubeconfig file found at /home/user/.kube/config and new config merged into it user@cloudshell:~ (us-ashburn-1)$ kubectl get pods -A NAMESPACE NAME READY STATUS RESTARTS AGE ingress-nginx ingress-nginx-controller-7d45557d5c-bqwwp 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-klgnb 1/1 Running 0 4h18m ingress-nginx ingress-nginx-controller-7d45557d5c-l4d2m 1/1 Running 0 4h18m kube-system coredns-746957c9c6-hwnm8 1/1 Running 0 4h27m kube-system csi-oci-node-kqf5x 1/1 Running 0 4h23m kube-system kube-dns-autoscaler-6f789cfb88-7mptd 1/1 Running 0 4h27m kube-system kube-flannel-ds-hb6ld 1/1 Running 1 (4h22m ago) 4h23m kube-system kube-proxy-v5qwm 1/1 Running 0 4h23m kube-system proxymux-client-vpnh7 1/1 Running 0 4h23m ......... user@cloudshell:~ (us-ashburn-1)$ Manually Scaling OKE To add additional nodes to the OKE cluster, the Marketplace installation stack can be re-applied after increasing the number of worker nodes.\nNOTE: If changes to the infrastructure were made outside the stack, re-applying the stack may revert those changes back to their original values. It is important to PLAN and review the proposed changes before running APPLY. This will ensure there are no unintentional modifications to the infrastructure.\nIn the OCI Console, navigate to Developer Services -\u0026gt; Resource Manager -\u0026gt; Stacks Ensure the compartment is set to where the Marketplace Stack was deployed, and Select the stack. Edit the Stack and Click Next Increase the Node Pool Workers Click Next and Save Changes Run Plan Carefully review the proposed changes Run Apply after reviewing the proposed changes ","description":"The Oracle Backend for Spring Boot and Microservices requires a Kubernetes cluster where the components are deployed. You can bring your own cluster or, in OCI, have a Oracle Kubernetes Engine (OKE) deployed for you.\nOKE Access At the end of setup, you are provided with a command in the log of the apply job to create a Kubernetes configuration file to access that cluster:\nTip For more information about working with the Kubernetes cluster, see Setting Up Cluster Access in the Oracle Cloud Infrastructure documentation."},{"id":17,"href":"/microservices-datadriven/spring/observability/metrics/","title":"Metrics","parent":"Observability","content":"Oracle Backend for Spring Boot and Microservices provides built-in platform services to collect metrics from system and application workloads and pre-built Grafana dashboards to view and explore those metrics.\nOn this page, you will find the following topics:\nOverview Pre-installed dashboards Spring Boot Observability Spring Boot Statistics Oracle Database Dashboard Kube State Metrics Dashboard Apache APISIX DashBoard HashiCorp Vault Dashboard How to have metrics collected for your applications How to access Prometheus How to access Grafana Overview Oracle Backend for Spring Boot and Microservices includes a number of pre-installed and pre-configured components to provide metrics for the platform itself and for your applications.\nThe diagram below provides an overview of the components that play a role in metrics:\nObservability Overview In the diagram above:\nYou may deploy applications into the platform and to have metrics collected these must either register with the Spring Eureka Service Registry or you must create Service Monitor resources for your applications. Prometheus is configured to auto-discover services that register with the service registry and collect metrics for them. Prometheus is configured to collect metrics from application described by a Service Monitor. The Oracle Database Exporter and Kube State Metrics are pre-installed and Prometheus is configured to collect metrics from them. Grafana is pre-installed and populated with a set of dashboards (see below). A Prometheus data source is pre-configured. Pre-installed dashboards The following dashboards are pre-installed in Grafana:\nSpring Boot Observability This dashboard provides details of one or more Spring Boot applications including the following:\nThe number of HTTP requests received by the application A breakdown of which URL paths requests were received for The average duration of requests by path The number of exceptions encountered by the application Details of 2xx (that is, successful) and 5xx (that is, exceptions) requests The request rate per second over time, by path Log messages from the service You may adjust the time period and to drill down into issues, and search the logs for particular messages. This dashboard is designed for Spring Boot 3.x applications. Some features may work for Spring Boot 2.x applications.\nHere is an example of this dashboard displaying data for a simple application:\nSpring Boot Observability Dashboard Spring Boot Statistics This dashboard provides more in-depth information about services including the following:\nJVM statistic like heap and non-heap memory usage, and details of garbage collection Load average and open files Database connection pool statistics (for HikariCP) HTTP request statistics Logging (logback) statistics You may adjust the time period and to drill down into issues, and search the logs for particular messages. This dashboard is designed for Spring Boot 3.x applications. Some features may work for Spring Boot 2.x applications.\nHere is an example of this dashboard displaying data for a simple application:\nSpring Boot Statistics Dashboard Oracle Database Dashboard This dashboard provides details about the Oracle Database including:\nSGA and PGA size Active sessions User commits Execute count CPU count and platform Top SQL Wait time statistics by class Here is an example of this dashboard:\nOracle Database Dashboard Kube State Metrics Dashboard This dashboard provides details of the Kubernetes cluster including:\nPod capacity and requests for CPU and memory Node availability Deployment, Stateful Set, Pod, Job and Container statistics Details of horizontal pod autoscalers Details of persistent volume claims Here is an example of this dashboard:\nKube State Metrics Dashboard Apache APISIX Dashboard This dashboard provides details of the APISIX API Gateway including:\nTotal Requests NGINX Connection State Etcd modifications Here is an example of this dashboard:\nApache APISIX Observability Dashboard HashiCorp Vault Dashboard This dashboard provides details of the HashiCorp Vault including:\nHealth and seal status Number of secrets Number of operations Here is an example of this dashboard:\nApache APISIX Observability Dashboard How to have metrics collected for your applications When you deploy an application with Oracle Backend for Spring Boot and Microservices CLI or Visual Code Extension, provided you included the Eureka Discovery Client and Actuator in your application, Prometheus will automatically find your application (using the service registry) and start collecting metrics. These metrics will be included in both the Spring Boot Observability dashboard and the Spring Boot Statistic dashboard automatically.\nTo include the Eureka Discovery client in your application, add the following dependencies to your Maven POM or equivalent:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; You must also add the following configuration to your Spring application.yaml:\nspring: application: name: my-app eureka: instance: hostname: ${spring.application.name} preferIpAddress: true client: service-url: defaultZone: ${eureka.service-url} fetch-registry: true register-with-eureka: true enabled: true management: endpoint: health: show-details: always endpoints: web: exposure: include: \u0026#34;*\u0026#34; metrics: tags: application: ${spring.application.name} Alternatively, if you do not want to include the Eureka client, you can instead create a ServiceMonitor resource for your service. This must be created in the namespace where your application is deployed, and you must specify the correct port and the path for Spring Boot Actuator. Your application must have Actuator and the prometheus endpoint enabled, as described above.\nHere is an example of a ServiceMonitor for an application:\napiVersion: monitoring.coreos.com/v1 kind: ServiceMonitor metadata: labels: app: my-app name: my-app namespace: application spec: endpoints: - interval: 20s path: /actuator/prometheus port: 8080 selector: matchLabels: app: my-app How to access Prometheus Prometheus is an open source monitoring and alerting system. Prometheus collects and stores metrics as time series data with the timestamp of the time that they are recorded, and optional Key/Value pairs called labels.\nExpose the Prometheus user interface (UI) using this command:\nkubectl port-forward -n prometheus svc/prometheus 9090:9090 Open the Prometheus web user interface URL: http://localhost:9090\nPrometheus UI In the Prometheus web user interface, search for metrics:\nIn the search bar, search for application_ready_time_seconds and click on Execute. You should see metrics for the Sample Applications. For example:\nPrometheus Metrics In the Prometheus web user interface, Status allows you to view the targets being monitored by Prometheus:\nIn the top menu, choose Status and then Targets. Notice that the targets \u0026ldquo;slow\u0026rdquo;, \u0026ldquo;customer\u0026rdquo; and others are in UP status and others are in DOWN status. Prometheus Targets How to access Grafana Grafana open source software enables you to query, visualize, alert, and explore your metrics, logs, and traces wherever they are stored. Grafana open source software provides tools that turn your time series database (TSDB) data into insightful graphs and visualizations. Take the following steps:\nExpose Grafana using this command:\nkubectl -n grafana port-forward svc/grafana 8080:80 Open the Grafana web user interface URL: http://localhost:8080\nusername: admin\nTo get the password, run this command:\nkubectl -n grafana get secret grafana-dashboard-authn -o jsonpath=\u0026#39;{.data.password}\u0026#39; | base64 -d; echo NOTE: If you do not have base64, leave off the last part (| base64 -d) in the command, then copy the output, and use this website to decode it: https://www.base64decode.org/.\nIf you did not set your own password during installation, then the auto-generated password will be a long string of characters that might be similar to 210BAqNzYkrcWjd58RKC2Xzerx9c0WkZi9LNsG4c. For example:\nGrafana Login ","description":"Oracle Backend for Spring Boot and Microservices provides built-in platform services to collect metrics from system and application workloads and pre-built Grafana dashboards to view and explore those metrics.\nOn this page, you will find the following topics:\nOverview Pre-installed dashboards Spring Boot Observability Spring Boot Statistics Oracle Database Dashboard Kube State Metrics Dashboard Apache APISIX DashBoard HashiCorp Vault Dashboard How to have metrics collected for your applications How to access Prometheus How to access Grafana Overview Oracle Backend for Spring Boot and Microservices includes a number of pre-installed and pre-configured components to provide metrics for the platform itself and for your applications."},{"id":18,"href":"/microservices-datadriven/spring/platform/microtx/","title":"MicroTx","parent":"Platform Services","content":"Oracle Transaction Manager for Microservices, also known as \u0026ldquo;MicroTx\u0026rdquo;, simplifies application development and operations by enabling distributed transactions to ensure consistency across microservices deployed in Kubernetes.\nOracle Backend for Spring Boot and Microservices includes the free version of MicroTx, which has all of the functionality of the commercial version, but limits the number of transactions and only persists data in memory. It is recommended for evaluations and application development purposes.\nMicroTx supports the following consistency models:\nExtended Architecture (XA) Long Running Actions (LRA) Try-Confirm/Cancel (TCC) The CloudBank sample application includes a \u0026ldquo;Transfer\u0026rdquo; service which demonstrates how to use MicroTx to implement the Saga pattern using the Eclipse Microprofile Long Running Actions specification.\nTo use MicroTx in your Spring Boot applications, include the following dependency in your pom.xml or equivalent:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.microtx.lra\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;microtx-lra-spring-boot-starter-3x\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Add the following configuration to your Spring application configuration. The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI or the Visual Studio Code Extension to deploy your application. For example:\nspring: microtx: lra: coordinator-url: ${MP_LRA_COORDINATOR_URL} propagation-active: true headers-propagation-prefix: \u0026#34;{x-b3-, oracle-tmm-, authorization, refresh-}\u0026#34; lra: coordinator: url: ${MP_LRA_COORDINATOR_URL} Upgrading to the commercial version If you have licensed Oracle Transaction Manager for Microservices Enterprise Edition, please see the documentation for details of how to install and configure MicroTx. Oracle recommends that you perform a new installation rather than attempting to upgrade the provided MicroTx Free installation to the commercial version.\n","description":"Oracle Transaction Manager for Microservices, also known as \u0026ldquo;MicroTx\u0026rdquo;, simplifies application development and operations by enabling distributed transactions to ensure consistency across microservices deployed in Kubernetes.\nOracle Backend for Spring Boot and Microservices includes the free version of MicroTx, which has all of the functionality of the commercial version, but limits the number of transactions and only persists data in memory. It is recommended for evaluations and application development purposes."},{"id":19,"href":"/microservices-datadriven/spring/infrastructure/networking/","title":"Networking","parent":"Infrastructure","content":"The Oracle Backend for Spring Boot and Microservices has specific networking requirements to ensure resource communication while providing security through isolation and networking rules.\nThe standard installation will provision a new Virtual Cloud Network (VCN) with the required subnets and all networking rules to get you started using the Oracle Backend for Spring Boot and Microservices quickly. To use an existing VCN, please follow the Bring Your Own VCN instructions.\nFor custom installations, including On-Premises, it is the responsibility of the customer to ensure network access controls to provide both operational access and security. The Oracle Cloud Infrastructure (OCI) standard installation setup can be used as a general template.\nNetwork Infrastructure Overview OCI Network Infrastructure All infrastructure resources are split between two subnets: one public and one private subnet with access restricted by Network Security Groups (Firewalls). All access is blocked by default with specific IP and port opened, as documented below, for proper operation.\nNote minimum CIDRs are based on an Oracle Cloud Infrastructure (OCI) deployments. Other cloud vendors reserve usable IPs within a CIDR reducing the usable IPs that can be used by the infrastructure.\nPublic Subnet The public subnet allows external access to the Oracle Backend for Spring Boot and Microservices resources. Ingress/Egress to the public subnet and from the Internet is provided by an Internet Gateway.\nAt a minimum, the public subnet requires two usable IP Addresses. In OCI this equates to a 30-bit network identifier (/30).\nICMP traffic is allowed between the public and private Subnets for resource discovery.\nNOTE: Resources within the public subnet are not inherently accessible from the internet. The public subnet allows the resources in it to obtain a public IP address, however assigning a public IP is not required. When a public IP is not assigned to the resource, it is only accessible from within the subnet itself. All access to resources in the public subnet are restricted by configurable Network Security Groups (Firewalls).\nLoad Balancer An external Load Balancer is used in conjunction with Ingress resources to expose Services to the internet. Ingress to the Load Balancer should be restricted by CIDR and ports (default: 0.0.0.0/0; 80,443). All TLS communications terminate at the LoadBalancer. For more information on the certificate for TLS, please see OCI Load Balancer TLS Certificate Setup.\nKubernetes API Endpoint The Kubernetes API Endpoint, within the Control Plane, is used to manage the Kubernetes Cluster as well as providing access to Kubernetes services that are not exposed to the Load Balancer via Port Forwarding. Ingress to the Endpoint is restricted to port 6443 and should be further restricted by CIDR (default: 0.0.0.0/0).\nIn Oracle Cloud Infrastructure (OCI), the Oracle Kubernetes Engine (OKE) Control Plane is allowed egress to OCI services via port 443. Access to these services are required for the OKE Managed Control Plane.\nPrivate Subnet The private subnet isolates its resources from direct external access by prohibiting the allocation of public IP address to those resources. Ingress to resources in the private subnet is restricted to the Load Balancer and Kubernetes API Endpoint via specific Network Security Group (Firewall) rules. Optionally, a Bastion Service, within the Private subnet, can provide additional non-restricted access to the resources in the private subnet.\nEgress to the Internet is provided by a NAT Gateway, while Egress to other Cloud Services (such as a Container Repository) is provided by a Service Gateway.\nThe CIDR of the Private Subnet is dependent on the number of Kubernetes Work Nodes and other resources, such as databases. It is recommended to specify a CIDR providing at least six usable IP Addresses. In OCI, this equates to a 29-bit network identifier (/29).\nICMP traffic is allowed between the public and private subnets for resource discovery.\nKubernetes Worker Nodes The worker nodes are allowed to communicate with other worker nodes on all ports.\nWorker Nodes and Load Balancer The Worker Nodes and Load Balancer are allowed to communicate on port 10256 for Health Check/Availability purposes and ports 30000-32767 for forwarding external internet access to exposed services.\nWorker Nodes and Kubernetes API Endpoint Worker Nodes are allowed to communicate with the API Endpoint on port 6443.\nWorker Nodes and Control Plane The Kubernetes Control Plane is allowed to communicate to Worker Nodes on all ports. The Worker Nodes are allowed to communicate with the Control Plane on port 12250.\nOracle Database It is recommended to place the Oracle Databases inside the Private Subnet. Worker Nodes and the Oracle Database will be allowed to communicate freely within the Private Subnet.\nWhen using the Oracle Autonomous Database (ADB), it can either be placed in the Private Subnet with a Private Endpoint, or outside the Virtual Cloud Network with Secured Access. When the ADB is configured for Secured Access, access is allowed from the Virtual Cloud Network and additional, configurable IPs.\nBring Your Own OCI VCN Using the Standard Edition you can use a pre-created VCN for the Oracle Backend for Spring Boot and Microservices resources.\nThe following are minimum requirements for a BYO VCN:\nPublic Subnet Minimum CIDR: /30 Route Table: Internet Gateway to 0.0.0.0/0 Private Subnet Minimum CIDR: /29 Route Table: Service Gateway to \u0026ldquo;All \u0026lt;Region\u0026gt; Services in the Oracle Services Network\u0026rdquo; NAT Gateway to 0.0.0.0/0 Configuration During the configuration of the Oracle Backend for Spring Boot and Microservices, ensure that the Edition is set to Standard:\nTick the \u0026ldquo;Bring Your Own Virtual Network\u0026rdquo; checkbox and fill in the appropriate values for the VCN Compartment/Name, Public Subnet Compartment/Name, and Private Subnet Compartment/Name:\nVirtual Cloud Network Compartment : The compartment of the existing VCN. Virtual Cloud Network (VCN) : The VCN name. Private Subnet Compartment : The compartment of the existing Private Subnet in the VCN. Private Subnet : The Private Subnet name (this will automatically translate the name to an OCID). Public Subnet Compartment : The compartment of the existing Public Subnet in the VCN. Public Subnet : The Public Subnet name (this will automatically translate the name to an OCID). OCI LoadBalancer TLS Certificate Setup In OCI, example self-signed certificates are used for TLS communication to the Load Balancer. The self-signed certificates should be replaced with certificates signed by a publicly trusted certificate authority (CA).\nSetup Ensure your Domain Name System (DNS) entry points to the public IP address associated with the service/ingress-nginx-controller in the ingress-nginx namespace:\nObtain a new TLS certificate. In a production environment, the most common scenario is to use a public certificate that has been signed by a certificate authority.\nCreate a new Kubernetes secret in the ingress-nginx namespace. For example:\nkubectl -n ingress-nginx create secret tls my-tls-cert --key new-tls.key --cert new-tls.crt Modify the service definition to reference the new Kubernetes secret by changing the service.beta.kubernetes.io/oci-load-balancer-tls-secret annotation in the service configuration. For example:\nkubectl patch service ingress-nginx-controller -n ingress-nginx \\ -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;annotations\u0026#34;:{\u0026#34;service.beta.kubernetes.io/oci-load-balancer-tls-secret\u0026#34;:\u0026#34;my-tls-cert\u0026#34;}}}\u0026#39; \\ --type=merge ","description":"The Oracle Backend for Spring Boot and Microservices has specific networking requirements to ensure resource communication while providing security through isolation and networking rules.\nThe standard installation will provision a new Virtual Cloud Network (VCN) with the required subnets and all networking rules to get you started using the Oracle Backend for Spring Boot and Microservices quickly. To use an existing VCN, please follow the Bring Your Own VCN instructions."},{"id":20,"href":"/microservices-datadriven/spring/development/cli/","title":"OBaaS CLI","parent":"Development","content":"The Oracle Backend for Spring Boot and Microservices offers a command-line interface (CLI), oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources that they use. Download the CLI here. The platform-specific binary can be renamed to oractl for convenience.\nTable of Contents:\nInstalling the CLI Using the CLI Available Commands Help Connect to the backend Create application namespace Delete application namespace Bind database schema/kubernetes secrets Deploy a service Create a horizontal pod autoscaler Delete a horizontal pod autoscaler List - show details about deployments Manage config server data GraalVM compile commands User Management Logging Information Installing the CLI The Oracle Backend for Spring Boot CLI is used to configure your backend and to deploy your Spring Boot applications to the backend.\nDownload the Oracle Backend for Spring Boot and Microservices CLI oractl\nDownload the CLI from here\nRename the downloaded file to oractl\nAdd oractl to PATH variable\nYou need to make sure it is executable and add it to your PATH environment variable.\n\u0026lt;copy\u0026gt; chmod +x oractl export PATH=/path/to/oractl:$PATH\u0026lt;/copy\u0026gt; NOTE: If environment is a Mac you need run the following command sudo xattr -r -d com.apple.quarantine \u0026lt;downloaded-file\u0026gt; otherwise will you get a security warning and the CLI will not work.\nUsing the CLI Expose the Oracle Backend for Spring Boot and Microservices Admin server that the CLI calls using this command:\nkubectl port-forward services/obaas-admin -n obaas-admin 8080 Start the CLI in interactive mode by running oractl from your terminal window. For example:\noractl As a result, the oractl prompt is displayed as follows:\n_ _ __ _ ___ / \\ |_) _. _. (_ / | | \\_/ |_) (_| (_| __) \\_ |_ _|_ ======================================================================================== Application Name: Oracle Backend Platform :: Command Line Interface Application Version: (1.1.3) :: Spring Boot (v3.2.1) :: Ask for help: - Slack: https://oracledevs.slack.com/archives/C03ALDSV272 - email: obaas_ww@oracle.com oractl:\u0026gt; Available Commands help Short descriptions for the available commands can be viewed by issuing the help command and detailed help for any individual commands can be viewed by issuing help [command-name]. For example:\noractl:\u0026gt;help AVAILABLE COMMANDS Application/Namespace Commands create: Create an application/namespace. Autoscaler Commands create-autoscaler: Create an autoscaler. delete-autoscaler: Delete an autoscaler. Built-In Commands help: Display help about available commands stacktrace: Display the full stacktrace of the last error. clear: Clear the shell screen. quit, exit: Exit the shell. history: Display or save the history of previously run commands version: Show version info script: Read and execute commands from a file. GraalVM Compile Commands compile-download: Download executable file compiled compile: Compile a service with GraalVM compile-purge: Delete a job launched compile-logs: Compilation progress Identity and Access Management Service user list: Lists the users in your platform. user create: Creates a new user in your platform. user get: Gets the specified user’s information. user delete: Delete a user in your platform. user change-roles: Change the roles from the specified user. connect: Connect to the OBaaS Admin Service. user change-password: Change password for the specified user. Informational Commands list: list/show details of application services. Service Commands bind: Create or Update a schema/user and bind it to service deployment. delete: Delete a service or entire application/namespace. config: View and modify Service configuration. deploy: Deploy a service. Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com An application is a namespace encompassing related microservices. For example, a \u0026ldquo;cloudbank\u0026rdquo; application may have \u0026ldquo;banktransfer\u0026rdquo; and \u0026ldquo;frauddetection\u0026rdquo; microservices deployed within it.\nThe create command results in the creation of an application namespace (Kubernetes namespace). The application namespace provides a mechanism for isolating groups of resources, especially the microservices.\nThe delete command results in the complete deletion of an application namespace (Kubernetes namespace) or for a specific microservice. Ensure that you want to completely delete the application namespace. You cannot rollback the components once deleted.\nThe bind command results in the automatic creation of a database schema for a given service or user and binds the information for that schema or database in the environment of the microservice. The option of a prefix for the bound environment properties is also returned. For example, most Spring Boot microservices use spring.datasource.\nThe deploy command takes service-name, app-name, and artifact-path as the main arguments (image-version and java-version options are also provided). When the deploy command is issued, the microservice JAR file is uploaded to the backend and a container image is created for the JAR or microservice, and various Kubernetes resources such as Deployment and Service are also created. This is all done automatically to simplify the development process and the management of the microservices by the backend.\nThe create-autoscaler and delete-autoscaler commands allow you to create and delete horizontal pod autoscalers for specific microservices.\nThe list command shows the details of the deployed microservices.\nThe config command can also be used to add, view, update, and delete configurations managed by the Spring Cloud Config server.\nA common development workflow pattern is to connect, change-password (only if necessary), create (once per application or namespace), config, bind (only if necessary), deploy, and list.\nFurther development and redeployment of the service can then be repeated issuing the deploy and list commands.\nThe following is a description of the CLI commands:\nconnect Use the connect command to connect your oractl CLI to the Oracle Backend Administration service:\noractl:\u0026gt;help connect NAME connect - Connect to the OBaaS Spring Cloud admin console. SYNOPSIS connect --url String --help OPTIONS --url String admin server URL [Optional, default = http://localhost:8080] --help or -h help for connect [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;connect ? username obaas-admin ? password **************** Credentials successfully authenticated! obaas-admin -\u0026gt; welcome to OBaaS CLI. create Use the create command to create an application namespace (Kubernetes namespace). The application namespace provides a mechanism for isolating groups of resources, especially the microservices. Names of resources need to be unique within an application namespace, but not across application namespaces.\noractl:\u0026gt;help create NAME create - Create an application/namespace. SYNOPSIS create --app-name String --help OPTIONS --app-name String application/namespace [Optional] --help or -h help for create [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;create --app-name myapp application/namespace created successfully and image pull secret (registry-auth) created successfully and database TNSAdmin/wallet secret created successfully delete Use the delete command to delete an application namespace (Kubernetes namespace) completely or a specific microservice inside an application namespace.\nATTENTION: Ensure that you want to completely delete the application namespace. You cannot rollback the components once deleted.\nNAME delete - Delete a service or entire application/namespace. SYNOPSIS delete --app-name String --service-name String --image-version String --help OPTIONS --app-name String application/namespace [Optional] --service-name String Service Name [Optional] --image-version String Image Version [Optional] --help or -h help for delete [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;delete --app-name myapp obaas-cli [delete]: The Application/Namespace [myapp] will be removed, including all Services deployed. Do you confirm the complete deletion (y/n)?: y obaas-cli [delete]: Application/Namespace [myapp] as successfully deleted bind Use the bind command to create and update a database schema or user for the service. These commands also create or update the Kubernetes secret and binding environment entries for the schema. These are set in the Kubernetes deployment created with the deploy command. For example:\noractl:\u0026gt;help bind NAME bind - Create or Update a schema/user and bind it to service deployment. SYNOPSIS bind --action CommandConstants.BindActions --app-name String --service-name String --username String --binding-prefix String --help OPTIONS --action CommandConstants.BindActions possible actions: create or update. create is default. [Optional, default = create] --app-name String application/namespace [Optional, default = application] --service-name String Service Name (Default for database user if username is not provided) [Optional] --username String Database User [Optional] --binding-prefix String spring binding prefix [Optional, default = spring.datasource] --help or -h help for bind [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com ATTENTION: The service-name is mandatory and used as the name for the schema or user to be created. If you want to use a different schema or user from the service-name, you must also submit the username.\nUse the bind or bind create command to create a database schema or user for the service. For Example:\noractl:\u0026gt;bind create --app-name myapp --service-name myserv Database/Service Password: ************ Schema {myserv} was successfully created and Kubernetes Secret {myapp/myserv} was successfully created. Use the bind update command to update an already created database schema or user for the service. For example:\noractl:\u0026gt;bind update --app-name myapp --service-name myserv Database/Service Password: ************ Schema {myserv} was successfully updated and Kubernetes Secret {myapp/myserv} was successfully updated. deploy Use the deploy command to create, build, and push an image for the microservice and create the necessary deployment, service, and secret Kubernetes resources for the microservice.\noractl:\u0026gt;help deploy NAME deploy - Deploy a service. SYNOPSIS deploy --bind String --app-name String [--service-name String] [--image-version String] --service-profile String --port String --java-version String --add-health-probe boolean --liquibase-db String [--artifact-path String] --initial-replicas int --graalvm-native boolean --apigw boolean --route String --apikey String --help OPTIONS --bind String automatically create and bind resources. possible values are [jms] [Optional] --app-name String application/namespace [Optional, default = application] --service-name String Service Name [Mandatory] --image-version String Image Version [Mandatory] --service-profile String Service Profile [Optional] --port String Service Port [Optional, default = 8080] --java-version String Java Base Image [ghcr.io/graalvm/jdk:ol9-java17-22.3.1] [Optional] --add-health-probe boolean Inject or not Health probes to service. [Optional, default = false] --liquibase-db String Inform the database name for Liquibase. [Optional] --artifact-path String Service jar/exe location [Mandatory] --initial-replicas int The initial number of replicas [Optional, default = 1] --graalvm-native boolean Artifact is a graalvm native compiled by Oracle Backend [Optional, default = false] --apigw boolean open routing through APISIX [Optional, default = false] --route String set an APISIX route path [Optional, default = /api/v1/] --apikey String set APISIX API_KEY [Optional] --help or -h help for deploy [Optional] CURRENTLY UNAVAILABLE you are not signedIn. Please sign in to be able to use this command! Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;deploy --app-name myapp --service-name myserv --image-version 0.0.1 --port 8081 --bind jms --add-health-probe true --artifact-path obaas/myserv/target/demo-0.0.1-SNAPSHOT.jar uploading: obaas/myserv/target/demo-0.0.1-SNAPSHOT.jar building and pushing image... binding resources... successful creating deployment and service... successfully deployed or, for native compiled microservices, add \u0026ndash;java-version container-registry.oracle.com/os/oraclelinux:7-slim to have a compact image and \u0026ndash;graalvm-native to specify the file provided is an executable .exec:\noractl:\u0026gt;deploy --app-name myapp --service-name account --artifact-path obaas/myserv/target/accounts-0.0.1-SNAPSHOT.jar.exec --image-version 0.0.1 --graalvm-native --java-version container-registry.oracle.com/os/oraclelinux:7-slim create-autoscaler Use the create-autoscaler command to create a horizontal pod autoscaler for a microservice you have deployed. You can specify the target scaling threshold using CPU percentage. Note that your microservice must have its CPU request set in order to use the autoscaler. It is set to 500m (that is, half a core) by the deploy command if you did not override the default.\noractl:\u0026gt;help create-autoscaler NAME create-autoscaler - Create an autoscaler. SYNOPSIS create-autoscaler --app-name String [--service-name String] --min-replicas int --max-replicas int --cpu-request String --cpu-percent int --help OPTIONS --app-name String application/namespace [Optional, default = application] --service-name String Service Name [Mandatory] --min-replicas int The minimium number of replicas [Optional, default = 1] --max-replicas int The maximum number of replicas [Optional, default = 4] --cpu-request String The amount of CPU to request [Optional, default = 100m] --cpu-percent int The CPU percent at which to scale [Optional, default = 80] --help or -h help for create-autoscaler [Optional] CURRENTLY UNAVAILABLE you are not signedIn. Please sign in to be able to use this command! Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;create-autoscaler --app-name application --service-name creditscore --cpu-percent 80 --cpu-request 200m --min-replicas 2 --max-replicas 6 obaas-cli [create-autoscaler]: Autoscaler was successfully created. You can view the details of the autoscaler using kubectl, for example:\n$ kubectl -n application get hpa NAME REFERENCE TARGETS MINPODS MAXPODS REPLICAS AGE creditscore Deployment/creditscore 0%/80% 2 6 2 26s customer Deployment/customer 4%/80% 2 6 2 26h delete-autoscaler Use the delete-autoscaler command to delete a horizontal pod autoscaler for a microservice you have deployed.\noractl:\u0026gt;help delete-autoscaler NAME delete-autoscaler - Delete an autoscaler. SYNOPSIS delete-autoscaler --app-name String [--service-name String] --help OPTIONS --app-name String application/namespace [Optional, default = application] --service-name String Service Name [Mandatory] --help or -h help for delete-autoscaler [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;delete-autoscaler --app-name application --service-name creditscore obaas-cli [delete-autoscaler]: Autoscaler was successfully deleted. list Use the list command to show details of the microservice deployed in the previous step. For example:\noractl:\u0026gt;help list NAME list - list/show details of application services. SYNOPSIS list --app-name String --help OPTIONS --app-name String application/namespace [Optional, default = application] --help or -h help for list [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example:\noractl:\u0026gt;list --app-name myapp name:myserv-c46688645-r6lhl status:class V1ContainerStatus { containerID: cri-o://6d10194c5058a8cf7ecbd5e745cebd5e44c5768c7df73053fa85f54af4b352b2 image: \u0026lt;region\u0026gt;.ocir.io/\u0026lt;tenancy\u0026gt;/obaas03/myapp-myserv:0.0.1 imageID: \u0026lt;region\u0026gt;.ocir.io/\u0026lt;tenancy\u0026gt;/obaas03/myapp-myserv@sha256:99d4bbe42ceef97497105218594ea19a9e9869c75f48bdfdc1a2f2aec33b503c lastState: class V1ContainerState { running: null terminated: null waiting: null } name: myserv ready: true restartCount: 0 started: true state: class V1ContainerState { running: class V1ContainerStateRunning { startedAt: 2023-04-13T01:00:51Z } terminated: null waiting: null } }name:myserv kind:null config Use the config command to view and update the configuration managed by the Spring Cloud Config server. More information about the configuration server can be found at this link: Spring Config Server\noractl:\u0026gt;help config NAME config - View and modify Service configuration. SYNOPSIS config [--action CommandConstants.ConfigActions] --service-name String --service-label String --service-profile String --property-key String --property-value String --artifact-path String --help OPTIONS --action CommandConstants.ConfigActions possible actions: add, list, update, or delete [Mandatory] --service-name String Service Name [Optional] --service-label String label for config [Optional] --service-profile String Service Profile [Optional] --property-key String the property key for the config [Optional] --property-value String the value for the config [Optional] --artifact-path String the context [Optional] --help or -h help for config [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com Use the config add command to add the application configuration to the Spring Cloud Config server using one of the two following options:\nAdd a specific configuration using the set of parameters --service-name, --service-label, --service-profile, --property-key, and --property-value. For example: oractl:\u0026gt;config add --service-name myserv --service-label 0.0.1 --service-profile default --property-key k1 --property-value value1 Property added successfully. Add a set of configurations based on a configuration file using these commands: { \u0026#34;application\u0026#34;: \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;spring.datasource.driver-class-name\u0026#34;: \u0026#34;oracle.jdbc.OracleDriver\u0026#34;, \u0026#34;spring.datasource.url\u0026#34;: \u0026#34;jdbc:oracle:thin:@$(db.service)?TNS_ADMIN=/oracle/tnsadmin\u0026#34; } } oractl:\u0026gt;config add --artifact-path /obaas/myserv-properties.json 2 property(s) added successfully. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.0.1 [ { \u0026#34;id\u0026#34; : 222, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;spring.datasource.driver-class-name\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;oracle.jdbc.OracleDriver\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:29:38.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; }, { \u0026#34;id\u0026#34; : 223, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;spring.datasource.url\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;jdbc:oracle:thin:@$(db.service)?TNS_ADMIN=/oracle/tnsadmin\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:29:38.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] Use the config list command, without any parameters, to list the services that have at least one configuration inserted in the Spring Cloud Config server. For example:\noractl:\u0026gt;config list [ { \u0026#34;name\u0026#34; : \u0026#34;apptest\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;\u0026#34; }, { \u0026#34;name\u0026#34; : \u0026#34;myapp\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;\u0026#34; }, […] Use the config list [parameters] command to list the parameters using parameters as filters. For example:\n--service-name : Lists all of the parameters from the specified service. --service-label : Filters by label. --service-profile : Filters by profile. --property-key : Lists a specific parameter filter by key. For example:\noractl:\u0026gt;config list --service-name myserv --service-profile default --service-label 0.0.1 [ { \u0026#34;id\u0026#34; : 221, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;default\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:10:16.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] Use the config update command to update a specific configuration using the set of parameters:\n--service-name --service-label --service-profile --property-key --property-value For example:\noractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 [ { \u0026#34;id\u0026#34; : 30, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-03-23T18:02:29.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] oractl:\u0026gt;config update --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 --property-value value1Updated Property successful modified. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key k1 [ { \u0026#34;id\u0026#34; : 30, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;k1\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value1Updated\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-03-23T18:02:29.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] Use the config delete command to delete the application configuration from the Spring Cloud Config server using one of the following two options:\nDelete all configurations from a specific service using the filters --service-name, --service-profile and --service-label. The CLI tracks how many configurations are present in the Spring Cloud Config server and confirms the completed deletion. For example:\noractl:\u0026gt;config delete --service-name myserv [obaas] 7 property(ies) found, delete all (y/n)?: Delete a specific configuration using the parameters --service-name, --service-label, --service-profile and --property-key. For example:\noractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 [ { \u0026#34;id\u0026#34; : 224, \u0026#34;application\u0026#34; : \u0026#34;myserv\u0026#34;, \u0026#34;profile\u0026#34; : \u0026#34;obaas\u0026#34;, \u0026#34;label\u0026#34; : \u0026#34;0.1\u0026#34;, \u0026#34;propKey\u0026#34; : \u0026#34;ktest2\u0026#34;, \u0026#34;value\u0026#34; : \u0026#34;value2\u0026#34;, \u0026#34;createdOn\u0026#34; : \u0026#34;2023-04-13T01:52:11.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34; : \u0026#34;CONFIGSERVER\u0026#34; } ] oractl:\u0026gt;config delete --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 [obaas] property successfully deleted. oractl:\u0026gt;config list --service-name myserv --service-profile obaas --service-label 0.1 --property-key ktest2 400 : \u0026#34;Couldn\u0026#39;t find any property for submitted query.\u0026#34; compile Use the GraalVM Compile Commands to:\nUpload a .jar file to the Oracle Backend for Spring Boot and microservices and its GraalVM compiler service. Start a compilation of your microservice to produce an executable native .exec file. Retrieve the last logs available regarding a compilation in progress or terminated. Download the .exec file to deploy on the backend. Purge the files remaining after a compilation on the remote GraalVM compiler service. The GraalVM Compile Commands are the following:\noractl:\u0026gt;help GraalVM Compile Commands compile-download: Download the compiled executable file. compile: Compile a service with GraalVM. compile-purge: Delete a launched job. compile-logs: Compilation progress. Use the compile command to upload and automatically start compilation using the following command:\noractl:\u0026gt;help compile NAME compile - Compile a service with GraalVM SYNOPSIS compile [--artifact-path String] --help OPTIONS --artifact-path String Service jar to compile location [Mandatory] --help or -h help for compile [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com Because the compilation of a .jar file using the tool native-image does not support cross-compilation, it must be on the same platform where the application will run. This service guarantees a compilation in the same operating system and CPU type where the service will be executed on the Kubernetes cluster.\nThe Spring Boot application pom.xml with the plugin:\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.graalvm.buildtools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;native-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; The project should be compiled on the developer desktop with GraalVM version 22.3 or later using an mvn command. For example:\nmvn -Pnative native:compile -Dmaven.test.skip=true This pre-compilation on your desktop checks if there are any issues on the libraries used in your Spring Boot microservice. In addition, your executable .jar file must include ahead-of-time (AOT) generated assets such as generated classes and JSON hint files. For additional information, see Converting Spring Boot Executable Jar.\nThe following is an example of the command output:\noractl:\u0026gt;compile --artifact-path /Users/cdebari/demo-0.0.1-SNAPSHOT.jar uploading: /Users/cdebari/demo-0.0.1-SNAPSHOT.jar filename: demo-0.0.1-SNAPSHOT.jar return: demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b return: Shell script execution started on: demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b successfully start compilation of: demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b oractl:\u0026gt; The following example shows the generated batch ID that must be used to retrieve the log files, download the compiled file, and purge the service instance:\ndemo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b\nIf omitted, then the last batch is considered by default.\nUse the compile-logs command to retrieve the logs that show the compilation progress. For example:\noractl:\u0026gt;help compile-logs NAME compile-logs - Compilation progress. SYNOPSIS compile-logs --batch String --help OPTIONS --batch String File ID returned from the compile command. If not provided by default, then the last file compiled. [Optional] --help or -h help for compile-logs [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com As previously mentioned, if the batch ID is not provided, then the logs of the most recently executed compilation are returned. For example:\noractl:\u0026gt;compile-logs extracted: BOOT-INF/lib/spring-jcl-6.0.11.jar extracted: BOOT-INF/lib/spring-boot-jarmode-layertools-3.1.2.jar inflated: BOOT-INF/classpath.idx inflated: BOOT-INF/layers.idx ======================================================================================================================== GraalVM Native Image: Generating \u0026#39;demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b.exec\u0026#39; (executable)... ======================================================================================================================== For detailed information and explanations on the build output, visit: https://github.com/oracle/graal/blob/master/docs/reference-manual/native-image/BuildOutput.md ------------------------------------------------------------------------------------------------------------------------ If the compile-logs commands returns a Finished generating message, then download the .exec file. For example:\nCPU: Enable more CPU features with \u0026#39;-march=native\u0026#39; for improved performance. QBM: Use the quick build mode (\u0026#39;-Ob\u0026#39;) to speed up builds during development. ------------------------------------------------------------------------------------------------------------------------ 155.3s (8.2% of total time) in 169 GCs | Peak RSS: 5.34GB | CPU load: 0.70 ------------------------------------------------------------------------------------------------------------------------ Produced artifacts: /uploads/demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b.temp/demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b.exec (executable) ======================================================================================================================== Finished generating \u0026#39;demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b.exec\u0026#39; in 31m 30s. Compiling Complete. Use the compile-download command to download the generated .exec file. For example:\noractl:\u0026gt;help compile-download NAME compile-download - Download the compiled executable file. SYNOPSIS compile-download --batch String --help OPTIONS --batch String File ID to download as the executable file. If not provided by default, then the last file compiled. [Optional] --help or -h help for compile-download [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com You can choose to use the batch ID if you need the last file compiled. The following example specifies the batch ID:\noractl:\u0026gt;compile-download --batch demo-0.0.1-SNAPSHOT.jar_24428206-7d71-423f-8ef5-7d779977535b File downloaded successfully to: /Users/cdebari/demo-0.0.1-SNAPSHOT.jar.exec Use the compile-purge command to delete all of the artifacts generated on the GraalVM compiler service after downloading the .exec file:\noractl:\u0026gt;help compile-purge NAME compile-purge - Delete a launched job. SYNOPSIS compile-purge --batch String --help OPTIONS --batch String File ID returned from compile command. If not provided by default, then the last file compiled. [Optional] --help or -h help for compile-purge [Optional] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com User Management Manage users allows you to create the platform users and assign the roles that give access permission to operate with the platform.\nUser Roles\nROLE_USER: Users with this role can:\nConnect to the Admin Service. Create and list applications (namespaces). Create and update a database schema for the service. Deploy, list, and scale workloads (services). ROLE_ADMIN: Users with this role have the same access rights as a ROLE_USER and additionally:\nCreate and delete users. Search for users. Change password and roles for users. ROLE_CONFIG_EDITOR: Users with this role are allowed to edit the platform configurations. Reserved for future use.\nCreate users Use the user create command to add users to the platform. This command requires the name of the user username and the user roles in a comma-separated list.\noractl:\u0026gt;help user create NAME user create - Creates a new user in your platform. SYNOPSIS user create [--username String] --roles String --help OPTIONS --username String The name you assign to the user during creation. This is the user\u0026#39;s login for the CLI and for the SOC UI, also. The name must be unique across all users in the platform and cannot be changed. [Mandatory] --roles String The user\u0026#39;s role within the platform. A user must have up to three possible roles provided in a comma-separated list. [ROLE_ADMIN,ROLE_CONFIG_EDITOR,ROLE_USER]. [Optional, default = ROLE_USER] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to create a user called obaas-user-test1 with roles ROLE_USER,ROLE_CONFIG_EDITOR:\noractl:\u0026gt;user create --username obaas-user-test1 --roles ROLE_USER,ROLE_CONFIG_EDITOR ? password **************** obaas-cli [user create]: User [obaas-user-test1] as successfully created. Obtain User details Use the user get command to obtain the user details registered on the platform.\noractl:\u0026gt;help user get NAME user get - Gets the specified user’s information. SYNOPSIS user get [--username String] --help OPTIONS --username String The username of the user. [Mandatory] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to list the details from the user called obaas-admin:\noractl:\u0026gt;user get --username obaas-admin ╔══╤═══════════╤═══════════════════════════════════════╗ ║Id│Username │Roles ║ ╠══╪═══════════╪═══════════════════════════════════════╣ ║2 │obaas-admin│ROLE_ADMIN,ROLE_CONFIG_EDITOR,ROLE_USER║ ╚══╧═══════════╧═══════════════════════════════════════╝ Change User Roles Use the user change-roles command to change the roles from a specific user registered on the platform.\noractl:\u0026gt;help user change-roles NAME user change-roles - Change the roles from the specified user. SYNOPSIS user change-roles [--username String] --roles String --help OPTIONS --username String The name you assign to the user during creation. This is the user’s login for the CLI. [Mandatory] --roles String The user\u0026#39;s role within the platform. A user must have up to three possible roles provided in a comma-separated list. [ROLE_ADMIN,ROLE_CONFIG_EDITOR,ROLE_USER]. [Optional, default = ROLE_USER] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to change the roles from a user called obaas-user-test1 apply the role ROLE_USER:\noractl:\u0026gt;user change-roles --username obaas-user-test1 --roles ROLE_USER obaas-cli [user change-roles]: User [obaas-user-test1] roles were successfully updated. Change User Password Use the user change-password command to change the password from a specific user registered on the platform. A user is allowed to change its password only. Only users with ROLE_ADMIN can change passwords from other users.\noractl:\u0026gt;help user change-password NAME user change-password - Change password for the specified user. SYNOPSIS user change-password [--username String] --help OPTIONS --username String The username you want to change the password. [Mandatory] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to change the password from a user called obaas-user-test1:\noractl:\u0026gt;user change-password --username obaas-user-test1 ? password *********** obaas-cli [user change-password]: User [obaas-user-test1] password was successfully updated. List Users Use the user list command to obtain the list of users registered on the platform.\noractl:\u0026gt;help user list NAME user list - Lists the users in your platform. SYNOPSIS user list --help Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to list all registered users:\noractl:\u0026gt;user list ╔══╤════════════════╤═══════════════════════════════════════╗ ║Id│Username │Roles ║ ╠══╪════════════════╪═══════════════════════════════════════╣ ║1 │obaas-user │ROLE_USER ║ ╟──┼────────────────┼───────────────────────────────────────╢ ║2 │obaas-admin │ROLE_ADMIN,ROLE_CONFIG_EDITOR,ROLE_USER║ ╟──┼────────────────┼───────────────────────────────────────╢ ║3 │obaas-config │ROLE_CONFIG_EDITOR,ROLE_USER ║ ╟──┼────────────────┼───────────────────────────────────────╢ ║4 │obaas-user-test1│ROLE_USER ║ ╚══╧════════════════╧═══════════════════════════════════════╝ Delete User Use the user delete command to remove users from the platform.\nNOTE: User deletion is permanent and irreversible.\noractl:\u0026gt;help user delete NAME user delete - Delete a user in your platform. SYNOPSIS user delete [--username String] --id int --help OPTIONS --username String The username you want to delete. [Mandatory] --id int The user id from the user you want to delete. [Optional, default = 0] Ask for Help Slack: https://oracledevs.slack.com/archives/C03ALDSV272 E-mail: obaas_ww@oracle.com For example, to delete a user called obaas-user-test1:\noractl:\u0026gt;user delete --username obaas-user-test1 obaas-cli [user delete]: User [obaas-user-test1] as successfully deleted. Logging The log file for oractl on Mac or Unix machine is stored in the $HOME/config/orctl directory. The file name is oractl-cli-history.log\n","description":"The Oracle Backend for Spring Boot and Microservices offers a command-line interface (CLI), oractl. The CLI commands simplify the deployment of microservices applications as well as bindings with the resources that they use. Download the CLI here. The platform-specific binary can be renamed to oractl for convenience.\nTable of Contents:\nInstalling the CLI Using the CLI Available Commands Help Connect to the backend Create application namespace Delete application namespace Bind database schema/kubernetes secrets Deploy a service Create a horizontal pod autoscaler Delete a horizontal pod autoscaler List - show details about deployments Manage config server data GraalVM compile commands User Management Logging Information Installing the CLI The Oracle Backend for Spring Boot CLI is used to configure your backend and to deploy your Spring Boot applications to the backend."},{"id":21,"href":"/microservices-datadriven/spring/observability/","title":"Observability","parent":"Oracle Backend for Spring Boot and Microservices","content":"Oracle Backend for Spring Boot and Microservices includes a number of common open source components to provide application observability including Prometheus, Grafana, Jaeger, and OpenTelemetry Collector.\nFor more details, read the following:\nMetrics Tracing ","description":"Oracle Backend for Spring Boot and Microservices includes a number of common open source components to provide application observability including Prometheus, Grafana, Jaeger, and OpenTelemetry Collector.\nFor more details, read the following:\nMetrics Tracing "},{"id":22,"href":"/microservices-datadriven/spring/","title":"Oracle Backend for Spring Boot and Microservices","parent":"","content":"Oracle Backend for Spring Boot and Microservices allows developers to build microservices in Spring Boot and provisions a \u0026ldquo;backend as a service\u0026rdquo; with Oracle Database and other infrastructure components that operate on multiple clouds. Oracle Backend for Spring Boot and Microservices vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nVersion 1.2.0 (production) released June, 2024 Oracle Backend for Spring Boot and Microservices Version 1.2.0 is now generally available and suitable for production use. This version supports and recommends Spring Boot 3.2.x, Spring 6.1 and Spring Cloud 2023.0.x, with limited backwards compatibility for Spring Boot 2.7.x. To learn more, watch this short introductory video:\nIn addition to an Oracle Autonomous Database Serverless instance, the following software components are deployed in an Oracle Cloud Infrastructure (OCI) Container Engine for Kubernetes cluster (OKE cluster):\nApache APISIX API Gateway and Dashboard Apache Kafka Grafana HashiCorp Vault Jaeger Apache Kafka Loki Netflix Conductor OpenTelemetry Collector Oracle Autonomous Database Serverless Oracle Backend for Spring Boot Command Line Interface (CLI) Oracle Backend for Spring Boot Visual Studio Code Plugin Oracle Coherence Oracle Database Operator for Kubernetes (OraOperator or the operator) Oracle Database Observability Exporter Oracle Transaction Manager for Microservices (MicroTx) Prometheus Promtail Spring Boot Admin dashboard Spring Cloud Config server Spring Cloud Eureka service registry Spring Operations Center Strimzi Kafka Operator Developers also have access to development or build time services and libraries including:\nA command-line interface (CLI) to manage service deployment and configuration, including database schema management. Visual Studio Code (VS Code) plugin to manage service deployment and configuration. Spring CLI support for project creation. Spring Data (Java Persistence API (JPA) and Oracle JDBC) to access Oracle Database. Oracle Java Database Connectivity (Oracle JDBC) drivers. Spring Cloud Config client. Spring Eureka service discovery client. Spring Cloud OpenFeign. OpenTelemetry Collector (including automatic instrumentation). Spring Starters for Oracle Universal Connection Pool (UCP), Oracle Wallet, Oracle Advanced Queuing (AQ), and Transactional Event Queues (TxEventQ). Learn more, try it out with CloudBank! To learn more about deploying and using Oracle Backend for Spring Boot and Microservices, we recommend our CloudBank self-paced, on-demand hands-on lab.\nIn the CloudBank hands-on lab, you can learn how to:\nInstall Oracle Backend for Spring Boot and Microservices. Set up a development environment for Spring Boot. Build Spring Boot microservices from scratch using Spring Web to create Representational State Transfer (REST) services. Use service discovery and client-side load balancing. Use Spring Actuator to allow monitoring of services. Create services that use asynchronous messaging with Java Message Service (JMS) instead of REST. Implement the Saga pattern to manage data consistency across microservices. Use the APISIX API Gateway to expose services to clients. Extend a provided Flutter client to add a new \u0026ldquo;cloud cash\u0026rdquo; feature that uses the services you have built. Need help? We\u0026rsquo;d love to hear from you! You can contact us in the #oracle-db-microservices channel in the Oracle Developers slack workspace, or open an issue in GitHub.\n","description":"Oracle Backend for Spring Boot and Microservices allows developers to build microservices in Spring Boot and provisions a \u0026ldquo;backend as a service\u0026rdquo; with Oracle Database and other infrastructure components that operate on multiple clouds. Oracle Backend for Spring Boot and Microservices vastly simplifies the task of building, testing, and operating microservices platforms for reliable, secure, and scalable enterprise applications.\nVersion 1.2.0 (production) released June, 2024 Oracle Backend for Spring Boot and Microservices Version 1."},{"id":23,"href":"/microservices-datadriven/spring/platform/vscode-plugin/","title":"Oracle Backend for Spring Boot and Microservices Visual Studio Code Extension","parent":"Platform Services","content":" GA 1.1.3 - March, 2024 \u0026ldquo;Oracle Backend for Spring Boot and Microservices\u0026rdquo; is a VS Code extension to browse and deploy applications on the Oracle Backend for Spring Boot and Microservices platform. This plugin allows to inspect the content of an Oracle Backend for Spring Boot deployment, in terms of applications, services and related configurations. It simplifies the access to the Platform Services installed, like Grafana, Spring, Apisix, Eureka and Jaeger creating ssh tunnels on-demand, and providing access to their respective web admin consoles. It allows to add credentials to access and bind services to the Oracle Autonomous DB included into Oracle Backend for Spring Boot and Microservices deployment. This plug-in replicates the functionalities available in OBaas CLI and simplify the access to Oracle Backend for Spring Boot and Microservices deployments from a development IDE like VS Code.\nSee the Oracle Free Use Terms and Conditions License\nPrerequisites You must have already installed and configured the following software which required for the Oracle Backend for Spring Boot and Microservices Setup:\nKubernetes command-line interface (kubectl) Oracle Cloud Infrastructure command-line interface OpenJDK Runtime Environment GraalVM 22.3 or above (optional). Installation Download the plug-in from here.\nOn the VS Code left menu bar, click on the Extensions symbol:\nFrom the upper right menu, select Install from VSIX\u0026hellip; and upload the plugin binaries that were previously downloaded:\nRestart VS Code to make the plugin fully operational.\nIf you do not see the plugin in the left menu bar, with the Oracle logo (as shown here), click on Additional Views to select the Oracle Backend for Spring Boot and Microservices:\nUsing VS Code Plugin After selecting the plugin from the left menu bar, the Oracle Backend for Spring Boot and Microservices VS Code plugin asks you to specify the full path for the Kubernetes configuration file. For example:\nBy default, it shows the path in the user\u0026rsquo;s Home directory .kube/config in which kubectl stores all of the information regarding the configured K8s clusters. You can set the full path of another Kubernetes configuration file. If the file is correctly loaded, the plugin shows the list of contexts available from which you can select one:\nIf successful, you should see a tree view with one node and the selected context. For example:\nIf the file path has not been correctly set, it returns an error message. For example:\nTo restart the plugin and proceed with setting the Kubernetes configuration file, execute a window reload in the command palette:\nHow to Access the Cluster Until you create a dedicated ssh tunnel to the Kubernetes cluster, and if you do not connect to Oracle Backend for Spring Boot and Microservices administrative services, you cannot browse resources included in the Oracle Backend for Spring Boot and Microservices deployment. To do this, follow these steps:\nSelect the cluster and right-click, choosing Set UID/PWD menu item to insert credentials related to your user account. For example:\nSpecify the OBSBM Admin ID for the Oracle Backend for Spring Boot and Microservices user for deployment. For example:\nOn the top menu, the Oracle Backend for Spring Boot and Microservices administrator OBSBM Admin password is required. For example:\nTwo dialog boxes confirm that the credentials have been set correctly. For example:\nNOTE: If you do not process these steps and try to expand the Kubernetes context, you receive this informational message:\nSelect the cluster again and right-click on Create Admin tunnel. VS Code opens two new terminal that tries to open two tunnels to the Kubernetes cluster on a local port, for the KubeProxy on port 7080 and to Backend starting from 8080. For example:\nBefore proceeding to the connection, wait until the tunnel are established and the terminals show a message similar to this:\nNOTE: If the K8s cluster is not related to an Oracle Backend for Spring Boot and Microservices deployment, the tunnel creation fails, because it will look for the services/obaas-admin in the namespace obaas-admin. In this case, execute a window reload to chose another cluster from the command palette. If you have any problem with the connection, start another tunnel. The plugin tries to connect to the cluster on another local port.\nSelect the cluster again and right-click Connect. This creates a session with the credentials set up in the first step.\nExplore Resources When the steps to create the tunnel are completed and you are connected to the backend, it is possible to expand and Refresh the tree related to the deployment. For example:\nYou see four top classes of resources that can be expanded in underlying items:\napplications : The list of applications deployed and the holding services. Oracle DB : In this release there is one Oracle Database in which the configurations and schemas related to deployed services are stored. platformServices : The list of Oracle Backend for Spring Boot and Microservices deployed services, like Grafana, Spring, Apache APISIX, Eureka and Jaeger. oBaasConf : The list of keys defined by the applications, stored in the Oracle Database, that are provisioned and available to share configurations information among services in each application. Applications Let\u0026rsquo;s look at the operations that you can do on Applications root item of the browse tree:\nOpen the list by clicking on the arrow to the left of applications:\nExpand the application you are interested to see the list of included services:\nApplications level commands At the root level, right-click on applications, you have the following list of commands available right-clicking on the line:\nAdd application Compilation progress Compile .jar in .exec Download compiled file in .exec Purge compilation files Add application With this option you can create a Kubernetes namespace will hold single Spring Boot microservice. It will be prompted the name of the application:\nWith this operation will be injected in the namespace a set of Secrets needed to run the microservices will be deployed.\nCompilation progress If it has been started a compilation with the command Compile .jar in .exec, you will see the tail of logs collected during the jar file compilation with GraalVM, in a single windows pane. You can re-submit the command to see the progress, as shown here:\nIf the compilation process is over successfully, you will see something like this:\nCompile .jar in .exec This option allows you to upload a .jar file to the Oracle Backend for Spring Boot and Microservices to a GraalVM compiler service. This service will start a compilation of your microservice in a native file, that it will be executed without JVM support. Since the compilation of a .jar file via the tool native-image does not support cross-compilation, so it must be on the same kind of platform where the application will run, this service guarantees a compilation in the same Operating System and CPU type where the service it will be executed on the Kubernetes cluster. The Spring Boot application pom.xml with the plugin:\n\u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.graalvm.buildtools\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;native-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;/plugin\u0026gt; it should be previously compiled on the developer desktop with GraalVM 22.3 or above through an mvn command like:\nmvn -Pnative native:compile -Dmaven.test.skip=true\nThis pre-compilation on your desktop needs not only to check if there are any issues on libraries used in your Spring Boot microservice but also, as you can read here, your executable jar file must include AOT generated assets such as generated classes and JSON hint files.\nAs soon as you upload the .jar file, the process will start showing these messages:\nDownload compiled file in .exec If the compilation progress report a \u0026ldquo;Finished generating \u0026lsquo;\u0026hellip;\u0026rdquo; message, you can download locally the .exec file to be used to deploy a new microservice under an application namespace. It will be only required to choose a directory in which to save the file.\nNOTE: if you\u0026rsquo;ll ask to download a file before the compilation is over, you will have a message like this:\nPurge compilation files After you have compiled and downloaded the executable file, it\u0026rsquo;s a good practice to purge files created on the compilation service before proceeding to other compilations. This command will delete the files related to the latest compilation.\nApplication level commands Expanding a single application, in which you are interested to see the list of included services, you will see a tree like in this picture:\nTo show the updated list, click on the Refresh button to the right of application.\nRight-clicking on each application, you can:\nAdd native service -\u0026gt; upload .exec Add service -\u0026gt; upload .jar Bind a service Delete application as shown here:\nAdd native service -\u0026gt; upload .exec The VS Code command palette prompts for the required parameters to upload an executable file coming from a compilation done with the service offered by Oracle Backend for Spring Boot and Microservices. At the end of compilation process, you can download the .exec file and use it to create a native executable Spring Boot microservices on the backend platform. Choosing this item menu, the parameters will be required are:\nA popup dialog box opens to select the local Spring Boot .exec file, that will be the only type that you can select:\nService Name\nBind [jms] (Default: ``)\nService Port (Default: 8080)\nService Profile (Default: obaas)\nImage Version (Default: 0.0.1)\nInitial Replicas (Default: 1)\nAdd Health probe? : [True]/[False] (Default: True)\nAt the end of the parameters collection, a process, that includes the .exec file upload, building image and deploying, starts. It generates a sequence of messages showing the status. These messages end with \u0026ldquo;Service deployed successfully!\u0026rdquo; or \u0026ldquo;Deploy failed\u0026rdquo;. The size and network constraints determine the amount of time for the process to terminate.\nAdd service -\u0026gt; upload .jar The Add -\u0026gt; upload .jar command uploads a Spring Boot Microservice to an application packaged as a .jar file. Choosing this item menu, selecting a single application, the parameters will be required are:\nA popup dialog box opens to select the local Spring Boot .jar file\nService Name\nBind [jms] (Default: ``)\nImage Version (Default: 0.0.1)\nJava image (Default: ghcr.io/graalvm/jdk:ol7-java17-22.2.0)\nAdd Health probe? : [True]/[False] (Default: True)\nService Port (Default: 8080)\nService Profile (Default: obaas)\nInitial Replicas (Default: 1)\nInform the database name for Liquibase: username for Liquibase.\nAt the end of the parameters collection, a process, that includes the .jar upload, building image and deploying, starts. It generates a sequence of messages showing the status. These messages end with \u0026ldquo;Service deployed successfully!\u0026rdquo; or \u0026ldquo;Deploy failed\u0026rdquo;. The size and network constraints determine the amount of time for the process to terminate.\nBind a service This command create/update a user on the Oracle DB according the service name typed, or optionally to a different user schema, to which bind a Spring Boot microservice that will store data into the DB. It also store secrets with the user credentials into the application namespace, in order to inject them into the related pods. If the schema exists, it impose to change the user password will be stored in the namespace. The parameters required are:\nService Name: DB User (optional): DB User Password: Spring Binding Prefix (optional): (Default: spring.datasource) Update? [True]/[False] (Default: True) Delete Application This command removes the application and all the services included. At the end of process, you see one of two messages: \u0026ldquo;Delete successful\u0026rdquo; or \u0026ldquo;Delete application failed!\u0026rdquo;. Refresh the tree at applications level to show the current application list. The termination of Pods and applications isn\u0026rsquo;t a synchronous operation. You may have to refresh more than one time for a clean view.\nService level commands With a right click on a single service you will have the following commands:\nCreate autoscaler Delete autoscaler Delete service Publish service as shown here:\nCreate autoscaler Create a Kubernetes autoscaler for the selected pod.\nminReplicas (Default: 1) maxReplicas (Default: 1) cpuPercent (Default: ``) cpuRequest (Default: 100m) Delete autoscaler Delete an existing autoscaler\nDelete service Selecting the service from the tree, under a specific application, you will remove the service deployment, and the active pods will be removed.\nPublish service This command creates a route in the APISix Gateway available in the Oracle Backend for Spring Boot and Microservices, in order to expose on Internet the selected service. To be performed, this command requires the APISix AdminKey, and a port-forward to the APISix engine.\nYou can get the AdminKey from the APISix configmap, using a kubectl command:\nkubectl -n apisix get configmap apisix -o yaml\nlooking for the -name: \u0026quot;admin\u0026quot; key.\nThe parameters you have to provide are:\nAPISix AdminKey: Url base path: (Default: /api/v1/). This path will be automatically appended by the service name to create the route accessible from an url like: http(s)://[LB_IP]/api/v1/[servicename]* A successful operation will return the Route ID recorded into the APISix, as shown in this example:\nThis is a shortcut with a standard registration: to customize the route, or start from scratch, is suggested the usage of APISix console.\nOracle DB For each Oracle Backend for Spring Boot and Microservices, an Oracle Autonomous Transaction Processing database is provisioned on OCI to hold the schema for the Spring Boot services and backend\u0026rsquo;s configuration details. The icon remembers the component deployed with the backend platform.\nplatformServices The platformServices option can be expanded to show the services available in the Oracle Backend for Spring Boot and Microservices platform. For each service, right-click on the symbol to open an ssh tunnel to the service, on a specific local port that is automatically chosen. A link opens in the default web browser for the administrator console of each platform service.\nFor example, by right-clicking on grafana monitor, a tunnel will be opened with a message holding a button to open a web browser on the administrator\u0026rsquo;s Grafana console. For example:\nThe apisix console shows one more command compared with the others, that allows you to open a tunnel to the engine, that is listening on a different port than the console. This enable the Publish service command available on each service.\nNOTE: If the port is already used or the connection times out, right clicking again it will automatically open on another port.\noBaasConf Configuration With Oracle Backend for Spring Boot and Microservices, developers can store the metadata and configurations to share among Pods in an application. The VS Code plugin can browse the content of this Key/Values store and add, update and delete keys as needed.\nExpand oBaasConf configuration to see the applications that are deployed and, expanding each of them, the Key/Value pair. For example:\nHover the mouse over each Key/Value pair to see the other metadata related to the key: profile and label, as shown here:\nYou can process the following operations:\nAdd key : By right-clicking oBaasConf configuration or one of the service-conf options in the VS Code command palette, you will set the following key parameters:\nservice name (mandatory) label profile propKey value Click on Refresh button to see the new key added.\nNOTE: You can add configuration properties for a service that is not yet deployed. In some cases, it is mandatory to prepare properties before deploying services in order to correctly start them.\nEdit key : Right-click on a selected key in the VS Code command palette to update the current content of Value.\nDelete key : Right-click on a selected key to delete it.\n","description":"GA 1.1.3 - March, 2024 \u0026ldquo;Oracle Backend for Spring Boot and Microservices\u0026rdquo; is a VS Code extension to browse and deploy applications on the Oracle Backend for Spring Boot and Microservices platform. This plugin allows to inspect the content of an Oracle Backend for Spring Boot deployment, in terms of applications, services and related configurations. It simplifies the access to the Platform Services installed, like Grafana, Spring, Apisix, Eureka and Jaeger creating ssh tunnels on-demand, and providing access to their respective web admin consoles."},{"id":24,"href":"/microservices-datadriven/spring/starters/aqjms/","title":"Oracle Spring Boot Starter for AQ/JMS","parent":"Oracle Spring Boot Starters","content":"This starter provides support for Oracle Transactional Event Queues (TxEventQ) and Oracle Advanced Queuing (AQ) as Java Message Service (JMS) providers. It depends on the Universal Connection Pool (UCP) starter.\nNote: By default, the data Source and JMS Connection Factory that the starter injects into your application share the same database transaction. This means that you can start a transaction, read from a queue, perform an update operation, and then commit or rollback that whole unit of work, including the message consumption.\nTo add this starter to your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-aqjms\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; For Gradle projects, add this dependency:\nimplementation \u0026#39;com.oracle.database.spring:oracle-spring-boot-starter-aqjms:23.4.0\u0026#39; To configure your application to use Oracle Transactional Event Queues or Oracle Advanced Queuing, you must annotate you application with the @EnableJms annotation, and create the two following beans:\nA JmsListenerContainerFactory\u0026lt;?\u0026gt; bean, which can be created as shown in the following example. Note that you can override settings if you need to. Also, note that the name of the method defines the name of the factory, which you will use when creating JMS listeners. A MessageConverter bean to map objects of your class representing the payload into a text based format (like JSON) that can be used in the actual messages. Note: Any queues or topics that you want to use must be pre-created in the database. See Sample Code for examples.\npackage com.example.aqjms; import jakarta.jms.ConnectionFactory; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.boot.autoconfigure.jms.DefaultJmsListenerContainerFactoryConfigurer; import org.springframework.context.ConfigurableApplicationContext; import org.springframework.context.annotation.Bean; import org.springframework.jms.annotation.EnableJms; import org.springframework.jms.config.DefaultJmsListenerContainerFactory; import org.springframework.jms.config.JmsListenerContainerFactory; import org.springframework.jms.core.JmsTemplate; import org.springframework.jms.support.converter.MappingJackson2MessageConverter; import org.springframework.jms.support.converter.MessageConverter; import org.springframework.jms.support.converter.MessageType; @SpringBootApplication @EnableJms public class JmsSampleApplication { @Bean public JmsListenerContainerFactory\u0026lt;?\u0026gt; myFactory(ConnectionFactory connectionFactory, DefaultJmsListenerContainerFactoryConfigurer configurer) { DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); // This provides all Boot\u0026#39;s defaults to this factory, including the message converter configurer.configure(factory, connectionFactory); // You could override some of Boot\u0026#39;s defaults here if necessary return factory; } @Bean public MessageConverter jacksonJmsMessageConverter() { MappingJackson2MessageConverter converter = new MappingJackson2MessageConverter(); converter.setTargetType(MessageType.TEXT); converter.setTypeIdPropertyName(\u0026#34;_type\u0026#34;); return converter; } public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(JmsSampleApplication.class, args); } } To send a message to a JMS queue or topic, get an instance of the JmsTemplate from the Spring Application context, and call the convertAndSend() method specifying the name of the queue or topic, and providing the object to be converted and sent in the payload of the message, as shown in the following example:\nJmsTemplate jmsTemplate = context.getBean(JmsTemplate.class); jmsTemplate.convertAndSend(\u0026#34;mailbox\u0026#34;, new Email(-1, \u0026#34;info@example.com\u0026#34;, \u0026#34;Hello\u0026#34;)); To receive messages from a JMS queue or topic, create a method that takes your message class, for example Email, as input. Annotate the method with the @JmsListener annotation, specifying the destination, that is the name of the queue or topic, and the container factory name that you created earlier, as shown in the following example:\npackage com.example.aqjms; import org.springframework.jms.annotation.JmsListener; import org.springframework.stereotype.Component; @Component public class Receiver { @JmsListener(destination = \u0026#34;mailbox\u0026#34;, containerFactory = \u0026#34;myFactory\u0026#34;) public void receiveMessage(Email email) { System.out.println(\u0026#34;Received \u0026lt;\u0026#34; + email + \u0026#34;\u0026gt;\u0026#34;); } } Note that the starter uses the configuration for spring.datasource as the connection details for the Oracle Database hosting the queues and topics. If you wish to use a different configuration, you must use a named configuration, for example spring.datasource.txeventq and use Java configuration (as shown for the UCP starter) and annotate the configuration with the standard Spring @Qualifier annotation, specifying the correct name, for example txevevntq.\n","description":"This starter provides support for Oracle Transactional Event Queues (TxEventQ) and Oracle Advanced Queuing (AQ) as Java Message Service (JMS) providers. It depends on the Universal Connection Pool (UCP) starter.\nNote: By default, the data Source and JMS Connection Factory that the starter injects into your application share the same database transaction. This means that you can start a transaction, read from a queue, perform an update operation, and then commit or rollback that whole unit of work, including the message consumption."},{"id":25,"href":"/microservices-datadriven/spring/starters/ucp/","title":"Oracle Spring Boot Starter for Universal Connection Pool","parent":"Oracle Spring Boot Starters","content":"This starter provides a connection (data source) to an Oracle Database using Universal Connection Pool, which provides an efficient way to use database connections.\nTo add this starter to your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-ucp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; For Gradle projects, add this dependency:\nimplementation \u0026#39;com.oracle.database.spring:oracle-spring-boot-starter-ucp:23.4.0\u0026#39; An Oracle data source is injected into your application and can be used normally. You must configure the data source as shown below, and you should also add either Spring Data JDBC or Spring Data JPA to your project.\nTo configure the data source, provide a spring.datasource object in your Spring application.yaml, or equivalent, as shown in the following example. The oracleucp entry is optional, and can be used to fine tune the configuration of the connection pool, if desired. For details of available settings, refer to the JavaDoc.\nspring: jpa: hibernate: ddl-auto: validate properties: hibernate: dialect: org.hibernate.dialect.OracleDialect format_sql: true show-sql: true datasource: url: jdbc:oracle:thin:@//myhost:1521/pdb1 username: account password: account driver-class-name: oracle.jdbc.OracleDriver type: oracle.ucp.jdbc.PoolDataSource oracleucp: connection-factory-class-name: oracle.jdbc.pool.OracleDataSource connection-pool-name: AccountConnectionPool initial-pool-size: 15 min-pool-size: 10 max-pool-size: 30 The spring.datasource.url can be in the basic format (as previously shown), or in TNS format if your application uses Transparent Network Substrate (TNS).\nNote that the connections to the database use the DEDICATED server by default. If you wish to use SHARED or POOLED, you can append that to the basic URL, or add it to the TNS names entry. For example, to use database resident pooled connections, you would change the URL shown in the previous example to the following:\ndatasource: url: jdbc:oracle:thin:@//myhost:1521/pdb1:pooled If you are using TNS, add server=pooled to the connect_data. For example:\nmydb_tp = (description= (retry_count=20) (retry_delay=3) (address=(protocol=tcps)(port=1521)(host=myhost)) (connect_data=(service_name=pdb1)(server=pooled)) (security=(ssl_server_dn_match=yes))) If you prefer to use Java configuration, the data source can be configured as shown in the following example:\nimport oracle.jdbc.pool.OracleDataSource; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import javax.sql.DataSource; import java.sql.SQLException; @Configuration public class DataSourceConfiguration { @Bean public DataSource dataSource() throws SQLException { OracleDataSource dataSource = new OracleDataSource(); dataSource.setUser(\u0026#34;account\u0026#34;); dataSource.setPassword(\u0026#34;account\u0026#34;); dataSource.setURL(\u0026#34;jdbc:oracle:thin:@//myhost:1521/pdb1\u0026#34;); dataSource.setDataSourceName(\u0026#34;AccountConnectionPool\u0026#34;); return dataSource; } } ","description":"This starter provides a connection (data source) to an Oracle Database using Universal Connection Pool, which provides an efficient way to use database connections.\nTo add this starter to your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-ucp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; For Gradle projects, add this dependency:\nimplementation \u0026#39;com.oracle.database.spring:oracle-spring-boot-starter-ucp:23.4.0\u0026#39; An Oracle data source is injected into your application and can be used normally. You must configure the data source as shown below, and you should also add either Spring Data JDBC or Spring Data JPA to your project."},{"id":26,"href":"/microservices-datadriven/spring/starters/wallet/","title":"Oracle Spring Boot Starter for Wallet","parent":"Oracle Spring Boot Starters","content":"This starter provides support for wallet-based authentication for Oracle Database connections. It depends on the UCP starter.\nTo add this starter to your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-wallet\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; For Gradle projects, add this dependency:\nimplementation \u0026#39;com.oracle.database.spring:oracle-spring-boot-starter-wallet:23.4.0\u0026#39; You need to provide the wallet to your application. You can specify the location in the spring.datasource.url as shown in the following example.\njdbc:oracle:thin:@mydb_tp?TNS_ADMIN=/oracle/tnsadmin Note that the location specified in the sqlnet.ora must match the actual location of the file.\nIf your service is deployed in Kubernetes, then the wallet should be placed in a Kubernetes secret which is mounted into the pod at the location specified by the TNS_ADMIN parameter in the URL.\n","description":"This starter provides support for wallet-based authentication for Oracle Database connections. It depends on the UCP starter.\nTo add this starter to your project, add this Maven dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-wallet\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; For Gradle projects, add this dependency:\nimplementation \u0026#39;com.oracle.database.spring:oracle-spring-boot-starter-wallet:23.4.0\u0026#39; You need to provide the wallet to your application. You can specify the location in the spring.datasource.url as shown in the following example.\njdbc:oracle:thin:@mydb_tp?TNS_ADMIN=/oracle/tnsadmin Note that the location specified in the sqlnet."},{"id":27,"href":"/microservices-datadriven/spring/starters/","title":"Oracle Spring Boot Starters","parent":"Oracle Backend for Spring Boot and Microservices","content":"Oracle provides a number of Spring Boot Starters that make it easy to use various Oracle technologies in Spring Boot projects.\nThe Oracle Spring Boot Starters are available in Maven Central and include the following starters.\nNote: The versioning of starters was originally in line with the matching Spring Boot version, but starting in November, 2023, the version numbering scheme was changed to more closely align with Oracle Database version numbering. The 23.4.0 starter is supported for Spring Boot 3.0 and later (including 3.1, 3.2). For Spring Boot 2.7.x users, use the matching 2.7.x version of the starter.\nOracle Spring Boot Starter for Universal Connection Pool Oracle Spring Boot Starter for Wallet Oracle Spring Boot Starter for AQ/JMS ","description":"Oracle provides a number of Spring Boot Starters that make it easy to use various Oracle technologies in Spring Boot projects.\nThe Oracle Spring Boot Starters are available in Maven Central and include the following starters.\nNote: The versioning of starters was originally in line with the matching Spring Boot version, but starting in November, 2023, the version numbering scheme was changed to more closely align with Oracle Database version numbering."},{"id":28,"href":"/microservices-datadriven/spring/platform/","title":"Platform Services","parent":"Oracle Backend for Spring Boot and Microservices","content":"Oracle Backend for Spring Boot and Microservices includes a number of Spring platform components that provide services to applications deployed to the platform.\nFor more details, read about:\nAPI Gateway Service Discovery Configuration Workflow Spring Admin Using the CLI MicroTx Vault ","description":"Oracle Backend for Spring Boot and Microservices includes a number of Spring platform components that provide services to applications deployed to the platform.\nFor more details, read about:\nAPI Gateway Service Discovery Configuration Workflow Spring Admin Using the CLI MicroTx Vault "},{"id":29,"href":"/microservices-datadriven/spring/development/envvars/","title":"Predefined Variables","parent":"Development","content":"When you deploy a Spring Boot application using the Oracle Backend for Spring Boot and Microservices CLI or Visual Code extension, a number of predefined environment variables will be injected into the pod definition. You may reference any of these variables in your application.\nThe predefined variables are as follows:\napp.container.port, for example 8080.\nThis sets the listen port for the pod and service. The Spring Boot application will listen on this port. The default is 8080. This can be set using the --port parameter on the deploy command in the CLI. spring.profiles.active, for example default.\nThis sets the Spring profiles that will be active in the application. The default value is default. This can be changed set the --service-profile parameter on the deploy command in the CLI. spring.config.label, for example 0.0.1.\nThis is a label that can be used with Spring Config to look up externalized configuration from Spring Config Server, along with the application name and the profile. eureka.instance.preferIpAddress, for example true.\nThis tells the Eureka discovery client to use the preferIpAddress setting. This is required in Kubernetes so that service discover will work correctly. eureka.instance.hostname, for example customer32.application.\nThis sets the hostname that Eureka will use for this application. MP_LRA_COORDINATOR_URL, for example http://otmm-tcs.otmm.svc.cluster.local:9000/api/v1/lra-coordinator.\nThis is the URL for the transaction manager which is required when using Eclipse Microprofile Long Running Actions in your application. MP_LRA_PARTICIPANT_URL, for example http://customer32.application.svc.cluster.local:8080.\nThis is the participant URL which is required when using Eclipse Microprofile Long Running Actions in your application. eureka.client.register-with-eureka, for example true.\nThis tells the Eureka discovery client to register with the Eureka server. eureka.client.fetch-registry, for example true.\nThis tells the Eureka discovery client to make a local copy of the registry by fetching it from the Eureka server. eureka.client.service-url.defaultZone, for example http://eureka.eureka:8761/eureka.\nThis is the default zone for the Eureka discovery client. zipkin.base-url, for example http://jaegertracing-collector.observability.svc.cluster.local:9411/api/v2/spans.\nThis is the URL of the Zipkin-compatible trace collector which can be used by your application to send trace data to the platform. otel.exporter.otlp.endpoint, for example http://open-telemetry-opentelemetry-collector.open-telemetry:4318/v1/traces.\nThis is the URL of the OpenTelemetry (OTLP protocol) trace collector which can be used by your application to send trace data to the platform. config.server.url, for example http://config-server.config-server.svc.cluster.local:8080.\nThis is the URL of the Spring Config Server provided by the platform. liquibase.datasource.username, for example set to the key db.username in secret admin-liquibasedb-secrets.\nThis sets the (admin) user that should be used to run Liquibase, if used in your service. liquibase.datasource.password, for example set to the key db.password in secret admin-liquibasedb-secrets.\nThis sets the (admin) user\u0026rsquo;s password that should be used to run Liquibase, if used in your service. spring.datasource.username, for example set to the key db.username in secret customer32-db-secrets.\nThis sets the (regular) user for your application to use to connect to the database (if you use JPA or JDBC in your application). spring.datasource.password:, for example set to the key db.password in secret customer32-db-secrets.\nThis sets the (regular) user\u0026rsquo;s password for your application to use to connect to the database (if you use JPA or JDBC in your application). DB_SERVICE, for example set to the key db.service in secret customer32-db-secrets.\nThis sets the database service name (the TNS name) for your application to use to connect to the database (if you use JPA or JDBC in your application). spring.datasource.url, for example jdbc:oracle:thin:@$(DB_SERVICE)?TNS_ADMIN=/oracle/tnsadmin.\nThis sets the data source URL for your application to use to connect to the database (if you use JPA or JDBC in your application). CONNECT_STRING, for example jdbc:oracle:thin:@$(DB_SERVICE)?TNS_ADMIN=/oracle/tnsadmin.\nThis sets the data source URL for your application to use to connect to the database (if you use JPA or JDBC in your application). ","description":"When you deploy a Spring Boot application using the Oracle Backend for Spring Boot and Microservices CLI or Visual Code extension, a number of predefined environment variables will be injected into the pod definition. You may reference any of these variables in your application.\nThe predefined variables are as follows:\napp.container.port, for example 8080.\nThis sets the listen port for the pod and service. The Spring Boot application will listen on this port."},{"id":30,"href":"/microservices-datadriven/spring/development/project/","title":"Project Structure","parent":"Development","content":"To take advantage of the built-in platform services, Oracle recommends using the following project structure.\nRecommended versions:\nSpring Boot 3.3.x Spring Cloud 2023.x.x Java 21 (or 17) Table of Contents:\nDependencies Spring Application Configuration Data Sources Liquibase Oracle Transaction Manager for Microservices Spring Config Server Tracing Dependencies Oracle recommends adding the following dependencies to your application so that it can take advantage of the built-in platform services. For example:\n\u0026lt;properties\u0026gt; \u0026lt;project.build.sourceEncoding\u0026gt;UTF-8\u0026lt;/project.build.sourceEncoding\u0026gt; \u0026lt;java.version\u0026gt;21\u0026lt;/java.version\u0026gt; \u0026lt;spring.boot.dependencies.version\u0026gt;3.3.1\u0026lt;/spring.boot.dependencies.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2023.0.2\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-registry-prometheus\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-netflix-eureka-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring.boot.dependencies.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; Spring Application Configuration Oracle recommends the following configuration in order for the application to access the built-in services, including the Spring Boot Eureka Service Registry and the observability tools:\nspring: application: name: account eureka: instance: hostname: ${spring.application.name} preferIpAddress: true client: service-url: defaultZone: ${eureka.service-url} fetch-registry: true register-with-eureka: true enabled: true management: endpoint: health: show-details: always endpoints: web: exposure: include: \u0026#34;*\u0026#34; metrics: tags: application: ${spring.application.name} The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI to deploy your application.\nData Sources If your application uses an Oracle database as data source, then add the following to the \u0026lsquo;pom.xml\u0026rsquo;. For more information about the Oracle Spring Boot Starters.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-ucp\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; If the database requires a Wallet to access the database you must add the following to the pom.xml file:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.database.spring\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;oracle-spring-boot-starter-wallet\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;23.4.0\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; Add the following to application configuration. Note that this example shows Java Persistence API (JPA). If you are using JDBC you should use the appropriate configuration. For example:\nspring: jpa: hibernate: ddl-auto: validate properties: hibernate: dialect: org.hibernate.dialect.OracleDialect format_sql: false show-sql: false datasource: url: ${spring.datasource.url} username: ${spring.datasource.username} password: ${spring.datasource.password} driver-class-name: oracle.jdbc.OracleDriver type: oracle.ucp.jdbc.PoolDataSource oracleucp: connection-factory-class-name: oracle.jdbc.pool.OracleDataSource connection-pool-name: AccountConnectionPool initial-pool-size: 15 min-pool-size: 10 max-pool-size: 30 The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI to deploy your application.\nLiquibase If you are using Liquibase to manage your database schema and data, then you should add the following dependency:\n\u0026lt;properties\u0026gt; \u0026lt;liquibase.version\u0026gt;4.28.0\u0026lt;/liquibase.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.liquibase\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;liquibase-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${liquibase.version}\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; Add the following configuration to your Spring application configuration:\nspring: liquibase: change-log: classpath:db/changelog/controller.yaml url: ${spring.datasource.url} user: ${liquibase.datasource.username} password: ${liquibase.datasource.password} enabled: ${LIQUIBASE_ENABLED:true} The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI to deploy your application. When you use the deploy command, you must specify the liquibase-db parameter and provide a user with sufficient privileges. Generally this will be permissions to create and alter users and to grant roles and privileges. If your service uses Java Messaging Service (JMS), this use may also need execute permission on dbms.aq_adm, dbms.aq_in and dbms.aq_jms.\nOracle Transaction Manager for Microservices If you are using Oracle Transaction Manager for Microservices (MicroTx) to manage data consistency across microservices data stores, then add the following dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.oracle.microtx.lra\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;microtx-lra-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;24.2.1\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Add the following configuration to your Spring application configuration. The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI or the Visual Studio Code Extension to deploy your application. For example:\nspring: microtx: lra: coordinator-url: ${MP_LRA_COORDINATOR_URL} propagation-active: true headers-propagation-prefix: \u0026#34;{x-b3-, oracle-tmm-, authorization, refresh-}\u0026#34; lra: coordinator: url: ${MP_LRA_COORDINATOR_URL} Spring Config Server If you are using Spring Config Server to manage configurations, then add the following dependency:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; Add the following configuration to your Spring application configuration. The variables in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI or the Visual Studio Code Extension to deploy your application. For example:\nspring: application: name: \u0026lt;application name\u0026gt; config: import: optional:configserver:${config.server.url} cloud: config: label: \u0026lt;optional\u0026gt; profile: \u0026lt;optional\u0026gt; username: \u0026lt;A user with the role ROLE_USER\u0026gt; password: \u0026lt;password\u0026gt; Tracing Application Tracing To enable Open Telemetry (OTEL) tracing you need to add the following dependencies to the pom/xml file.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing-bridge-otel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.opentelemetry\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;opentelemetry-exporter-otlp\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;io.micrometer\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;micrometer-tracing\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; In addition add the following to the application configuration. The variable in this configuration are automatically injected to your deployment and pods when you use the Oracle Backend for Spring Boot and Microservices CLI or the Visual Studio Code Extension to deploy your application. For example:\nmanagement: tracing: sampling: probability: 1.0 info: os: enabled: true env: enabled: true java: enabled: true otlp: tracing: endpoint: ${otel.exporter.otlp.endpoint} Database tracing To get tracing for the database calls you need to add the following dependency to the po.xml file:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;net.ttddyy.observation\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;datasource-micrometer-spring-boot\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0.3\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; ","description":"To take advantage of the built-in platform services, Oracle recommends using the following project structure.\nRecommended versions:\nSpring Boot 3.3.x Spring Cloud 2023.x.x Java 21 (or 17) Table of Contents:\nDependencies Spring Application Configuration Data Sources Liquibase Oracle Transaction Manager for Microservices Spring Config Server Tracing Dependencies Oracle recommends adding the following dependencies to your application so that it can take advantage of the built-in platform services. For example:\n\u0026lt;properties\u0026gt; \u0026lt;project."},{"id":31,"href":"/microservices-datadriven/spring/blogs/","title":"Read our blogs!","parent":"Oracle Backend for Spring Boot and Microservices","content":"Our team members post blog articles and other content on various sites including Medium, LinkedIn (Corrado de Bari, Doug Drechsel), RedStack, DZone, Andy Tael and the Oracle Developers Blog. We\u0026rsquo;d love you to check them out. This page acts as an index/aggregator for some of our featured content.\nAnd be sure to subscribe to our YouTube channel \u0026ldquo;The Converged Database\u0026rdquo; for more great content!\nBlowing Up Database Monoliths\nA deep dive into Data Recfactoring Advisor - an innovative method to refactor monolithic database schema for microservices.\nAniket Tiwari - 7/22/2024\nOracle Database Observabilty\nAn update on the Oracle Database metrics (Prometheus) exporter to coincide with the 1.2.1 release.\nMark Nelson - 4/17/2024\nFull Stack Development with Oracle 23c\nDoug gives an end to end demo of full stack development using the new Oracle 23c Database and the \u0026#39;OWEN\u0026#39; stack.\nDoug Drechsel - 4/8/2024\nOracle Autonomous DB ‘Select AI’ and Spring Boot to talk with your DB\nLearn about the new Select AI feature that allows Autonomous Database to use generative AI with Large Language Models (LLMs) to convert the user’s input text into Oracle SQL. Select AI processes the natural language prompt, supplements the prompt with metadata, and then generates and runs a SQL query.\nCorrado de Bari - 2/7/2024\nBoost your apps with GraalVM in the Oracle Backend for Spring Boot and Microservices\nHow to run your Spring Boot app in native way on the Oracle Backend for Spring Boot and Microservices and the benefits you\u0026#39;ll gain.\nCorrado de Bari - 12/06/2023\nSpring Boot: from Jar to production in 5 minutes\nStep-by-step how to deploy your Spring Boot app with Oracle Autonomous as DB, tested and running locally, to the Oracle Backend for Spring Boot and Microservices.\nCorrado de Bari - 11/27/2023\nTesting Spring Boot Applications with Testcontainers and Oracle\nIn this article, Mark shows us how to easily test your Spring Boot applications with a full Oracle 23c database, with only about a 10 second startup time, which is fast enough to use even in unit tests.\nMark Nelson - 11/21/2023\nIntroducing the Oracle Database Observability Exporter\nLearn about the new Oracle Database Observability Exporter which allows you to export metrics from the Oracle Database in the defacto standard Prometheus format, so that they can be ingested in Prometheus or a similar time series database and used to create dashboards in Grafana or a similar platform.\nMark Nelson - 11/13/2023\nDeveloping Mobile Apps with Oracle Free23c\nDoug shows how to develop mobile applications using Oracle\u0026#39;s MERN Stack locally.\nDoug Drechsel - 10/27/2023\nUsing Oracle\u0026#39;s MERN Stack to develop Mobile Applications\nIn this video, Doug introduces Oracle\u0026#39;s MERN Stack and then demonstrates how to build mobile applications using the Stack.\nDoug Drechsel - 10/2/2023\nUsing GraphQL with Oracle\u0026#39;s MERN Stack\nDoug introduces GraphQL and shows how to run simple queries using the GraphQL playground in the Parse dashboard.\nDoug Drechsel - 9/25/2023\nCoding for Observability in the Oracle Backend for Spring Boot and Microservices\nCorrado shows how to configure a Spring Boot application to allow Prometheus to collect metrics and show them in a Grafana dashboard.\nCorrado de Bari - 7/25/2023\nChat with the Oracle DB\nCorrado shows how to leverage OpenAI models to make text-to-SQL translation on Oracle DB.\nCorrado de Bari - 7/19/2023\nOracle Backend for Spring Boot and Microservices multi-cloud install on Azure\nJohn shows us how to install Oracle Backend for Spring Boot and Microservices on Azure.\nJohn Lathouwers - 6/15/2023\nHow to use ChatGPT/OpenAI APIs from Oracle Backend for Spring Boot and Microservices/Parse\nCorrado demonstrates how to use OpenAI APIs to provide AI application services to mobile clients through the Parse Platform.\nCorrado de Bari - 6/5/2023\nSpring Boot integration with Parse Platform\nCorrado and Doug show us how to use WebHooks in Parse Platform to expose Spring Boot microservices to mobile apps.\nCorrado de Bari - 6/1/2023\nExample: Use Liquibase with Spring Boot in Kubernetes\nJohn shows us how to use Liquibase with Spring Boot.\nJohn Lathouwers - 6/1/2023\nExample: Use SQLcl \u0026#43; Liquibase in Kubernetes initContainers\nJohn shows us how to use SQLcl and Liquibase in Kubernetes initContainers for effective Schema Change Management during deployments of microservices applications in Kubernetes that use Oracle Database.\nJohn Lathouwers - 5/26/2023\nKafka interoperability in Oracle Database 23c\nMark provides an overview of the Kafka compatibility features in Oracle Database 23c Free - Developer Release including the Java and REST APIs and the connectors.\nMark Nelson - 5/22/2023\nLearn how to build and deploy a Spring Boot application to Oracle Backend for Spring Boot and Microservices using Spring starters for UCP and Wallet\nAndy shows us how to build a Phonebook application using Spring Boot with the Oracle Spring Boot Starters for Universal Connection Pools and wallet, and deploys the applications to the Oracle Backend for Spring Boot and tests it.\nAndy Tael - 5/17/2023\nStart up an Oracle Database in Kubernetes with Oracle REST Data Services and Database Actions in no time at all!\nMark demonstrates how easy it is to get an instance of Oracle up and running in Kubernetes, with Oracle REST Data Services and Database Actions using the Oracle Database Operator for Kubernetes.\nMark Nelson - 5/1/2023\nNew 23c version of Kafka-compatible Java APIs for Transactional Event Queues published\nMark demonstrates how to use the new 23c version of the Kafka-compatible Java APIs for Transactional Event Queues, available in Maven Central, which allow you to use the standard Kafka Java API with Transactional Event Queues acting as the Kafka broker. The only things that you would need to change are the broker address, and you need to use the Oracle versions of KafkaProducer and KafkaConsumer – other than that, your existing Kafka Java code should just work!\nMark Nelson - 5/1/2023\nSpring Boot Starters for Oracle updated\nAn example of how to use the new Spring Boot Starter for UCP for Spring 3.0.x.\nMark Nelson - 4/24/2023\nI have deployed Oracle Backend for Spring Boot and Microservices (Developer preview). Now what?\nAndy shows us how easy it is to build a Spring Boot Phone Book application, deploy it to Oracle Backend for Spring Boot and Microservices using the CLI, and create a route in APISIX Gateway to expose the REST endpoints.\nAndy Tael - 4/20/2023\nOracle Backend for Spring and Parse Video\nThis video introduces the Oracle Backend for Spring Boot and Microservices (and Parse Platform) which makes it super easy to develop, run and manage Spring Boot microservices and mobile applications leveraging all the power of Oracle’s converged database.\nAndy Tael - 4/20/2023\nLong Running Actions\nPaul Parkinson demonstrates a Spring Boot microservices application that implements the Saga pattern with Long Running Actions using the Oracle Transaction Manager for Microservices to manage data consistency across microservices.\nPaul Parkinson - 4/18/2023\nOracle Mobile Backend As A Service\nMobile Backend As A Service (MBaaS) is a cloud service that an app developer can immediately start development against with just an endpoint. Doug finds out how far he can get developing a phone application without interacting with the server in any way other than the API endpoint.\nDoug Drechsel - 4/14/2023\nIntroducing Cloud Bank\nAnd introduction to the Cloud Bank sample application which showcases Spring Boot microservices, long running actions/sagas and a Flutter mobile application built with the Oracle Backend for Spring Boot and Microservices.\nMark Nelson - 4/6/2023\nDeveloping Saga Participant Code For Compensating Transactions\nA detailed comparison of the saga pattern with XA (2PC) comparing the pros and cons of each approach to provide data integrity between multiple services and for potentially long running transactions.\nPaul Parkinson - 3/27/2023\nOracle Backend for Spring Boot and Microservices is LIVE! (Developer Preview)\nAn introduction to the Oracle Backend for Spring Boot and Microservices.\nAndy Tael - 3/25/2023\nA First Spring Boot Service with Oracle\nA detailed guide to building a Spring Boot microservice from scratch that uses Spring Data JPA to manage data in the Oracle Database and exposes various endpoints to access the data.\nMark Nelson - 2/3/2023\nReact Native and Oracle MBaaS – a beginner’s tutorial\nA step-by-step guide to building a React Native mobile application using the Parse APIs and Oracle Backend for Parse Platform.\nCorrado de Bari - 1/5/2023\nOracle Mobile Backend as a Service (MBaaS)\nAn introduction and walk-through of the Oracle Backend for Parse Platform, including installation, using the dashboard, getting started with application development and integration with the Oracle Autonomous Database.\nDoug Drechsel - 12/23/2022\nReact.JS on Oracle MBaaS\nA step-by-step guide to implement a simple ReactJS app leveraging Oracle MBaaS.\nCorrado de Bari - 12/22/2022\nTwo new Backend as a Service offerings live now!\nA brief announcement and introduction to our Developer Preview releases of Oracle Backend for Spring Boot and Microservices and Parse Platform.\nMark Nelson - 12/21/2022\nDevelopment Environment Setup with Spring Boot For Oracle\nA detailed guide to setting up a development environment to build Spring Boot microservices with the Oracle Database.\nMark Nelson - 12/8/2022\nBackend-as-a-Service (BaaS) and Oracle Database (Video) OCW Teaser\nErin Dawson, DevRel Communications Manager talks with Mark about the Oracle CloudWorld 2022 presentations and hands-on labs for Oracle Backend for Spring Boot and Microservices and Parse Platform.\nMark Nelson - 10/12/2022\nOracle REST Data Services 22.3 bring new REST APIs for Transactional Event Queues\nAn announcement and several example that show how to use the new REST APIs for Transactional Event Queues.\nMark Nelson - 10/11/2022\nGetting Started with the New Observability Exporter for Oracle Database\nA simple step-by-step getting started example that shows you how to use the Observability Exporter for Oracle Database to expose data from the Oracle Database as Prometheus metrics.\nMark Nelson - 9/27/2022\nDevelop React \u0026#43; GraphQL \u0026#43; Spring Data JPA \u0026#43; UCP \u0026#43; Oracle\nA a succinct description and example of a modern full stack microservice app including a React frontend service that conducts GraphQL queries against a Spring Boot Data JPA backend service that in turn maps to an Oracle database.\nPaul Parkinson - 9/18/2022\nUnified Observability Exporters: Metrics, Logs, and Tracing\nA deep dive into metrics, logs and tracing exporters for the Oracle Database and how to configure them with Grafana to provide unified observability for microservices and the Oracle Database.\nPaul Parkinson - 8/11/2022\nLet the Oracle Database Operator for Kubernetes Do the Job\nAn introduction to and overview of the Oracle Database Operator for Kubernetes.\nPaulo Simoes - 1/6/2022\nHow to use Vaults and Wallets for Simple Secure Connectivity\nProvides details on how to secure connections in Java, JavaScript, Python, .NET, and Go as well as convenience integration features that are provided by microservice frameworks, specifically Helidon and Micronaut.\nPaul Parkinson - 12/18/2021\nDeveloping Event Driven Microservices in Java, Javascript, PL/SQL, Go, Python\nLearn about developing Event-Driven Microservices in Java, JavaScript, Python, .NET, and Go with AQ/TEQ in the Oracle Database.\nPaul Parkinson - 12/17/2021\nApache Kafka vs Oracle Transactional Event Queues for Event Driven Microservices\nComparing transactional and message delivery behavior, as it relates to microservice architectures (event mesh, event sourcing, etc.) Kafka and Oracle Transaction Event Queues.\nPaul Parkinson - 9/23/2021\n","description":"Our team members post blog articles and other content on various sites including Medium, LinkedIn (Corrado de Bari, Doug Drechsel), RedStack, DZone, Andy Tael and the Oracle Developers Blog. We\u0026rsquo;d love you to check them out. This page acts as an index/aggregator for some of our featured content.\nAnd be sure to subscribe to our YouTube channel \u0026ldquo;The Converged Database\u0026rdquo; for more great content!\nBlowing Up Database Monoliths\nA deep dive into Data Recfactoring Advisor - an innovative method to refactor monolithic database schema for microservices."},{"id":32,"href":"/microservices-datadriven/spring/release-notes/","title":"Release Notes","parent":"Oracle Backend for Spring Boot and Microservices","content":" Version 1.2.0, June 14th, 2024 This release includes:\nAdditional functionality to Spring Operations Center UI (SOC UI). Spring Boot upgrade to 3.3.0 and Spring Cloud 2023.0.2 for internal components. Oracle Backend for Spring Boot and Microservices are running Java 21 with Virtual Threads enabled. oractl is compiled using Java 21 and Virtual Threads. Openshift support The following components were updated:\nComponent New Version Replaced Version Spring Boot Admin server 3.3.1 3.2.0 APISIX API Gateway 3.9.1 3.8.0 Spring Authorization Server 3.3.0 3.2.1 Coherence Operator 3.3.4 3.3.2 Spring Cloud Config server 4.1.2 2023.0.0 Spring Eureka service registry 4.1.2 2023.0.0 Grafana 10.4.1 9.2.5 iNGINX Ingress Controller 1.10.0 1.8.1 Apache Kafka 3.7.0 3.6.1 Metrics server 0.7.0 0.6.4 Jaeger Tracing 1.53.0 1.51.0 OpenTelemetry Collector 0.101.0 0.93.0 Oracle Database Observability Exporter 1.2.1 1.2.0 Oracle Transaction Manager for Microservices 23.4.2 23.4.1 Prometheus 2.52.0 2.47.1 Prometheus Operator 0.74.0 0.63.0 Spring Operations Center 1.2.0 1.1.3 HashiCorp Vault 1.16.1 1.15.2 Deprecation Notice The following components are deprecated and are removed from this release:\nOracle Database Storage Adapter for Parse Parse Server Parse Dashboard Version 1.1.3, March 8, 2024 This release includes small updates and/or bug fixes. No components were upgraded.\nThe following functionality was added:\nHashiCorp Vault Grafana dashboard. HashiCorp Vault audit logging capability. Version 1.1.2, March 1, 2024 This release includes small updates and/or bug fixes and some additional functionality to SOC UI. No components were added or upgraded.\nVersion 1.1.1, February 9, 2024 This release adds the \u0026ldquo;Spring Operations Center\u0026rdquo; feature, adds or updates some Grafana dashboards, and includes other small updates and/or bug fixes.\nThe following components were added:\nComponent Version Description Spring Operations Center 1.1.1 Provide operations capabilities for Spring applications. The following components were updated:\nComponent New Version Replaced Version OpenTelemetry Collector 0.93.0 0.91.0 Version 1.1.0, February 2, 2024 Notes:\nRecommended versions for user applications updated Spring Boot 3.2.x, Java 17 or 21, Spring 6.1 and Spring Cloud 2023.0.0, with limited backwards compatibility for Spring Boot 2.7.x. Platform components are updated to Spring Boot 3.2.1 versions and matching Spring Cloud versions. A preview of a new \u0026ldquo;Spring Operations Center\u0026rdquo; feature is added, including a web user interface and additional Grafana dashboards. User Management using the CLI and REST Endpoints. Added support for auto-scaling of Spring Boot applications deployed in the platform. Changes to the custom installation to allow using existing resources including database, network and Kubernetes. Various platform services updated to use Database Resident Connection Pooling to improve performance. Improvements to collection of trace data using Open Telemetry, including migration to agentless approach, uptake of Micrometer, and so on. Improvements for Spring Native/GraalVM native image compilation of Spring Boot services. Improvements to CLI to support scripting. Various components updated to newer releases. Bug fixes. The following components were added:\nComponent Version Description Oracle Database Observability Exporter 1.1.2 Provides observability for the Oracle Database. Metrics server 0.64 Source of container resource metrics for Kubernetes built-in autoscaling pipeline Kube State Metrics 2.10.1 Collects metrics for the Kubernetes cluster The following components were updated:\nComponent New Version Replaced Version APISIX API Gateway 3.8.0 3.4.0 Apache Kafka 3.6.1 3.5.1 Coherence Operator 3.3.2 3.2.11 Conductor Server 3.13.8 3.13.2 HashiCorp Vault 1.15.2 1.14.0 Netflix Conductor 3.13.8 3.13.2 OpenTelemetry Collector 0.91.0 0.86.0 Oracle Backend for Spring Boot and Microservices CLI 1.1.0 1.0.1 Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 1.1.0 1.0.1 Oracle Transaction Manager for Microservices (MicroTx) 23.4.1 22.3.2 Spring Authorization Server 3.2.1 2.7.5 Spring Boot Admin dashboard 3.2.0 3.1.3 Spring Cloud Config server 2023.0.0 2022.0.4 Spring Cloud Eureka service registry 2023.0.0 4.0.3 Strimzi-Apache Kafka operator 0.39.0 0.36.1 Version 1.0.1, November 2, 2023 Notes:\nBug fixes The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 1.0.1 1.0.0 Oracle Backend for Spring Boot and Microservices CLI 1.0.1 1.0.0 Version 1.0.0, October 15, 2023 This is the first production release.\nNotes:\nAll Spring platform components upgraded to Spring Boot 3.x, Spring 6.x and Spring Cloud 2022.0.4 versions. Spring Native (with GraalVM native image ahead of time compilation) is the default/recommended deployment option for microservices. JVM continues to be available as an option. Loki and Promtail added for logging, Spring Boot dashboard updated to show metrics and logs on the same dashboard. Spring Authorization Server added, and preconfigured with default users (you supply passwords during installation, or they are generated). Various platform services and the CLI updated for authentication and authorization using Spring Authorization Server. Various platform services reconfigured for increased availability. Various components updated. The following components were added:\nComponent Version Description Loki 2.6.1 Provides log aggregation and search. Promtail 2.8.2 Collects logs. Spring Authorization Server 2022.0.4 Provides authentication and authorization for applications. The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 1.0.0 0.3.9 Oracle Backend for Spring Boot and Microservices CLI 1.0.0 0.3.1 Grafana 9.5.2 9.2.5 Spring Eureka Service Registry 2022.0.4 2021.0.3 Spring Config Server 2022.0.4 2021.0.3 Spring Boot Admin 3.1.3 2.7.5 cert-manager 1.12.3 1.11.0 NGINX Ingress Controller 1.8.1 1.6.4 Prometheus 2.40.2 2.34.0 Open Telemetry Collector 0.86.0 0.66.0 Jaeger Tracing 1.45.0 1.39.0 APISIX API Gateway 3.4.0 3.2.0 Strimzi-Apache Kafka operator 0.36.1 0.33.1 Apache Kafka 3.4.0 - 3.5.1 3.2.0 - 3.3.2 Oracle Database storage adapter for Parse (optional) 1.0.0 0.2.0 There were no component deprecations or removals.\nDeveloper Preview 0.7.0, July 24, 2023 Notes:\nContinued incremental improvements to Oracle Database Adapter for Parse Server. The following components were added:\nComponent Version Description Coherence 3.2.11 Provides in-memory data grid. The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 0.3.9 0.3.8 HashiCorp Vault 1.14.0 v1.11.3 Oracle Database Operator for Kubernetes 1.0 0.6.1 Parse Server 6.2.0 5.2.7 Parse Dashboard 5.1.0 5.0.0 Oracle Transaction Manager for Microservices 22.3.2 22.3.1 There were no component deprecations or removals.\nDeveloper Preview 0.3.1, June 14, 2023 Notes:\nImprovements to Oracle Cloud Infrastructure (OCI) installation process. Continued incremental improvements to Oracle Database Adapter for Parse Server. No components were added.\nThe following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices CLI 0.3.1 0.3.0 Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 0.3.8 0.3.7 There were no component deprecations or removals.\nDeveloper Preview 0.3.0, April 17, 2023 Notes:\nOracle Backend for Spring Boot and Microservices now includes the option to install in a Multicloud (OCI/Azure) environment. The Oracle Database Operator for Kubernetes is bound to the existing Oracle Autonomous Database (ADB) created by infrastructure as code (IaC) in an all-OCI installation and provisions the ADB in the Multicloud installation. Improvements to On-Premises and desktop installation processes. The following components were added:\nComponent New Version Description Oracle Backend for Spring Boot and Microservices Visual Studio Code extension 0.3.7 Allows Visual Studio Code users to manage the platform, deployments and configuration. The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices CLI 0.3.0 0.1.0 There were no component deprecations or removals.\nDeveloper Preview 0.2.3, March 8, 2023 Notes:\nOracle Backend for Spring Boot and Microservices now includes the option to also install Parse Platform in the same deployment. Oracle Backend for Spring Boot and Microservices CLI 0.2.3 includes a number of bug fixes and adds support for custom listening ports for services. Apache APISIX is now pre-configured for both Eureka and Kubernetes service discovery. The following components were added:\nComponent Version Description Oracle Database Operator for Kubernetes 0.6.1 Helps reduce the time and complexity of deploying and managing Oracle databases. Parse Server 5.2.7 Provides backend services for mobile and web applications. Parse Dashboard 5.0.0 Uses a web user interface for managing Parse Server. Oracle Database Adapter for Parse Server 0.2.0 Enables the Parse Server to store data in an Oracle database. The following components were updated:\nComponent New Version Replaced Version Oracle Backend for Spring Boot and Microservices CLI 0.2.3 0.1.0 cert-manager 1.11.0 1.10.1 NGINX Ingress Controller 1.6.4 1.5.1 Jaeger Tracing 1.39.0 1.37.0 Apache APISIX 3.1.1 2.15.1 Spring Boot Eureka service registry 2.0.1 2021.0.3 Oracle Transaction Manager for Microservices 22.3.2 22.3.1 Parse Server (optional) 6.3.0 6.2.0 Parse Dashboard (optional) 5.2.0 5.1.0 There were no deprecations or removals.\nDeveloper Preview 0.2.0, February 27, 2023 The following components were added:\nComponent Version Description Oracle Transaction Manager for Microservices 22.3.1 Manages distributed transactions to ensure consistency across Microservices. Strimzi-Apache Kafka Operator 0.33.1 Manages Apache Kafka clusters. Apacha Kafka 3.2.0 - 3.3.2 Allows distributed event streaming. There were no deprecations or removals.\nDeveloper Preview 0.1.0, January 30, 2023 The following components were added:\nComponent Version Description HashiCorp Vault v1.11.3 Provides a way to store and tightly control access to sensitive data. Oracle Backend for Spring Boot and Microservices CLI 0.1.0 Provides a command-line interface to manage application deployment and configuration. Netflix Conductor OSS 3.13.2 Provides workflow orchestration for Microservices. On-premises installer 0.1.0 Allows installation of a self-hosted stack. There were no deprecations or removals.\nDeveloper Preview 0.0.1, December 20, 2022 This release includes the following components:\nComponent Version Description cert-manager 1.10.1 Automates the management of certificates. NGINX Ingress Controller 1.5.1 Provides a traffic management solution for cloud native applications in Kubernetes. Prometheus 2.40.2 Provides event monitoring and alerting. Prometheus operator 0.60.1 Provides management for Prometheus monitoring tools. OpenTelemetry Collector 0.66.0 Collects process and export telemetry data. Grafana 9.2.5 Examines, analyzes, and monitors metrics. Jaeger Tracing 1.37.0 Provides a distributed tracing system for monitoring and troubleshooting distributed systems. Apache APISIX 2.15.1 Provides full lifecycle API management. Spring Cloud Admin server 2.7.5 Manages and monitors Spring Boot applications. Spring Cloud Config server 2.7.5 Provides server-side support for externalized configuration. Spring Boot Eureka service registry 2021.0.3 Provides service discovery capabilities. ","description":"Version 1.2.0, June 14th, 2024 This release includes:\nAdditional functionality to Spring Operations Center UI (SOC UI). Spring Boot upgrade to 3.3.0 and Spring Cloud 2023.0.2 for internal components. Oracle Backend for Spring Boot and Microservices are running Java 21 with Virtual Threads enabled. oractl is compiled using Java 21 and Virtual Threads. Openshift support The following components were updated:\nComponent New Version Replaced Version Spring Boot Admin server 3."},{"id":33,"href":"/microservices-datadriven/spring/sampleapp/","title":"Sample Application - CloudBank","parent":"Oracle Backend for Spring Boot and Microservices","content":"Oracle recommends that you use the CloudBank LiveLab to learn how to use Oracle Backed for Spring Boot and Microservices. The LiveLab has the following Outline:\nProvision an Instance Setup your Development Environment Build the Account Microservice Build Check Processing Microservice that uses JMS and TXEventQ Manage Saga Transactions across Microservices Deploy the full CloudBank Application using the CLI Deploy the full CloudBank Application using the VS Code Extension Explore the Backend Platform Extend the Mobile Application Cleanup The CloudBank source code is provided here, this repository also contains more services.\n","description":"Oracle recommends that you use the CloudBank LiveLab to learn how to use Oracle Backed for Spring Boot and Microservices. The LiveLab has the following Outline:\nProvision an Instance Setup your Development Environment Build the Account Microservice Build Check Processing Microservice that uses JMS and TXEventQ Manage Saga Transactions across Microservices Deploy the full CloudBank Application using the CLI Deploy the full CloudBank Application using the VS Code Extension Explore the Backend Platform Extend the Mobile Application Cleanup The CloudBank source code is provided here, this repository also contains more services."},{"id":34,"href":"/microservices-datadriven/spring/security/","title":"Security","parent":"Oracle Backend for Spring Boot and Microservices","content":"The Oracle Backend for Spring Boot and Microservices has the following security characteristics:\nAll access to the database is done using the Mutual Transport Layer Security (mTLS) database wallet. The user name, password, and URL are stored in Kubernetes secrets.\nAccessing most dashboards can only be done using port-forwarding, the exceptions are the Spring Operations Center and Grafana, which can be accessed through the load balancer using TLS and appropriate authentication. The passwords for the dashboards are provided by the installer or autogenerated and stored in Kubernetes secrets.\nThe only \u0026ldquo;public\u0026rdquo; exposure is the Apache APISIX Gateway (note that the dashboard is not exposed publicly), the Spring Operations Center and Grafana.\nServices deployed to the platform are not exposed through the Apache APISIX Gateway automatically. If you want to expose the service through the gateway, you must define a route in the Apache APISIX dashboard. APISIX Gateway Documentation\nThe deployed platform services are using using self-signed certificates.\nA customer application can only access services running in the platform using the Apache APISIX Gateway. APISIX Gateway Documentation\nThe customer application can be secured using Spring Security (for example, Spring OAuth 2.0 Resource Server). An external authorization server is recommended (for example Okta or Auth0).\nOracle Backend for Spring Boot and Microservices provides an authorization server which is an engine to authenticate and authorize requests to various components in Oracle Backend for Spring Boot and Microservices. The end user can manage users using REST Endpoints. AuthZ Server Documentation\nOracle Backend for Spring Boot and Microservices contains HashiCorp Vault to secure, store and tightly control access to tokens, passwords, certificates, encryption keys for protecting secrets, and other sensitive data. HashiCorp Vault Documentation\nTransport Layer Security The Oracle Backend for Spring Boot and Microservices is deployed with a sample self-signed certificate for Transport Layer Security (TLS). This results in an \u0026ldquo;Accept Risk\u0026rdquo; message when accessing the Spring Operations Center or Grafana web user interfaces and the sample TLS certificate should not be used for production deployments.\nUpdating the TLS Certificate Ensure your Domain Name System (DNS) entry points to the IP address for the public load balancer. You can check this address with this command, the address in the EXTERNAL-IP field is the public load balancer address:\nkubectl -n ingress-nginx get svc ingress-nginx-controller Obtain a new TLS certificate. In a production environment, the most common scenario is to use a public certificate that has been signed by a certificate authority.\nCreate a new Kubernetes secret in the ingress-nginx namespace. For example:\nkubectl -n ingress-nginx create secret tls my-tls-cert --key new-tls.key --cert new-tls.crt Modify the service definition to reference the new Kubernetes secret by changing the service.beta.kubernetes.io/oci-load-balancer-tls-secret annotation in the service configuration. For example:\nkubectl patch service ingress-nginx-controller -n ingress-nginx \\ -p \u0026#39;{\u0026#34;metadata\u0026#34;:{\u0026#34;annotations\u0026#34;:{\u0026#34;service.beta.kubernetes.io/oci-load-balancer-tls-secret\u0026#34;:\u0026#34;my-tls-cert\u0026#34;}}}\u0026#39; \\ --type=merge ","description":"The Oracle Backend for Spring Boot and Microservices has the following security characteristics:\nAll access to the database is done using the Mutual Transport Layer Security (mTLS) database wallet. The user name, password, and URL are stored in Kubernetes secrets.\nAccessing most dashboards can only be done using port-forwarding, the exceptions are the Spring Operations Center and Grafana, which can be accessed through the load balancer using TLS and appropriate authentication."},{"id":35,"href":"/microservices-datadriven/spring/setup/","title":"Setup","parent":"Oracle Backend for Spring Boot and Microservices","content":"Oracle Backend for Spring Boot and Microservices is available in the OCI Marketplace.\nPrerequisites Summary of Components Overview of the Setup Process Set Up the OCI Environment Set Up the Local Machine Access information and passwords from the OCI Console Prerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot and Microservices. You need:\nAn Oracle Cloud Infrastructure (OCI) account in a tenancy with sufficient quota to create the following:\nAn OCI Container Engine for Kubernetes cluster (OKE cluster), plus a node pool with three worker nodes. A virtual cloud network (VCN) with at least two public IP\u0026rsquo;s available. A public load balancer. An Oracle Autonomous Database Serverless instance. At least one free OCI auth token (note that the maximum is two per user).\nOn a local machine, you need:\nThe Kubernetes command-line interface (kubectl). Installing kubectl documentation Oracle Cloud Infrastructure command-line interface (CLI). Quickstart - Installing the CLI. Oracle Backend for Spring Boot and Microservices command-line interface (oractl). Download oractl. [OPTIONAL]Oracle Backend for Spring Boot and Microservices VS Code Extension. Download VS Code Extension. OCI policies The following policies needs to be in place to be able to install Oracle Backend for Spring Boot and Microservices. Top level and their dependencies listed.\nOracle Container Engine for Kubernetes Allow group `\u0026lt;group-name\u0026gt;` to manage cluster-family in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to inspect compartments in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to read virtual-network-family in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to use network-security-groups in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to use private-ips in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to use subnets in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to use vnics in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to manage cluster-node-pools in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to manage instance-family in `\u0026lt;location\u0026gt;` └── Allow group `\u0026lt;group-name\u0026gt;` to manage public-ips in `\u0026lt;location\u0026gt;` VCN Allow group `\u0026lt;group-name\u0026gt;` to manage vcns in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to manage route-tables in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to manage-security-lists in `\u0026lt;location\u0026gt;` ├── Allow group `\u0026lt;group-name\u0026gt;` to manage-dhcp-options in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage vcns in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage route-tables in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage security-lists in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage dhcp-options in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage nat-gateways in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage service-gateways in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage network-security-groups in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage subnets in `\u0026lt;location\u0026gt;` Container Registry Allow group `\u0026lt;group-name\u0026gt;` to manage repos in `\u0026lt;location\u0026gt;` Object Storage Allow group `\u0026lt;group-name\u0026gt;` to read objectstorage-namespaces in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage objects in `\u0026lt;location\u0026gt;` └── Allow group `\u0026lt;group-name\u0026gt;` to manage buckets in `\u0026lt;location\u0026gt;` Autonomous Database Allow group `\u0026lt;group-name\u0026gt;` to manage autonomous-database-family in `\u0026lt;location\u0026gt;` Vault If you deploy Oracle Backend for Spring Boot and Microservices STANDARD edition you need the following policies.\nAllow group `\u0026lt;group-name\u0026gt;` to manage vaults in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage keys in `\u0026lt;location\u0026gt;` Additional Vault To allow Container Engine for Kubernetes to access Vault via Groups:\nAllow group `\u0026lt;group-name\u0026gt;` to manage policies in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage tag-namespaces in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage dynamic-groups in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage secret-family in `\u0026lt;location\u0026gt;` Oracle Resource Manager Allow group `\u0026lt;group-name\u0026gt;` to read orm-template in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to use orm-stacks in `\u0026lt;location\u0026gt;` └── Allow group `\u0026lt;group-name\u0026gt;` to manage orm-jobs in `\u0026lt;location\u0026gt;` Allow group `\u0026lt;group-name\u0026gt;` to manage orm-private-endpoints in `\u0026lt;location\u0026gt;` Summary of Components Oracle Backend for Spring Boot and Microservices setup installs the following components:\nComponent Version Description Apache APISIX 3.9.1 Provides full lifecycle API management. Apache Kafka 3.7.0 Provides distributed event streaming. cert-manager 1.12.3 Automates the management of certificates. Coherence Operator 3.3.4 Provides in-memory data grid. Conductor Server 3.13.8 Provides a Microservice orchestration platform. Grafana 10.4.1 Provides the tool to examine, analyze, and monitor metrics. HashiCorp Vault 1.16.1 Provides a way to store and tightly control access to sensitive data. Jaeger Tracing 1.53.0 Provides distributed tracing system for monitoring and troubleshooting distributed systems. Kube State Metrics 2.10.1 Collects metrics for the Kubernetes cluster Loki 2.6.1 Provides log aggregation and search. Metrics server 0.7.0 Source of container resource metrics for Kubernetes built-in autoscaling pipeline NGINX Ingress Controller 1.10.1 Provides traffic management solution for cloud‑native applications in Kubernetes. OpenTelemetry Collector 0.101.0 Collects process and export telemetry data. Oracle Database Observability Exporter 1.2.1 Exposes Oracle Database metrics in standard Prometheus format. Oracle Database Operator 1.0 Helps reduce the time and complexity of deploying and managing Oracle databases. Oracle Transaction Manager for Microservices 23.4.2 Manages distributed transactions to ensure consistency across Microservices. Prometheus 2.52.0 Provides event monitoring and alerts. Prometheus Operator 0.74.0 Provides management for Prometheus monitoring tools. Promtail 2.8.2 Collects logs. Spring Authorization Server 3.3.0 Provides authentication and authorization for applications. Spring Boot Admin server 3.3.1 Manages and monitors Spring Cloud applications. Spring Cloud Config server 4.1.2 Provides server-side support for an externalized configuration. Spring Eureka service registry 4.1.2 Provides service discovery capabilities. Strimzi-Apache Kafka operator 0.36.1 Manages Apache Kafka clusters. Overview of the Setup Process This video provides a quick overview of the setup process.\nInstalling Oracle Backend for Spring Boot and Microservice takes approximately one hour to complete. The following steps are involved:\nSetup the OCI environment Setup of the Local Environment Access environment variables from the OCI Console Set Up the OCI Environment To set up the OCI environment, process these steps:\nGo to the OCI Marketplace listing for Oracle Backend for Spring Boot and Microservices.\nMarketplace Listing Choose the target compartment, agree to the terms, and click Launch Stack. This starts the wizard and creates the new stack. On the first page, choose a compartment to host your stack and select Next and Configure the variables for the infrastructure resources that this stack will create when you run the apply job for this execution plan.\nCreate Stack In the Backend as A Service Section, fill in the following configuration variables as needed and select Next:\nCompartment : Select the compartment where you want to install Oracle Backend for Spring Boot and Microservices.\nApplication Name (optional) : A random pet name that will be used as the application name if left empty.\nEdition : Select between COMMUNITY and STANDARD Edition.\nCOMMUNITY - for developers for quick start to testing Spring Boot Microservices with an integrated backend. Teams can start with the deployment and scale up as processing demand grows. Community support only. STANDARD - focused for pre-prod and production environments with an emphasis on deployment, scaling, and high availability. Oracle support is included with a Oracle Database support agreement. All features for developers are the same so start here if you’re porting an existing Spring Boot application stack and expect to get into production soon. This edition allows for additional Bring Your Own (BYO) capabilities. Existing Authorization Token (optional) - Enter an existing Authorization token. The token is used by the cluster to pull images from the Oracle Container Registry. If left empty the token will be created.\nWARNING: Deletion or expiration of the token will result in the failure to pull images later. Also you must have one free OCI auth token (note that the maximum is two per user). You can NOT use someone elses token.\nEdition BYO Network BYO Database Production Vault Registry Scanning Community Standard x x x x Compartment, Application and Edition If you check the checkbox Set Administrator Passwords in the Administrator Passwords section you have the option to fill in the following passwords (if not they are autogenerated):\nAPISIX Administrator Password (optional) : Leave blank to auto-generate.\nGrafana Administrator Password (optional) : Leave blank to auto-generate.\nORACTL Administrator Password optional) : Leave blank to auto-generate. This is the password for the obaas-admin user.\nORACTL User Password (optional) : Leave blank to auto-generate. This is the password for the obaas-user user.\nAdministrator Passwords (Standard Edition Only) If you check the checkbox Bring Your Own Virtual Cloud Network in the Network Options section you can use an existing Virtual Cloud Network. This is required to Bring Your Own Database (Standard Edition Only).\nNetwork Options - Standard Edition For more information on the network requirements and topology of the Oracle Backend for Spring Boot and Microservices including the options for Bring Your Own Virtual Cloud Network, please see the Networking documentation.\nIn the Kubernetes Cluster Options section, fill in the following for the OKE Cluster Options:\nPublic API Endpoint? : This option allows access to the OKE Control Plane API Endpoint from the internet (public IP). If not selected, access can only be from a private virtual cloud network (VCN). API Endpoint Access Control : Enter the CIDR block you want to give access to the Control Plane API. Default (and not recommended) is 0.0.0.0/0. Node Pool Workers : The number of Kubernetes worker nodes (virtual machines) attached to the OKE cluster. Node Pool Worker Shape : The shape of the node pool workers. Node Workers OCPU : The initial number of Oracle Compute Units (OCPUs) for the node pool workers. NOTE: Oracle recommends that you set API Endpoint Access Control to be as restrictive as possible\nCreate Stack OKE Options In the Load Balancers Options section, fill in the following for the Load Balancers options:\nEnable Public Load Balancer : This option allows access to the load balancer from the internet (public IP). If not selected, access can only be from a private VCN. Public Load Balancer Access Control : Enter the CIDR block you want to give access to the Load Balancer. Default (and not recommended) is 0.0.0.0/0. Public Load Balancer Ports Exposed : The ports exposed from the load balancer. Minimum bandwidth : The minimum bandwidth that the load balancer can achieve. Maximum bandwidth : The maximum bandwidth that the load balancer can achieve. NOTE: Oracle recommends that you set Public Load Balancer Access Control to be as restrictive as possible.\nLoad Balancer Options In the Database Options section, you can modify the following Database options.\nAutonomous Database Compute Model : Choose either ECPU (default) or OCPU compute model for the ADB. Autonomous Database Network Access : Choose the Autonomous Database network access. Choose between SECURE_ACCESS and PRIVATE_ENDPOINT_ACCESS. NOTE: This option currently cannot be changed later. SECURE_ACCESS - Accessible from outside the Kubernetes Cluster. Requires mTLS and can be restricted by IP or CIDR addresses. PRIVATE_ENDPOINT_ACCESS - Accessible only from inside the Kubernetes Cluster or via a Bastion service. Requires mTLS. ADB Access Control : Comma separated list of CIDR blocks from which the ADB can be accessed. This only applies if SECURE_ACCESS was chosen. Default (and not recommended) is 0.0.0.0/0. Autonomous Database CPU Core Count : Choose how many CPU cores will be elastically allocated. Allow Autonomous Database CPU Auto Scaling : Enable auto scaling for the ADB CPU core count (x3 ADB CPU). Autonomous Database Data Storage Size : Choose ADB Database Data Storage Size in gigabytes (ECPU) or terabytes (OCPU). Allow Autonomous Database Storage Auto Scaling : Allow the ADB storage to automatically scale. Autonomous Database License Model : The Autonomous Database license model. Create an Object Storage Bucket for ADB : Create a Object Storage bucket, with the appropriate access policies, for the ADB. NOTE: Oracle recommends that you restrict by IP or CIDR addresses to be as restrictive as possible.\nDatabase Options (Standard Edition Only) If Bring Your Own Virtual Cloud Network has been selected in the Network Options section, then you have the option to Bring Your Own Database in the section Database Options.\nBring your Own Database Options - Standard Edition For more information on the Bring Your Own Database option for the Oracle Backend for Spring Boot and Microservices including the required values, please review the Database documentation.\n(Standard Edition Only) If you check the checkbox Enable Vault in Production Mode in the section Vault Options you will be installing HashiCorp in Production mode otherwise the HashiCorp Vault be installed in Development mode.\nFill in the following Vault options. You have the option of creating a new OCI Vault or using an existing OCI Vault. The OCI Vault is only used in Production mode to auto-unseal the HashiCorp Vault (see documentation \u0026hellip;) Fill in the following information if you want to use an existing OCI Vault:\nVault Compartment (Optional) : Select a compartment for the OCI Vault.\nExisting Vault (Optional) : Select an existing OCI Vault. If not selected a new OCI Vault be created.\nExisting Vault Key (Optional) : Select an existing OCI Vault key. If not selected a new OCI Vault Key will be created.\nHashiCorp Vault Options - Standard Edition Warning Never run a Development mode HashiCorp Vault Server in a production environment. It is insecure and will lose data on every restart (since it stores data in-memory). It is only intended for development or experimentation. (Standard Edition Only) If you check the checkbox Enable Container Registry Vulnerability Scanning in the section Additional Options you will enable the automatic Vulnerability Scanning on images stored in the Oracle Container Registry.\nCreate Stack Additional Options - Standard Edition Now you can review the stack configuration and save the changes. Oracle recommends that you do not check the Run apply option. This gives you the opportunity to run the \u0026ldquo;plan\u0026rdquo; first and check for issues. Click Create\nCreate Stack Wizard Config Review Apply the stack.\nAfter you create the stack, you can test the plan, edit the stack, and apply or destroy the stack.\nOracle recommends that you test the plan before applying the stack in order to identify any issues before you start creating resources. Testing a plan does not create any actual resources. It is just an exercise to tell you what would happen if you did apply the stack.\nYou can test the plan by clicking on Plan and reviewing the output. You can fix any issues (for example, you may find that you do not have enough quota for some resources) before proceeding.\nCreate Stack Plan When you are happy with the results of the test, you can apply the stack by clicking on Apply. This creates your Oracle Backend as a Service and Microservices for a Spring Cloud environment. This takes about 20 minutes to complete. Much of this time is spent provisioning the Kubernetes cluster, worker nodes, database and all the included services. You can watch the logs to follow the progress of the operation.\nCreate Stack Apply The OCI Resource Manager applies your stack and generates the execution logs. The apply job takes approximately 45 minutes.\nCreate Stack Apply Logs When the Apply job finishes you can collect the OKE access information by clicking on Outputs.\nCreate Stack Outputs Click on Copy for the variable named kubeconfig_cmd. Save this information because it is needed to access the OKE cluster.\nGet Kube Config Cmd Set Up the Local Machine To set up the local machine, process these steps:\nSet up cluster access.\nTo access a cluster, use the kubectl command-line interface that is installed (see the Kubernetes access) locally. If you have not already done so, do the following:\nInstall the kubectl command-line interface (see the kubectl documentation).\nGenerate an API signing key pair. If you already have an API signing key pair, go to the next step. If not:\na. Use OpenSSL commands to generate the key pair in the required P-Early-Media (PEM) format. If you are using Windows, you need to install Git Bash for Windows in order to run the commands. See How to Generate an API Signing Key.\nb. Copy the contents of the public key to the clipboard to paste the value into the Console later.\nAdd the public key value of the API signing key pair to the User Settings for your user name. For example:\na. In the upper right corner of the OCI Console, open the Profile menu (User menu symbol) and click User Settings to view the details.\nb. Click Add Public Key.\nc. Paste the value of the public key into the window and click Add.\nThe key is uploaded and its fingerprint is displayed (for example, d1:b2:32:53:d3:5f:cf:68:2d:6f:8b:5f:77:8f:07:13).\nInstall and configure the Oracle Cloud Infrastructure CLI. For example:\na. Install the Oracle Cloud Infrastructure CLI version 2.6.4 (or later). See Quickstart.\nb. Configure the Oracle Cloud Infrastructure CLI. See Configuring the CLI.\nInstall the Oracle Backend for Spring Boot and Microservices command-line.\nThe Oracle Backend for Spring Boot and Microservices command-line interface, oractl, is available for Linux and Mac systems. Download the binary that you want from the Releases page and add it to your PATH environment variable. You can rename the binary to remove the suffix.\nIf your environment is a Linux or Mac machine, run chmod +x on the downloaded binary. Also, if your environment is a Mac, run the following command. Otherwise, you get a security warning and the CLI does not work:\nsudo xattr -r -d com.apple.quarantine \u0026lt;downloaded-file\u0026gt;\nAccess information and passwords from the OCI Console You can get the necessary access information from the OCI COnsole:\nOKE Cluster Access information e.g. how to generate the kubeconfig information. Oracle Backend for Spring Boot and Microservices Passwords. The assigned passwords (either auto generated or provided by the installer) can be viewed in the OCI Console (ORM homepage). Click on Application Information in the OCI ORM Stack.\nAccess Information You will presented with a screen with the access information and passwords. NOTE: The passwords can also be accessed from the k8s secrets.\nDetailed Access Information ","description":"Oracle Backend for Spring Boot and Microservices is available in the OCI Marketplace.\nPrerequisites Summary of Components Overview of the Setup Process Set Up the OCI Environment Set Up the Local Machine Access information and passwords from the OCI Console Prerequisites You must meet the following prerequisites to use Oracle Backend for Spring Boot and Microservices. You need:\nAn Oracle Cloud Infrastructure (OCI) account in a tenancy with sufficient quota to create the following:"},{"id":36,"href":"/microservices-datadriven/spring/platform/spring-admin/","title":"Spring Boot Admin","parent":"Platform Services","content":" View Application Details Using the Spring Boot Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications:\nExpose the Spring Boot Admin dashboard using this command:\nkubectl -n admin-server port-forward svc/admin-server 8989 Open the Spring Boot Admin dashboard URL: http://localhost:8989\nSpring Admin DashboardI On the dashboard you will see all the internal services registered with Eureka. If you have deployed the sample application CloudBank or done the LiveLab for Oracle Backend for Spring Boot and Microservices you will see those services.\nIf you click (expand) an application and click on the instance of service you will details about the service instance, metrics, configuration, and so on,\nSpring Admin Service Details ","description":"View Application Details Using the Spring Boot Admin Dashboard Spring Boot Admin is a web application used for managing and monitoring Spring Boot applications. Applications are discovered from the service registry. Most of the information displayed in the web user interface comes from the Spring Boot Actuator endpoints exposed by the applications:\nExpose the Spring Boot Admin dashboard using this command:\nkubectl -n admin-server port-forward svc/admin-server 8989 Open the Spring Boot Admin dashboard URL: http://localhost:8989"},{"id":37,"href":"/microservices-datadriven/spring/platform/config/","title":"Spring Config Server","parent":"Platform Services","content":"Oracle Backend for Spring Boot and Microservices includes Spring Cloud Config which provides server- and client-side support for externalized configurations in a distributed system. The Spring Cloud Config server provides a central place to manage external properties for applications across all environments.\nThe Spring Cloud Config server is pre-configured to work with the Spring Boot Eureka service registry, configured to store the Configuration in the Oracle Autonomous Database to support labeled versions of configuration environments as well as being accessible to a wide range of tools for managing the content. More details can be found here: (Spring Cloud Config Documentation).\nManaging Config Server Data Config Server REST API endpoints overview Config Server REST API endpoints examples Re-create test data Overview When building applications using Spring Config Server, the Spring Cloud Config client\u0026rsquo;s application.yaml configuration file must include access information to the deployed Spring Config Server:\nspring: application: name: \u0026lt;application name\u0026gt; config: import: optional:configserver:${config.server.url} cloud: config: label: \u0026lt;optional\u0026gt; profile: \u0026lt;optional\u0026gt; username: \u0026lt;A user with the role ROLE_USER\u0026gt; password: \u0026lt;password\u0026gt; You also need to add the following dependency to your Spring Boot application pom.xml:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; The configuration is stored in the CONFIGSERVER schema in the PROPERTIES table. Managing the data for the Spring Cloud Config server should be done using the CLI or the REST API endpoints. If you prefer, you can also work directly with the CONFIGSERVER.PROPERTIES table in the database. How to access the database is documented here, (Accessing the database).\nDuring setup of Oracle Backend for Spring Boot and Microservices, the following data is loaded into CONFIGSERVER.PROPERTIES. This data can be deleted.\n| APPLICATION | PROFILE | LABEL | PROP_KEY | VALUE |-----------------|----------------|----------|---------------------|-----------------------------------| | atael | dev | latest | test-property | This is the test-property value | | atael | dev | latest | test-property-2 | This is the test-property-2 value | | application-a | production | 12c | db-name | databasename-a-prod | | application-a | production | 12c | db-connection | connectionstring-a-prod | | application-a | development | 23cbeta | db-dev-name | databasename-a-dev | | application-a | development | 23cbeta | db-dev-connection | connectionstring-a-dev | | application-b | production | 19c | db-name | databasename-b-prod | | application-b | production | 19c | db-connection | connectionstring-b-prod | | application-b | development | 23cbeta | db-dev-name | databasename-b-dev | | application-b | development | 23cbeta | db-dev-connection | connectionstring-b-dev | | application-c | secret | 23.4 | json-db | 23c-json-db | | application-c | secret | 23.4 | json-sdb-conn | 23c-mongo-conn | | application-c | secret | 23.4 | txeventq | 23c-conn-string | | application-c | secret | 23.4 | txeventq | 23c-kafka-name | Managing Config Server Data Maintaining the Config Servers information can be done using the following methods:\nOracle Backend for Microservices CLI, oractl. REST API endpoints exposed via obaas-admin and config-server services. Config Server REST API endpoints overview The following REST API endpoints are available to the Config Server entries. The table lists which minimum required role is needed to perform the operation. \u0026lsquo;N/A\u0026rsquo; in the following table indicates that the endpoint does not require authentication to be accessed.\nEnd point Method Description Minimum Required Role /srv/config/all GET Get all distinct properties for a service (application) N/A /srv/config/properties GET Get all distinct properties with filters (see examples) N/A /srv/config/properties/add POST Create properties from a file ROLE_USER /srv/config/property/add POST Create a property ROLE_USER /srv/config/property/update PUT Update a property ROLE_USER /srv/config/properties/delete DELETE Delete properties with filters (see examples) ROLE_ADMIN Config Server REST API endpoints examples In all of the following examples, replace \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; with your username and password when necessary. (Getting User information). The examples are using curl to interact with the REST API endpoints. This also requires an open tunnel on port 8080 to either the config-server or obaas-admin service. Use the following command to start a tunnel to the config-server service:\nkubectl port-forward -n config-server svc/config-server 8080 The output will be slightly different when using a tunnel to obaas-admin. The data will be included in the \u0026quot;body\u0026quot; section.\n/srv/config/all Get all distinct application services:\ncurl -s http://localhost:8080/srv/config/all Example of data returned:\n[ { \u0026#34;name\u0026#34;: \u0026#34;application-a\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;application-b\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;application-c\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;\u0026#34; }, { \u0026#34;name\u0026#34;: \u0026#34;atael\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;\u0026#34; } ] /srv/config/all?service-profile=\u0026lt;profile-name\u0026gt; Get all distinct services filtered on profile (service-profile):\ncurl -s http://localhost:8080/srv/config/all\\?service-profile\\=dev Example of data returned:\n[ { \u0026#34;name\u0026#34;: \u0026#34;atael\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;latest\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;dev\u0026#34; } ] /srv/config/properties?service-name=\u0026lt;service-name\u0026gt; Get all properties for a service-name (application):\ncurl -s http://localhost:8080/srv/config/properties\\?service-name\\=application-a Example of data returned:\n[ { \u0026#34;id\u0026#34;: 3, \u0026#34;application\u0026#34;: \u0026#34;application-a\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;12c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;databasename-a-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; }, { \u0026#34;id\u0026#34;: 4, \u0026#34;application\u0026#34;: \u0026#34;application-a\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;12c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-connection\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;connectionstring-a-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; }, { \u0026#34;id\u0026#34;: 5, \u0026#34;application\u0026#34;: \u0026#34;application-a\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;development\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;23cbeta\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-dev-name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;databasename-a-dev\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; }, { \u0026#34;id\u0026#34;: 6, \u0026#34;application\u0026#34;: \u0026#34;application-a\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;development\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;23cbeta\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-dev-connection\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;connectionstring-a-dev\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; } ] /srv/config/properties?service-name=\u0026lt;service-name\u0026gt;\u0026amp;service-label=\u0026lt;service-label\u0026gt; Get all properties for a service-name (application) filtered on service-label (label):\ncurl -s http://localhost:8080/srv/config/properties\\?service-name\\=application-b\\\u0026amp;service-label\\=19c Example of data returned:\n[ { \u0026#34;id\u0026#34;: 7, \u0026#34;application\u0026#34;: \u0026#34;application-b\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;19c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;databasename-b-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; }, { \u0026#34;id\u0026#34;: 8, \u0026#34;application\u0026#34;: \u0026#34;application-b\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;19c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-connection\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;connectionstring-b-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; } ] /srv/config/properties?service-name=\u0026lt;service-name\u0026gt;\u0026amp;service-label=\u0026lt;service-label\u0026gt;\u0026amp;service-profile=\u0026lt;service-profile\u0026gt; Get all properties for a service-name (application) filtered on service-label (label) and service-profile (profile):\ncurl -s http://localhost:8080/srv/config/properties\\?service-name\\=application-b\\\u0026amp;service-label\\=19c\\\u0026amp;service-profile\\=production Example of data returned:\n[ { \u0026#34;id\u0026#34;: 7, \u0026#34;application\u0026#34;: \u0026#34;application-b\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;19c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;databasename-b-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; }, { \u0026#34;id\u0026#34;: 8, \u0026#34;application\u0026#34;: \u0026#34;application-b\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;production\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;19c\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;db-connection\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;connectionstring-b-prod\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; } ] /srv/config/properties?service-name=\u0026lt;service-name\u0026gt;\u0026amp;service-label=\u0026lt;service-label\u0026gt;\u0026amp;service-profile=\u0026lt;service-profile\u0026gt;\u0026amp;property-key=\u0026lt;property-key\u0026gt; Get all properties for a service-name (application) filtered on service-label (label), service-profile (profile) and property-key (prop_key):\ncurl -s http://localhost:8080/srv/config/properties\\?service-name\\=application-c\\\u0026amp;service-label\\=23.4\\\u0026amp;service-profile\\=secret\\\u0026amp;property-key\\=txeventq Example of data returned:\n[ { \u0026#34;id\u0026#34;: 14, \u0026#34;application\u0026#34;: \u0026#34;application-c\u0026#34;, \u0026#34;profile\u0026#34;: \u0026#34;secret\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;23.4\u0026#34;, \u0026#34;propKey\u0026#34;: \u0026#34;txeventq\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;23c-kafka-name\u0026#34;, \u0026#34;createdOn\u0026#34;: \u0026#34;2023-10-19T16:50:07.000+00:00\u0026#34;, \u0026#34;createdBy\u0026#34;: \u0026#34;ADMIN\u0026#34; } ] /srv/config/property/add Create a property:\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X POST \\ -d \u0026#34;service-name=application-d\u0026amp;service-label=1.0\u0026amp;service-profile=AI\u0026amp;property-key=url-to-host\u0026amp;property-value=hostname\u0026#34; \\ http://localhost:8080/srv/config/property/add Successful creation of a property returns:\nProperty added successfully. /srv/config/property/update Update a property:\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X PUT \\ -d \u0026#34;service-name=application-d\u0026amp;service-label=1.0\u0026amp;service-profile=AI\u0026amp;property-key=url-to-host\u0026amp;property-value=new-hostname\u0026#34; \\ http://localhost:8080/srv/config/property/update Successful update of a property returns:\nProperty successfully modified. /srv/config/properties/delete?service-name\u0026lt;service-name\u0026gt; Delete all properties from a service (application):\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X DELETE http://localhost:8080/srv/config/properties/delete\\?service-name\\=atael Successful deletion of properties returns:\nProperties successfully deleted. /srv/config/delete?service-profile=\u0026lt;profile-name\u0026gt;\u0026amp;service-profile=\u0026lt;service-profile\u0026gt; Delete all properties with a service profile:\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X DELETE http://localhost:8080/srv/config/properties/delete\\?service-name\\=application-d\\\u0026amp;service-profile\\=AI Successful deletion of properties returns:\nProperties successfully deleted. /srv/config/delete?service-profile=\u0026lt;profile-name\u0026gt;\u0026amp;service-profile=\u0026lt;service-profile\u0026gt;\u0026amp;service-label=\u0026lt;service-label\u0026gt; Delete all properties from a service with a profile and a label:\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X DELETE http://localhost:8080/srv/config/properties/delete\\?service-name\\=application-a\\\u0026amp;service-profile\\=development\\\u0026amp;service-label\\=12c Successful deletion of properties returns:\nProperties successfully deleted. /srv/config/delete?service-profile=\u0026lt;profile-name\u0026gt;\u0026amp;service-profile=\u0026lt;service-profile\u0026gt;\u0026amp;service-label=\u0026lt;service-label\u0026gt;\u0026amp;property-key=\u0026lt;property-key\u0026gt; Delete all properties from a service with a profile and a label:\ncurl -u \u0026lt;username\u0026gt;:\u0026lt;password\u0026gt; -s -X DELETE http://localhost:8080/srv/config/properties/delete\\?service-name\\=application-b\\\u0026amp;service-profile\\=development\\\u0026amp;service-label\\=23cbeta\\\u0026amp;property-key\\=db-dev-name Successful deletion of properties returns:\nProperties successfully deleted. Re-create test data The Config Server data can be created using the following SQL statements:\nINSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;atael\u0026#39;,\u0026#39;dev\u0026#39;,\u0026#39;latest\u0026#39;,\u0026#39;test-property\u0026#39;,\u0026#39;This is the test-property value\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;atael\u0026#39;,\u0026#39;dev\u0026#39;,\u0026#39;latest\u0026#39;,\u0026#39;test-property-2\u0026#39;,\u0026#39;This is the test-property-2 value\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-a\u0026#39;,\u0026#39;production\u0026#39;,\u0026#39;12c\u0026#39;,\u0026#39;db-name\u0026#39;,\u0026#39;databasename-a-prod\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-a\u0026#39;,\u0026#39;production\u0026#39;,\u0026#39;12c\u0026#39;,\u0026#39;db-connection\u0026#39;,\u0026#39;connectionstring-a-prod\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-a\u0026#39;,\u0026#39;development\u0026#39;,\u0026#39;23cbeta\u0026#39;,\u0026#39;db-dev-name\u0026#39;,\u0026#39;databasename-a-dev\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-a\u0026#39;,\u0026#39;development\u0026#39;,\u0026#39;23cbeta\u0026#39;,\u0026#39;db-dev-connection\u0026#39;,\u0026#39;connectionstring-a-dev\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-b\u0026#39;,\u0026#39;production\u0026#39;,\u0026#39;19c\u0026#39;,\u0026#39;db-name\u0026#39;,\u0026#39;databasename-b-prod\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-b\u0026#39;,\u0026#39;production\u0026#39;,\u0026#39;19c\u0026#39;,\u0026#39;db-connection\u0026#39;,\u0026#39;connectionstring-b-prod\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-b\u0026#39;,\u0026#39;development\u0026#39;,\u0026#39;23cbeta\u0026#39;,\u0026#39;db-dev-name\u0026#39;,\u0026#39;databasename-b-dev\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-b\u0026#39;,\u0026#39;development\u0026#39;,\u0026#39;23cbeta\u0026#39;,\u0026#39;db-dev-connection\u0026#39;,\u0026#39;connectionstring-b-dev\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-c\u0026#39;,\u0026#39;secret\u0026#39;,\u0026#39;23.4\u0026#39;,\u0026#39;json-db\u0026#39;,\u0026#39;23c-json-db\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-c\u0026#39;,\u0026#39;secret\u0026#39;,\u0026#39;23.4\u0026#39;,\u0026#39;json-sdb-conn\u0026#39;,\u0026#39;23c-mongo-conn\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-c\u0026#39;,\u0026#39;secret\u0026#39;,\u0026#39;23.4\u0026#39;,\u0026#39;txeventq\u0026#39;,\u0026#39;23c-conn-string\u0026#39;); INSERT INTO CONFIGSERVER.PROPERTIES (APPLICATION, PROFILE, LABEL, PROP_KEY, VALUE) VALUES (\u0026#39;application-c\u0026#39;,\u0026#39;secret\u0026#39;,\u0026#39;23.4\u0026#39;,\u0026#39;txeventq\u0026#39;,\u0026#39;23c-kafka-name\u0026#39;); ","description":"Oracle Backend for Spring Boot and Microservices includes Spring Cloud Config which provides server- and client-side support for externalized configurations in a distributed system. The Spring Cloud Config server provides a central place to manage external properties for applications across all environments.\nThe Spring Cloud Config server is pre-configured to work with the Spring Boot Eureka service registry, configured to store the Configuration in the Oracle Autonomous Database to support labeled versions of configuration environments as well as being accessible to a wide range of tools for managing the content."},{"id":38,"href":"/microservices-datadriven/spring/platform/soc/","title":"Spring Operations Center","parent":"Platform Services","content":"Oracle Backend for Spring Boot and Microservices version includes \u0026ldquo;Spring Operations Center\u0026rdquo;. More capabilities will be added to this feature in future releases.\nThe Spring Operations Center provides a web user interface to manage the Oracle Backend for Spring Boot and Microservices. This release includes the following capabilities:\nView details about the configuration and health of the environment Manage and deploy workloads (Spring Boot applications) deployed in the environment Easy one-click access to Grafana dashboards for applications Manage users and roles defined in the Spring Authorization Server included in the environment Easy one-click access to Grafana dashboards for the Kubernetes cluster, the applications and the Oracle Database Collect diagnostic data for support Note: More capabilities will be added to this feature in future releases.\nAccessing Spring Operations Center The Dashboard Manage Namespaces Manage Workloads Manage Identity Accessing Spring Operations Center To access the Spring Operations Center, obtain the public IP address for your environment using this command:\nkubectl -n ingress-nginx get service ingress-nginx-controller The output will be similar to this:\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller LoadBalancer 10.96.172.148 xxx.xxx.xxx.xxx 80:31393/TCP,443:30506/TCP 158m Use the EXTERNAL-IP from the results and open a browser to https://xxx.xxx.xxx.xxx/soc to access the login page.\nNote: If you installed with self-signed certificates, which is the default, you will see a browser warning message and will have to click on \u0026ldquo;Accept risk\u0026rdquo; or similar. For information about replacing the self-signed certificate with a production certificate, refer to Transport Layer Security\nSOC Login Page Login using the obaas-admin user (or another user if you have created one) and the password that you set during installation. If you did not set a password, one was auto-generated for you and can be obtained with this command:\nkubectl get secret -n azn-server oractl-passwords -o jsonpath=\u0026#39;{.data.admin}\u0026#39; | base64 -d; echo After logging in, you will see the SOC Dashboard.\nThe Dashboard The Spring Operations Center Dashboard provides information about the overall state of the environment including:\nThe version and platform the environment is running on The configuration and sizing of the Kubernetes cluster The configuration and sizing of the Database instance Easy one-click access to Grafana dashboards to see detailed status of the Kubernetes cluster and Database instance The overall system health status How many applications are deployed in the environment SOC Dashboard Manage Namespaces The Manage Namespaces screen is accessible from the Workloads menu, and allows you to view and manage the namespaces that are configured for Spring Boot application deployments. Note that this does not show you all namespaces in the Kubernetes cluster, just those that have be specifically configured for Spring Boot workloads, meaning they have the necessary secrets for pulling images, accessing the database, and so on.\nSOC Manage Namespaces screen Clicking on a namespace will allow you to drill down into that namespace and see the workloads (Spring Boot applications) deployed there.\nManage Workloads The Manage Workloads screen shows the workloads (Spring Boot applications) deployed in a specific namespace, including the status of each workload, and how many replicas are currently running and desired.\nSOC Manage Workloads screen You can click on the \u0026ldquo;open\u0026rdquo; link in the Dashboard column to open the Spring Boot Statistics Grafana dashboard for any workload listed in the table. Note that you may need to authenticate to Grafana the first time.\nGrafana Dashboard for Workload More details of this dashboard can be found here.\nManage Identity The Manage Identity screen is accessible from the Security menu and allows you to view information about the users and roles defined in the Spring Authorization Server included in the platform.\nSOC Manage Identity screen Collect Diagnostic Data The Collect Diagnostic Data is accessible from the Settings Menu and allows you to collect and download diagnostic data about your installation and platform. Verify its contents for any sensitive information before submitting with any support request.\nDiagnostic Data ","description":"Oracle Backend for Spring Boot and Microservices version includes \u0026ldquo;Spring Operations Center\u0026rdquo;. More capabilities will be added to this feature in future releases.\nThe Spring Operations Center provides a web user interface to manage the Oracle Backend for Spring Boot and Microservices. This release includes the following capabilities:\nView details about the configuration and health of the environment Manage and deploy workloads (Spring Boot applications) deployed in the environment Easy one-click access to Grafana dashboards for applications Manage users and roles defined in the Spring Authorization Server included in the environment Easy one-click access to Grafana dashboards for the Kubernetes cluster, the applications and the Oracle Database Collect diagnostic data for support Note: More capabilities will be added to this feature in future releases."},{"id":39,"href":"/microservices-datadriven/spring/tags/","title":"Tags","parent":"Oracle Backend for Spring Boot and Microservices","content":"","description":""},{"id":40,"href":"/microservices-datadriven/spring/get-help/troubleshooting/","title":"Troubleshooting","parent":"Get Help","content":"If experiencing issues with the Oracle Backend for Spring Boot and Microservices; check here for known issues and resolutions.\nORA-28000: The account is locked Access the database and determine which account has been locked by running the following SQL:\nSELECT USERNAME, LOCK_DATE, PROFILE FROM DBA_USERS WHERE ACCOUNT_STATUS=\u0026#39;LOCKED\u0026#39; AND AUTHENTICATION_TYPE=\u0026#39;PASSWORD\u0026#39; AND ORACLE_MAINTAINED\u0026lt;\u0026gt;\u0026#39;Y\u0026#39;; Unlock the account by running: ALTER USER \u0026lt;USERNAME\u0026gt; ACCOUNT UNLOCK;\nIf the account continues to be locked, evaluate the password being used by the service and changes appropriately.\n","description":"If experiencing issues with the Oracle Backend for Spring Boot and Microservices; check here for known issues and resolutions.\nORA-28000: The account is locked Access the database and determine which account has been locked by running the following SQL:\nSELECT USERNAME, LOCK_DATE, PROFILE FROM DBA_USERS WHERE ACCOUNT_STATUS=\u0026#39;LOCKED\u0026#39; AND AUTHENTICATION_TYPE=\u0026#39;PASSWORD\u0026#39; AND ORACLE_MAINTAINED\u0026lt;\u0026gt;\u0026#39;Y\u0026#39;; Unlock the account by running: ALTER USER \u0026lt;USERNAME\u0026gt; ACCOUNT UNLOCK;\nIf the account continues to be locked, evaluate the password being used by the service and changes appropriately."},{"id":41,"href":"/microservices-datadriven/spring/uninstall/","title":"Uninstall","parent":"Oracle Backend for Spring Boot and Microservices","content":"To remove Oracle Backend for Spring Boot and Microservices, navigate to Developer Services then Resource Manager - Stacks in the Oracle Cloud Infrastructure Console (OCI Console) main menu. Ensure that you are in the correct region and compartment where you installed the Oracle Backend as a Service (OBaaS).\nClick on the link to open the detailed view for the Oracle Backend for Spring Boot and Microservices instance and click Destroy to clean up resources. For example:\nOCI Stack Destroy The OCI Resource Manager uses the stack definition to destroy all resources. For example:\nOCI Stack Destroy Logs The destroy job takes about 20 minutes to complete. Review the logs when the job is done to ensure that it completed successfully. If there are any errors, run the Destroy job again.\n","description":"To remove Oracle Backend for Spring Boot and Microservices, navigate to Developer Services then Resource Manager - Stacks in the Oracle Cloud Infrastructure Console (OCI Console) main menu. Ensure that you are in the correct region and compartment where you installed the Oracle Backend as a Service (OBaaS).\nClick on the link to open the detailed view for the Oracle Backend for Spring Boot and Microservices instance and click Destroy to clean up resources."},{"id":42,"href":"/microservices-datadriven/spring/upgrade/","title":"Upgrade","parent":"Oracle Backend for Spring Boot and Microservices","content":"The world of Microservices moves fast. In order to keep up with new software versions and provide additional features, regular updates and patches are provided for the Oracle Backend for Spring Boot and Microservices.\nDepending on the original installation method and the state of your infrastructure, these patches and upgrades can either be preformed in-place or out-of-place. Oracle recommends, despite which option you choose, to have a backup of your applications and database in order to recover from any unintentional loss.\nThere are various methods to perform an upgrade including:\nIn-Place Marketplace Upgrade Out-of-Place Marketplace Upgrade In-Place Custom Upgrade Out-of-Place Custom Upgrade In-Place Marketplace Upgrade The in-place Marketplace upgrade can be performed when there has been no external modifications of the infrastructure after the original installation of the Marketplace stack; or you wish to reconcile the infrastructure back to the delivered Marketplace infrastructure.\nThe in-place method will both modify the infrastructure and patch/upgrade the delivered Oracle Backend for Spring Boot and Microservices applications.\nThis method is recommended for development deployments, or after testing the upgrade using the Out-of-Place Upgrade for production deployments.\nWarning: to ensure no unintentional outage or infrastructure destruction; do not directly apply the upgrade stack. Plan and review the actions that will be performed prior to its application. If in doubt about the potential loss of data or infrastructure, opt for the Out-of-Place method.\nDownload the Marketplace Upgrade Stack Visit the Release page and download the marketplace_upgrade.zip file for the version you are upgrading to.\nUpdate the Current Stack In Oracle Cloud Infrastructure, navigate to Developer Services -\u0026gt; Stacks. Ensure the region and compartment is set to the location where the Marketplace stack was first installed, and select the stack.\nEdit the Stack, and upload the marketplace_upgrade.zip file.\nClick through the wizard and ensure the \u0026ldquo;Apply\u0026rdquo; checkbox is not ticked. Save Changes.\nPlan the Upgrade Run the plan Job and review the proposed actions.\nGenerally, any proposed destruction of the Database or Kubernetes cluster should be avoided unless you are confident that you can recover both your applications and data. If the plan shows the destruction of these resources, the Out-of-Place Upgrade should be used as an alternative.\nApply the Upgrade Out-of-Place Marketplace Upgrade The out-of-place Marketplace upgrade can be used when manual changes to the original infrastructure have been made after the initial installation of the Oracle Backend for Spring Boot and Microservices. It is the recommended Marketplace method for production installations as it allows you to test the upgrade prior to go live, while leaving the old infrastructure in place for rollbacks.\nThe out-of-place method deliver new infrastructure and Oracle Backend for Spring Boot and Microservices applications. You will need to migrate your applications to the new platform.\nFollow the instructions to install the latest Marketplace version.\nClone Database Depending on the Oracle Database that was used during the initial installation, the method of cloning the database will vary. For example:\nOracle Autonomous Database Oracle BaseDB On-Premises options include: PDB Clone RMAN Duplicate Datapump Load Custom Applications Once the database has been cloned, re-load your applications into the new Kubernetes environment.\nClean Up Old Installation Follow the uninstall guide to clean up the old Marketplace installation.\nCustom In-Place Upgrade The Custom In-Place upgrade can be applied to any existing installation of the Oracle Backend for Spring Boot and Microservices. It will not modify any infrastructure and only apply changes to existing and install new Oracle Backend for Spring Boot and Microservices applications.\nDownload the Latest Installation Visit the Release page and download the custom-ebaas_latest.zip file for the version you are upgrading to.\nUnzip the custom-ebaas_latest.zip file.\nDefine the Infrastructure From the original installation source, copy the following infrastructure definitions, where they exist, to the new release source:\nansible/roles/common/vars/main.yaml ansible/roles/registry/vars/main.yaml ansible/roles/database/vars/main.yaml ansible/roles/oci/vars/main.yaml ansible/roles/azure/vars/main.yaml Perform the Upgrade From the unzipped source, run the following commands:\n./setup_ansible.sh source activate.env ansible-playbook ansible/k8s_apply.yaml -t full Custom Out-of-Place Upgrade The custom out-of-place upgrade assumes you have out-of-place infrastructure to install into. The existing Oracle Database should be cloned for use with the new version.\nDownload the Latest Installation Visit the Release page and download the custom-ebaas_latest.zip file for the version you are upgrading to.\nUnzip the custom-ebaas_latest.zip file.\nClone Database Depending on the Oracle Database that was used during the initial installation, the method of cloning the database will vary. For example:\nOracle Autonomous Database Oracle BaseDB On-Premises options include: PDB Clone RMAN Duplicate Datapump Update the Infrastructure From the original installation source, copy the following infrastructure definitions, where they exist, to the new release source:\nansible/roles/common/vars/main.yaml ansible/roles/registry/vars/main.yaml ansible/roles/database/vars/main.yaml ansible/roles/oci/vars/main.yaml ansible/roles/azure/vars/main.yaml Update the files to point to the new out-of-place infrastructure.\nPerform the Upgrade From the unzipped source, run the following commands:\n./setup_ansible.sh source activate.env ansible-playbook ansible/k8s_apply.yaml -t full Load Custom Applications Once the upgrade is complete, re-load your applications into the new Kubernetes environment.\n","description":"The world of Microservices moves fast. In order to keep up with new software versions and provide additional features, regular updates and patches are provided for the Oracle Backend for Spring Boot and Microservices.\nDepending on the original installation method and the state of your infrastructure, these patches and upgrades can either be preformed in-place or out-of-place. Oracle recommends, despite which option you choose, to have a backup of your applications and database in order to recover from any unintentional loss."},{"id":43,"href":"/microservices-datadriven/spring/platform/conductor/","title":"Workflow","parent":"Platform Services","content":"Oracle Backend for Spring Boot and Microservices includes the Netflix Conductor Server. Conductor is a popular workflow solution that works with Spring Boot Microservices and Oracle Database.\nDocumentation on Conductor can be found here:\nConductor OSS Documentation Accessing the Server User Interface (UI) Expose the Oracle Spring Cloud Admin server that the CLI calls by using this command:\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor server UI at this URL:\nhttp://localhost:8080 Access the Swagger documentation at this URL:\nhttp://localhost:8080/swagger-ui/index.html API Specification The API Specification can be found here:\nAPI Specification ","description":"Oracle Backend for Spring Boot and Microservices includes the Netflix Conductor Server. Conductor is a popular workflow solution that works with Spring Boot Microservices and Oracle Database.\nDocumentation on Conductor can be found here:\nConductor OSS Documentation Accessing the Server User Interface (UI) Expose the Oracle Spring Cloud Admin server that the CLI calls by using this command:\nkubectl port-forward services/conductor-server -n conductor-server 8080:8080 Access the Conductor server UI at this URL:"}]