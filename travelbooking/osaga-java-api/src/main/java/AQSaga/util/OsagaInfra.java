package AQSaga.util;

public class OsagaInfra
{
    static String[] SQL;
    static final String createBEGINSAGAWRAPPER = "CREATE OR REPLACE PROCEDURE BEGINSAGAWRAPPER(   SAGANAME IN VARCHAR2,   SAGAID OUT VARCHAR2)IS     request JSON;BEGIN  SAGAID := dbms_saga.begin_saga(SAGANAME);END;";
    static String createEnrollParticipant;
    static final String DATA_PUMP_DIR = "DATA_PUMP_DIR";
    static final String GET_OBJECT_CWALLETSSO_DATA_PUMP_DIR = "BEGIN DBMS_CLOUD.GET_OBJECT(object_uri => ?, directory_name => ?); END;";
    static final String DROP_CREDENTIAL_SQL = "BEGIN DBMS_CLOUD.DROP_CREDENTIAL(credential_name => ?);END;";
    static final String CREATE_CREDENTIAL_SQL = " BEGIN  DBMS_CLOUD.CREATE_CREDENTIAL(  credential_name => ?,  username => ?,  password => ?  ); END;";
    static final String CREATE_DBLINK_SQL = "BEGIN DBMS_CLOUD_ADMIN.CREATE_DATABASE_LINK(db_link_name => ?,hostname => ?,port => ?,service_name => ?,ssl_server_cert_dn => ?,credential_name => ?,directory_name => ?);END;";
    static final String write_file_sql = "CREATE OR REPLACE PROCEDURE write_file(             directory_name   IN  VARCHAR2,             file_name        IN  VARCHAR2,             contents         IN  BLOB     )     IS     l_file      UTL_FILE.file_type;     l_data_len  INTEGER;     l_buffer    RAW(32000);     l_pos       INTEGER := 1;     l_amount    INTEGER := 32000;     BEGIN     l_data_len := DBMS_LOB.getlength(contents);     l_file := UTL_FILE.FOPEN(directory_name, file_name, 'wb', l_amount);     WHILE l_pos < l_data_len     LOOP       DBMS_LOB.read(contents, l_amount, l_pos, l_buffer);       UTL_FILE.PUT_RAW(l_file, l_buffer, TRUE);     l_pos := l_pos + l_amount;     END LOOP;     UTL_FILE.FCLOSE(l_file);     EXCEPTION     WHEN OTHERS THEN       UTL_FILE.FCLOSE(l_file);     RAISE;     END write_file;";
    
    static {
        (OsagaInfra.SQL = new String[16])[0] = "create table saga_message_broker$ (              id  RAW(16) not NULL,                       name VARCHAR2(128) not NULL,               owner VARCHAR2(128) not NULL,              broker_topic VARCHAR2(128),                 remote  NUMBER not NULL,                    CONSTRAINT SAGA$_MESSAGE_BROKER_PK primary key (id),              CONSTRAINT SAGA$_MESSAGE_BROKER_UNIQUE UNIQUE(name,remote) ) ";
        OsagaInfra.SQL[1] = "create table saga_participant$ (              id  RAW(16) not NULL,                             name VARCHAR2(128) not NULL,                     owner VARCHAR2(128) not NULL,                    type NUMBER not NULL,                                                                                                                                    broker_id  RAW(16) not NULL,                    coordinator_id   RAW(16),                         dblink_to_broker VARCHAR2(128),                  dblink_to_participant   VARCHAR2(128),                                                                    incoming_topic VARCHAR2(128) not NULL,               outgoing_topic VARCHAR2(128) not NULL,           callback_schema VARCHAR2(128),                  callback_package VARCHAR2(128),                participant_iscomplete NUMBER,                                                                            remote  NUMBER not NULL,                                                                                                                                                CONSTRAINT SAGA_PARTICIPANT$_PK primary key (id),              CONSTRAINT SAGA_PARTICIPANT$_UNIQUE UNIQUE(name,broker_id),              CONSTRAINT saga_participant_broker_constraint              FOREIGN KEY (broker_id)              REFERENCES SAGA_MESSAGE_BROKER$(ID) ON DELETE CASCADE ) ";
        OsagaInfra.SQL[2] = "create table saga$ (              id RAW(16) not NULL,                             saga_level  NUMBER not NULL,                                                                                                                         initiator   VARCHAR2(128),                      coordinator VARCHAR2(128),                      owner       VARCHAR2(128) not NULL,                 participant VARCHAR2(128) not NULL,                 duration NUMBER,                                 begin_time  TIMESTAMP WITH TIME ZONE not NULL,                end_time    TIMESTAMP WITH TIME ZONE,                         status  NUMBER,                                              CONSTRAINT SAGA$_PK primary key (id, participant) ) ";
        OsagaInfra.SQL[3] = "create table saga_finalization$ (              saga_id RAW(16) not NULL,                       participant VARCHAR2(128),                      txn_id RAW(16) not NULL,                       user#  NUMBER not NULL,                        escrow_obj# NUMBER not NULL,                  status  NUMBER not NULL,                   CONSTRAINT saga_finalization$_fk FOREIGN KEY(saga_id, participant)         REFERENCES saga$(ID, PARTICIPANT) ON DELETE CASCADE ) ";
        OsagaInfra.SQL[4] = "create table saga_participant_set$ (              saga_id RAW(16) not NULL,                          coordinator VARCHAR2(128) not NULL,                participant VARCHAR2(128) not NULL,                status NUMBER not NULL,                            join_time  TIMESTAMP WITH TIME ZONE,               completion_time TIMESTAMP WITH TIME ZONE   ) ";
        OsagaInfra.SQL[5] = "create table saga_secrets$ (              id RAW(16) not NULL,                              secret NUMBER not NULL,                             operation NUMBER not NULL,                          secret_time TIMESTAMP WITH TIME ZONE,          CONSTRAINT saga_secrets$_fk FOREIGN KEY(id)         REFERENCES saga_participant$(ID) ON DELETE CASCADE ) ";
        OsagaInfra.SQL[6] = "create or replace package dbms_saga_adm as procedure add_coordinator(coordinator_name IN varchar2 ,                           coordinator_schema IN varchar2                           DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                           storage_clause IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           dblink_to_coordinator IN varchar2 DEFAULT NULL);   procedure drop_coordinator(coordinator_name IN varchar2);   procedure add_participant(participant_name IN varchar2 ,                           participant_schema IN varchar2                           DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                           storage_clause IN varchar2 DEFAULT NULL,                           coordinator_name IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           callback_schema IN varchar2                           DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                           callback_package IN varchar2 DEFAULT NULL,                           dblink_to_participant IN varchar2 DEFAULT NULL);   procedure drop_participant(participant_name IN varchar2) ;  procedure add_broker(broker_name IN varchar2 ,                      broker_schema IN varchar2                      DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                      storage_clause IN varchar2 DEFAULT NULL);   procedure drop_broker(broker_name in varchar2);   procedure register_saga_callback(participant_name IN varchar2,                                  callback_schema IN varchar2                                  DEFAULT sys_context('USERENV','CURRENT_USER'),                                  callback_package IN varchar2) ; procedure notify_callback_coordinator(context RAW ,                                       reginfo sys.aq$_reg_info ,                                       descr sys.aq$_descriptor ,                                       payload RAW ,                                       payloadl NUMBER);  ROLLINGUNSUPPORTED          EXCEPTION; PRAGMA                      EXCEPTION_INIT(ROLLINGUNSUPPORTED, -45493) ; END dbms_saga_adm; ";
        OsagaInfra.SQL[7] = "create or replace package dbms_saga as  CMT_SAGA CONSTANT NUMBER := 1; ABRT_SAGA CONSTANT NUMBER := 2; REQUEST CONSTANT NUMBER := 4; RESPONSE CONSTANT NUMBER := 5; CMT_FAIL CONSTANT NUMBER := 6; ABRT_FAIL CONSTANT NUMBER := 7;  subtype saga_id_t IS RAW(16) ;  ROLLINGUNSUPPORTED          EXCEPTION; PRAGMA                      EXCEPTION_INIT(ROLLINGUNSUPPORTED, -45493);   function begin_saga(initiator_name IN VARCHAR2 ,                     timeout IN number DEFAULT 86400) return saga_id_t;  procedure enroll_participant(saga_id        IN saga_id_t,                              sender         IN VARCHAR2,                              recipient      IN VARCHAR2,                              coordinator    IN VARCHAR2,                              payload        IN JSON DEFAULT NULL);  function get_saga_id return saga_id_t;  procedure set_saga_id(saga_id IN saga_id_t);  procedure commit_saga(saga_participant IN VARCHAR2,                       saga_id IN saga_id_t,                       force IN boolean DEFAULT TRUE);  procedure rollback_saga(saga_participant IN VARCHAR2,                         saga_id IN saga_id_t,                         force IN boolean DEFAULT TRUE);  procedure forget_saga(saga_id IN saga_id_t);  procedure leave_saga(saga_id IN saga_id_t);  procedure after_saga(saga_id IN saga_id_t);  function is_incomplete(saga_id IN saga_id_t) return boolean;  function get_out_topic(entity_name IN varchar2) return varchar2;  procedure set_incomplete(saga_id IN saga_id_t);  procedure notify_callback_participant(context RAW,                                       reginfo sys.aq$_reg_info,                                       descr sys.aq$_descriptor,                                       payload RAW,                                       payloadl NUMBER);  procedure set_saga_sender(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                           sender IN varchar2);  procedure set_saga_recipient(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                              recipient IN varchar2);  procedure set_saga_opcode(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                           opcode IN NUMBER);  procedure set_saga_id(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                       saga_id IN RAW);  procedure set_saga_coordinator(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                                saga_coordinator IN VARCHAR2);  function get_saga_sender(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2;  function get_saga_recipient(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2;  function get_saga_opcode(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return NUMBER;  function get_saga_id(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return RAW;  function get_saga_coordinator(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2;  end dbms_saga; ";
        OsagaInfra.SQL[8] = "create or replace package dbms_saga_adm_sys  AS PARTICIPANT             CONSTANT NUMBER := 0; COORDINATOR             CONSTANT NUMBER := 1;  DBMS_LOCAL              CONSTANT NUMBER := 0; DBMS_REMOTE             CONSTANT NUMBER := 1;  INCOMPLETE              CONSTANT NUMBER := 0; COMPLETED               CONSTANT NUMBER := 1;  subtype saga_id_t IS RAW(16);  BROKER_MAX_STATE        CONSTANT NUMBER := 2; PARTICIPANTENTRYDONE    CONSTANT NUMBER := 7; BROKERENTRYDONE         CONSTANT NUMBER := 6; CALLBACKDONE            CONSTANT NUMBER := 5; PROPAGATIONDONE         CONSTANT NUMBER := 4; BROKERSUBDONE           CONSTANT NUMBER := 3; OUTBOUNDDONE            CONSTANT NUMBER := 2; INBOUNDDONE             CONSTANT NUMBER := 1; REGREMOTEDONE           CONSTANT NUMBER := 3; REGLOCALDONE            CONSTANT NUMBER := 2; REGCALLBACKDONE         CONSTANT NUMBER := 1;  CONNECT_BROKER          CONSTANT NUMBER := 1; DISCONNECT_BROKER       CONSTANT NUMBER := 2; UPDATE_CALLBACK         CONSTANT NUMBER := 3;  CREATEENTITY            CONSTANT NUMBER := 0; CREATEPACKAGE           CONSTANT NUMBER := 1;   procedure add_coordinator(coordinator_name IN varchar2 ,                           coordinator_schema IN varchar2,                           storage_clause IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           dblink_to_coordinator IN varchar2 DEFAULT NULL,                           current_user IN varchar2);  procedure drop_coordinator(coordinator_name IN varchar2);  procedure add_participant(participant_name IN varchar2 ,                           participant_schema IN varchar2,                           storage_clause IN varchar2 DEFAULT NULL,                           coordinator_name IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           callback_schema IN varchar2,                           callback_package IN varchar2 DEFAULT NULL,                           dblink_to_participant IN varchar2 DEFAULT NULL,                           current_user IN varchar2);  procedure drop_participant(participant_name IN varchar2);  procedure add_broker(broker_name IN varchar2 ,                      broker_schema IN varchar2,                      storage_clause IN varchar2 DEFAULT NULL,                      current_user IN varchar2);  procedure drop_broker(broker_name in varchar2);  procedure connectBrokerToInqueue(participant_id IN RAW,                                  entity_name_int IN varchar2 ,                                  entity_schema_int IN varchar2 ,                                  coordinatorOrParticipant IN number,                                  broker_id IN RAW,                                  coordinator_id IN RAW,                                  dblink_to_broker_int IN varchar2,                                  dblink_to_entity_int IN varchar2,                                  inbound_queue IN varchar2,                                  outbound_queue IN varchar2,                                  callback_schema_int IN varchar2 ,                                  callback_package_int IN varchar2 ,                                  participant_iscomplete IN number,                                  broker_schema_int IN varchar2 ,                                  broker_name_int IN varchar2,                                  saga_secret IN number);  procedure disconnectBrokerFromInqueue(entity_name_int IN varchar2 ,                                       entity_schema_int IN varchar2,                                       dblink_to_entity_int IN varchar2,                                       broker_schema_int IN varchar2,                                       broker_name_int IN varchar2,                                       dblink_to_broker IN varchar2,                                       entity_id IN RAW,                                       saga_secret IN number);  procedure register_saga_callback(participant_name IN varchar2,                                  callback_schema IN varchar2,                                  callback_package IN varchar2);  function uniqueEntityAtPDB(entity_name IN varchar2,                            broker_name IN varchar2,                            mailbox_schema IN varchar2,                            broker_pdb_link IN varchar2,                            entity_dblink IN varchar2) return boolean;  procedure getBrokerInfo(broker_id IN OUT RAW,                         broker_name IN OUT varchar2,                         broker_schema IN OUT varchar2,                         isCreate IN BOOLEAN);  procedure updateCallbackInfo(cbk_schema IN varchar2,                              cbk_package IN varchar2,                              p_status IN number,                              p_id IN RAW,                              saga_secret IN number);  function validateSecret(entity_id IN RAW,                         saga_operation IN NUMBER,                         saga_secret IN NUMBER) return boolean;  procedure process_notification(recipient IN varchar2,                                sender IN varchar2,                                deq_saga_id IN saga_id_t,                                opcode IN number,                                coordinator IN varchar2,                                req_res IN clob);  CONNECTTOBROKERFAILURE      EXCEPTION; PRAGMA                      EXCEPTION_INIT(CONNECTTOBROKERFAILURE, -20001); END dbms_saga_adm_sys; ";
        OsagaInfra.SQL[9] = "create or replace package dbms_saga_sys  AS  INITIATOR CONSTANT NUMBER := 0; PARTICIPANT CONSTANT NUMBER := 1;  JOINING CONSTANT NUMBER := -1; INITIATED CONSTANT NUMBER := 0; JOINED CONSTANT NUMBER := 0; FINALIZATION CONSTANT NUMBER := 1; COMMITED CONSTANT NUMBER := 2; ROLLEDBACK CONSTANT NUMBER := 3; COMMIT_FAILED CONSTANT NUMBER := 4; ROLLEDBACK_FAILED CONSTANT NUMBER := 5;  subtype saga_id_t IS RAW(16);  JOIN_SAGA CONSTANT NUMBER := 0; CMT_SAGA CONSTANT NUMBER := 1; ABRT_SAGA CONSTANT NUMBER := 2; ACK_SAGA CONSTANT NUMBER := 3; REQUEST CONSTANT NUMBER := 4; RESPONSE CONSTANT NUMBER := 5; CMT_FAIL CONSTANT NUMBER := 6; ABRT_FAIL CONSTANT NUMBER := 7;  JOIN_EXISTS CONSTANT NUMBER := -1; JOIN_SUCCESS CONSTANT NUMBER := 0; JOIN_SKIP CONSTANT NUMBER := 1;   ROLLINGUNSUPPORTED          EXCEPTION; PRAGMA                      EXCEPTION_INIT(ROLLINGUNSUPPORTED, -45493);   function begin_saga(initiator_name IN VARCHAR2 ,                     timeout IN number DEFAULT NULL,                     current_user IN VARCHAR2) return saga_id_t;  function join_saga_int(saga_id         IN  saga_id_t,                        initiator_name  IN  VARCHAR2,                        saga_initiator  IN  VARCHAR2,                        coordinator     IN  VARCHAR2,                        payload         IN  CLOB) return NUMBER;  procedure commit_saga(saga_participant IN VARCHAR2,                       saga_id IN saga_id_t,                       force IN boolean DEFAULT TRUE,                       current_user IN varchar2);  procedure rollback_saga(saga_participant IN VARCHAR2,                         saga_id IN saga_id_t,                         force IN boolean DEFAULT TRUE,                         current_user IN varchar2);  function get_out_topic(entity_name IN varchar2) return varchar2;  procedure process_notification(recipient IN varchar2,                                sender IN varchar2,                                saga_id IN saga_id_t,                                opcode IN number,                                coordinator IN varchar2,                                req_res IN clob);  end dbms_saga_sys; ";
        OsagaInfra.SQL[10] = "create or replace package dbms_saga_connect_int as   ROLLINGUNSUPPORTED          EXCEPTION; PRAGMA                      EXCEPTION_INIT(ROLLINGUNSUPPORTED, -45493);   procedure connectBrokerToInqueue(participant_id IN RAW,                                  entity_name_int IN varchar2 ,                                  entity_schema_int IN varchar2 ,                                  coordinatorOrParticipant IN number,                                  broker_id IN RAW,                                  coordinator_id IN RAW,                                  dblink_to_broker_int IN varchar2,                                  dblink_to_entity_int IN varchar2,                                  inbound_queue IN varchar2,                                  outbound_queue IN varchar2,                                  callback_schema_int IN varchar2 ,                                  callback_package_int IN varchar2 ,                                  participant_iscomplete IN number,                                  broker_schema_int IN varchar2 ,                                  broker_name_int IN varchar2,                                  saga_secret IN NUMBER);  procedure disconnectBrokerFromInqueue(entity_name_int IN varchar2 ,                                       entity_schema_int IN varchar2,                                       dblink_to_entity_int IN varchar2,                                       broker_schema_int IN varchar2,                                       broker_name_int IN varchar2,                                       dblink_to_broker IN varchar2,                                       entity_id IN RAW,                                       saga_secret IN NUMBER);  function uniqueEntityAtPDB(entity_name IN varchar2,                            broker_name IN varchar2,                            mailbox_schema IN varchar2,                            broker_pdb_link IN varchar2,                            entity_dblink IN varchar2) return boolean;  procedure getBrokerInfo(broker_id IN OUT RAW,                         broker_name IN OUT varchar2,                         broker_schema IN OUT varchar2,                         isCreate IN BOOLEAN);  procedure updateCallbackInfo(cbk_schema IN varchar2,                              cbk_package IN varchar2,                              p_status IN number,                              p_id IN RAW,                              saga_secret IN NUMBER);  function validateSecret(entity_id IN RAW,                         saga_operation IN NUMBER,                         saga_secret IN NUMBER) return boolean;  end dbms_saga_connect_int; ";
        OsagaInfra.SQL[11] = "create or replace package body dbms_saga_adm as  procedure write_trace(message IN varchar2,                       event IN binary_integer DEFAULT 10855,                       event_level IN binary_integer DEFAULT 1,                       time_info IN boolean DEFAULT FALSE);  procedure dump_trace(message IN varchar2,                      time_info IN boolean DEFAULT FALSE);   procedure add_broker(broker_name     IN VARCHAR2 ,                      broker_schema   IN VARCHAR2                      DEFAULT sys_context('USERENV', 'CURRENT_USER'),                      storage_clause  IN VARCHAR2 DEFAULT NULL) AS  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('ADD_BROKER : BEGIN ADD_BROKER');    dbms_saga_adm_sys.add_broker(                      broker_name => broker_name,                      broker_schema => broker_schema,                      storage_clause => storage_clause,                      current_user => sys_context('USERENV', 'CURRENT_USER'));    write_trace('ADD_BROKER : END ADD_BROKER');  END;  procedure add_coordinator(coordinator_name IN varchar2,                           coordinator_schema IN varchar2                           DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                           storage_clause IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           dblink_to_coordinator IN varchar2 DEFAULT NULL) as  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('ADD_COORDINATOR : BEGIN ADD_COORDINATOR');    dbms_saga_adm_sys.add_coordinator(                         coordinator_name => coordinator_name,                         coordinator_schema => coordinator_schema,                         storage_clause => storage_clause,                         dblink_to_broker => dblink_to_broker,                         mailbox_schema => mailbox_schema,                         broker_name => broker_name,                         dblink_to_coordinator => dblink_to_coordinator,                         current_user => sys_context('USERENV', 'CURRENT_USER'));    write_trace('ADD_COORDINATOR : END ADD_COORDINATOR');  END;  procedure drop_coordinator(coordinator_name IN varchar2) AS  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('DROP_COORDINATOR : BEGIN DROP_COORDINATOR');    dbms_saga_adm_sys.drop_coordinator(coordinator_name => coordinator_name);    write_trace('DROP_COORDINATOR : END DROP_COORDINATOR');  END;  procedure add_participant(participant_name IN varchar2,                           participant_schema IN varchar2                           DEFAULT sys_context('USERENV','CURRENT_USER'),                           storage_clause IN varchar2 DEFAULT NULL,                           coordinator_name IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           callback_schema IN varchar2                           DEFAULT sys_context('USERENV','CURRENT_USER'),                           callback_package IN varchar2 DEFAULT NULL,                           dblink_to_participant IN varchar2 DEFAULT NULL) AS  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('ADD_PARTICIPANT : BEGIN ADD_PARTICIPANT');    dbms_saga_adm_sys.add_participant(                 participant_name => participant_name,                 participant_schema => participant_schema,                 storage_clause => storage_clause,                 coordinator_name => coordinator_name,                 dblink_to_broker => dblink_to_broker,                 mailbox_schema => mailbox_schema,                 broker_name => broker_name,                 callback_schema => callback_schema,                 callback_package => callback_package,                 dblink_to_participant => dblink_to_participant,                 current_user => sys_context('USERENV', 'CURRENT_USER'));    write_trace('ADD_PARTICIPANT : END ADD_PARTICIPANT');  END;  procedure drop_participant(participant_name IN varchar2) AS  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('DROP_PARTICIPANT : BEGIN DROP_PARTICIPANT');    dbms_saga_adm_sys.drop_participant(participant_name => participant_name);    write_trace('ADD_PARTICIPANT : BEGIN ADD_PARTICIPANT');  END;   procedure drop_broker(broker_name in varchar2) as  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    write_trace('DROP_BROKER : BEGIN DROP_BROKER');    dbms_saga_adm_sys.drop_broker(broker_name => broker_name);    write_trace('DROP_BROKER : END DROP_BROKER');  END;   procedure register_saga_callback(participant_name IN varchar2,                               callback_schema IN varchar2                               DEFAULT sys_context('USERENV' , 'CURRENT_USER'),                               callback_package IN varchar2) as  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    dbms_saga_adm_sys.register_saga_callback(                         participant_name => participant_name,                         callback_schema => callback_schema,                         callback_package => callback_package);  END;   procedure notify_callback_coordinator(context RAW ,                                       reginfo sys.aq$_reg_info ,                                       descr sys.aq$_descriptor ,                                       payload RAW ,                                       payloadl NUMBER) as    dequeue_options     sys.dbms_aq.dequeue_options_t;   message_properties  dbms_aq.message_properties_t;   message_handle      RAW(16);   message             SYS.AQ$_JMS_TEXT_MESSAGE;   enqueue_options     dbms_aq.enqueue_options_t;   opcode              NUMBER;   deq_saga_id         dbms_saga.saga_id_t;   req_payload         CLOB;  BEGIN    IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_adm.ROLLINGUNSUPPORTED;   END IF;    dequeue_options.msgid := descr.msg_id;   dequeue_options.navigation := dbms_aq.first_message;    DBMS_AQ.DEQUEUE(     queue_name => descr.queue_name,     dequeue_options => dequeue_options,     message_properties => message_properties,     payload => message,     msgid => message_handle);      deq_saga_id := dbms_saga.get_saga_id(message);     opcode  := dbms_saga.get_saga_opcode(message);     message.get_text(req_payload);    dbms_saga_adm_sys.process_notification(                         recipient => dbms_saga.get_saga_recipient(message),                         sender =>  dbms_saga.get_saga_sender(message),                         deq_saga_id => deq_saga_id,                         opcode => opcode,                         coordinator => NULL,                         req_res => req_payload); END;   procedure write_trace(   message      IN varchar2,   event        IN binary_integer DEFAULT 10855,   event_level  IN binary_integer DEFAULT 1,   time_info    IN boolean DEFAULT FALSE) AS    event_value BINARY_INTEGER := 0; BEGIN   IF bitand(event_value, event_level) = event_level THEN     dump_trace(message, time_info);   END IF; END write_trace;  procedure dump_trace(   message      IN varchar2,   time_info    IN boolean DEFAULT FALSE) AS    pos        BINARY_INTEGER := 1;   mesg_len   BINARY_INTEGER := LENGTH(message);  BEGIN    WHILE pos <= mesg_len LOOP     pos := pos + 80;   END LOOP; END dump_trace;  end dbms_saga_adm; ";
        OsagaInfra.SQL[12] = "create or replace package body dbms_saga as M_IDEN                  VARCHAR2(128); M_IDEN_Q                VARCHAR2(130); M_IDEN_SCM              VARCHAR2(261); MAX_ENTITY_NAME         CONSTANT BINARY_INTEGER := 115; procedure write_trace(message       IN VARCHAR2,                       event         IN BINARY_INTEGER DEFAULT 10855,                       event_level   IN BINARY_INTEGER DEFAULT 1,                       time_info     IN BOOLEAN DEFAULT FALSE); procedure dump_trace(message    IN  varchar2,                      time_info  IN boolean DEFAULT FALSE); function begin_saga(initiator_name IN VARCHAR2, timeout IN number DEFAULT 86400)                    return saga_id_t AS   guid                  RAW(16); BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   write_trace('BEGIN_SAGA : START begin_saga');   guid := dbms_saga_sys.begin_saga(                        initiator_name => initiator_name,                        timeout => timeout,                        current_user => sys_context('USERENV', 'CURRENT_USER'));   RETURN guid;   write_trace('BEGIN_SAGA : END begin_saga'); END; procedure enroll_participant(saga_id        IN saga_id_t,                              sender         IN VARCHAR2,                              recipient      IN VARCHAR2,                              coordinator    IN VARCHAR2,                              payload        IN JSON DEFAULT NULL) AS   enroll_message      SYS.AQ$_JMS_TEXT_MESSAGE;   enq_options         DBMS_AQ.ENQUEUE_OPTIONS_T;   msg_properties      DBMS_AQ.MESSAGE_PROPERTIES_T;   message_handle      RAW(16);   payload_clob        CLOB;   sender_out_topic    M_IDEN_SCM%TYPE;   recipient_int       M_IDEN%TYPE;   sender_int          M_IDEN%TYPE;   coordinator_int     M_IDEN%TYPE; BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   enroll_message := sys.aq$_jms_text_message.construct;   dbms_saga.set_saga_opcode(enroll_message,dbms_saga.REQUEST);   dbms_saga.set_saga_id(enroll_message,saga_id);   dbms_saga.set_saga_coordinator(enroll_message,coordinator);   dbms_saga.set_saga_sender(enroll_message,sender);   dbms_saga.set_saga_recipient(enroll_message,recipient);   IF payload IS NOT NULL THEN     payload_clob := to_clob(json_serialize(payload));     enroll_message.set_text(payload_clob);   END IF;   sender_out_topic := dbms_saga.get_out_topic(sender);   dbms_aq.enqueue(queue_name => sender_out_topic,                   enqueue_options => enq_options,                   message_properties => msg_properties,                   payload => enroll_message,                   msgid   => message_handle                   ); COMMIT; END; function get_saga_id return saga_id_t as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   return null; END; procedure set_saga_id(saga_id IN saga_id_t) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   null; END; procedure commit_saga(saga_participant IN VARCHAR2,                       saga_id IN saga_id_t ,                       force IN boolean DEFAULT TRUE) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   write_trace('COMMIT_SAGA : BEGIN commit_saga. Saga ID :' || saga_id);   dbms_saga_sys.commit_saga(                 saga_participant => saga_participant,                 saga_id => saga_id,                 force => force,                 current_user => sys_context('USERENV', 'CURRENT_USER'));   write_trace('COMMIT_SAGA : END commit_saga. Saga ID :' || saga_id); END; procedure rollback_saga(saga_participant IN VARCHAR2,                         saga_id IN saga_id_t ,                         force IN boolean DEFAULT TRUE) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   write_trace('ROLLBACK_SAGA : BEGIN rollback_saga. Saga ID : ' || saga_id);   dbms_saga_sys.rollback_saga(                 saga_participant => saga_participant,                 saga_id => saga_id,                 force => force,                 current_user => sys_context('USERENV', 'CURRENT_USER'));   write_trace('ROLLBACK_SAGA : END rollback_saga. Saga ID : ' || saga_id); END; procedure forget_saga(saga_id IN saga_id_t) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   null; END; procedure leave_saga(saga_id IN saga_id_t) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   null; END; procedure after_saga(saga_id IN saga_id_t) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   null; END; function is_incomplete(saga_id IN saga_id_t) return boolean as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   return null; END; procedure set_incomplete(saga_id IN saga_id_t) as BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   null; END; function get_out_topic(entity_name IN varchar2) return varchar2 as   out_queue         M_IDEN_SCM%TYPE; BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   out_queue := dbms_saga_sys.get_out_topic(entity_name => entity_name);   return out_queue; END; procedure notify_callback_participant(context RAW ,                                       reginfo sys.aq$_reg_info ,                                       descr sys.aq$_descriptor ,                                       payload RAW ,                                       payloadl NUMBER) as   r_dequeue_options       DBMS_AQ.DEQUEUE_OPTIONS_T;   r_message_properties    DBMS_AQ.MESSAGE_PROPERTIES_T;   v_message_handle        RAW(16);   message                 SYS.AQ$_JMS_TEXT_MESSAGE;   response_payload        SYS.AQ$_JMS_TEXT_MESSAGE;   saga_id                 dbms_saga_sys.saga_id_t;   recipient               M_IDEN%TYPE;   coordinator             M_IDEN%TYPE;   sender                  M_IDEN%TYPE;   opcode                  NUMBER;   req_res                 CLOB; BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga.ROLLINGUNSUPPORTED;   END IF;   r_dequeue_options.msgid := descr.msg_id;   r_dequeue_options.navigation := dbms_aq.first_message;   DBMS_AQ.DEQUEUE(     queue_name         => descr.queue_name,     dequeue_options    => r_dequeue_options,     message_properties => r_message_properties,     payload            => message,     msgid              => v_message_handle);   recipient          := dbms_saga.get_saga_recipient(message);   sender             := dbms_saga.get_saga_sender(message);   saga_id            := dbms_saga.get_saga_id(message);   opcode             := dbms_saga.get_saga_opcode(message);   coordinator        := dbms_saga.get_saga_coordinator(message);   message.get_text(req_res);   dbms_saga_sys.process_notification(recipient => recipient,                                          sender => sender,                                          saga_id => saga_id,                                          opcode => opcode,                                          coordinator => coordinator,                                          req_res => req_res); END; procedure set_saga_sender(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                           sender IN varchar2) IS   saga_sender_int     VARCHAR(115); BEGIN   dbms_utility.canonicalize(sender, saga_sender_int, 115);   message.set_string_property('jms_oracle_aq$_saga_sender' , saga_sender_int); END; procedure set_saga_recipient(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                              recipient IN varchar2) IS   saga_recipient_int  VARCHAR(115); BEGIN   dbms_utility.canonicalize(recipient, saga_recipient_int, 115);   message.set_string_property('jms_oracle_aq$_saga_recipient' , saga_recipient_int); END; procedure set_saga_opcode(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                           opcode IN NUMBER) IS BEGIN   message.set_int_property('jms_oracle_aq$_saga_opcode' , opcode); END; procedure set_saga_id(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                       saga_id IN RAW) IS BEGIN   message.set_string_property('jms_oracle_aq$_saga_id' , saga_id); END; procedure set_saga_coordinator(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE,                                saga_coordinator IN VARCHAR2) IS   saga_coordinator_int     VARCHAR(115); BEGIN   dbms_utility.canonicalize(saga_coordinator, saga_coordinator_int, 115);   message.set_string_property('jms_oracle_aq$_saga_coordinator' , saga_coordinator_int); END; function get_saga_sender(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2 IS BEGIN   return message.get_string_property('jms_oracle_aq$_saga_sender'); END; function get_saga_recipient(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2 IS BEGIN   return message.get_string_property('jms_oracle_aq$_saga_recipient'); END; function get_saga_opcode(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return NUMBER IS BEGIN   return message.get_int_property('jms_oracle_aq$_saga_opcode'); END; function get_saga_id(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return RAW IS BEGIN   return HEXTORAW(message.get_string_property('jms_oracle_aq$_saga_id')); END; function get_saga_coordinator(message IN OUT SYS.AQ$_JMS_TEXT_MESSAGE) return VARCHAR2 IS BEGIN   return message.get_string_property('jms_oracle_aq$_saga_coordinator'); END; procedure write_trace(       message      IN varchar2,       event        IN binary_integer DEFAULT 10855,       event_level  IN binary_integer DEFAULT 1,       time_info    IN boolean DEFAULT FALSE) AS   event_value BINARY_INTEGER := 0; BEGIN   IF bitand(event_value, event_level) = event_level THEN     dump_trace(message, time_info);   END IF; END write_trace; procedure dump_trace(     message      IN varchar2,     time_info    IN boolean DEFAULT FALSE) AS   pos        BINARY_INTEGER := 1;   mesg_len   BINARY_INTEGER := LENGTH(message); BEGIN   WHILE pos <= mesg_len LOOP     pos := pos + 80;   END LOOP; END dump_trace; end dbms_saga;";
        OsagaInfra.SQL[13] = "create or replace package body dbms_saga_adm_sys as M_IDEN_NAME             VARCHAR2(115);M_IDEN_NAME_Q           VARCHAR2(117);M_IDEN                  VARCHAR2(128);M_IDEN_Q                VARCHAR2(130);M_IDEN_SCM              VARCHAR2(261);MAX_ENTITY_NAME         CONSTANT BINARY_INTEGER := 115;MAX_IDENTIFIER_NAME     CONSTANT BINARY_INTEGER := 128;procedure addParticipantOrCoordinator(entity_name IN varchar2,                                       entity_schema IN varchar2,                                       storage_clause IN varchar2 DEFAULT NULL,                                       dblink_to_broker IN varchar2,                                       mailbox_schema IN varchar2,                                       broker_name IN varchar2 DEFAULT NULL,                                       callback_schema IN varchar2,                                       callback_package IN varchar2,                                       dblink_to_entity IN varchar2,                                       isCoordinator IN boolean DEFAULT FALSE,                                       coordinator_name IN varchar2 default NULL)                                       ;procedure dropParticipantOrCoordinator(entity_name IN varchar2 ,                                        entity_ntfn_callback IN varchar2);function uniqueEntity(entity_name IN varchar2,                       entity_schema IN varchar2,                       isBroker IN boolean) return boolean;procedure drop_broker_int(queue_table IN varchar2,                           broker_schema IN varchar2,                           broker_name_int IN varchar2,                           curr_state IN number);procedure drop_entity_int(entity_name_int IN varchar2,                           entity_schema_int IN varchar2,                           broker_idr IN raw,                           participant_status IN number,                           broker_dblink_int IN varchar2,                           broker_name_int IN varchar2,                           mailbox_schema_int IN varchar2,                           entity_ntfn_callback IN varchar2,                           curr_state_int IN number,                           saga_secret IN number);procedure register_callback_comp(participant_name_int IN varchar2,                                  participant_schema IN varchar2,                                  broker_dblink IN varchar2,                                  old_p_status IN number,                                  old_p_callback_schm IN varchar2,                                  old_p_callback_name IN varchar2,                                  participant_id IN raw,                                  curr_state_int IN number);procedure write_trace(message IN varchar2,                       event IN binary_integer DEFAULT 10855,                       event_level IN binary_integer DEFAULT 1,                       time_info IN boolean DEFAULT FALSE);procedure dump_trace(message IN varchar2,                      time_info IN boolean DEFAULT FALSE);procedure add_broker(broker_name IN varchar2 ,                      broker_schema IN varchar2,                      storage_clause IN varchar2 DEFAULT NULL,                      current_user IN varchar2) AS   q_table             M_IDEN%TYPE;  q_table_q           M_IDEN_Q%TYPE;  q_table_schema      M_IDEN_SCM%TYPE;  q_name              M_IDEN%TYPE;  q_name_q            M_IDEN_Q%TYPE;  q_name_schema       M_IDEN_SCM%TYPE;  any_rows_found      NUMBER;  saved_state         BOOLEAN;  broker_name_int     M_IDEN_NAME%TYPE;  broker_schema_int   M_IDEN_NAME%TYPE;  broker_name_q       M_IDEN_NAME_Q%TYPE;  broker_schema_q     M_IDEN_NAME_Q%TYPE;  curr_state          NUMBER := 0;  BROKER_EXISTS       EXCEPTION;  UNAUTHACCESS        EXCEPTION;BEGIN   dbms_utility.canonicalize(broker_name, broker_name_int, MAX_ENTITY_NAME);  broker_name_q := dbms_assert.enquote_name(broker_name_int, FALSE);  dbms_utility.canonicalize(broker_schema, broker_schema_int, MAX_ENTITY_NAME);  broker_schema_q := dbms_assert.enquote_name(broker_schema_int, FALSE);  IF uniqueEntity(broker_name_int, broker_schema_int, TRUE) = FALSE THEN     RAISE BROKER_EXISTS;  END IF;  q_table := 'SAGA$_' || broker_name_int || '_INOUT_QT';  q_table_q := dbms_assert.enquote_name(q_table, FALSE);  q_table_schema := broker_schema_q || '.' || q_table_q;  q_name := 'SAGA$_' || broker_name_int || '_INOUT';  q_name_q := dbms_assert.enquote_name(q_name, FALSE);  q_name_schema := broker_schema_q || '.' || q_name_q;  write_trace('ADD_BROKER(SYS) : q_table : ' || q_table                 || ' q_name : ' || q_name_schema);  dbms_aqadm.create_queue_table(     QUEUE_TABLE => q_table_schema,     QUEUE_PAYLOAD_TYPE => 'SYS.AQ$_JMS_TEXT_MESSAGE',     MULTIPLE_CONSUMERS => TRUE   );  curr_state := curr_state + 1;  dbms_aqadm.create_queue(     QUEUE_NAME => q_name_schema,     QUEUE_TABLE => q_table_schema   );  dbms_aqadm.start_queue(     QUEUE_NAME => q_name_schema,     ENQUEUE => TRUE,     DEQUEUE => TRUE   );  insert into saga_message_broker$ values(sys_guid(), broker_name_int,                                               broker_schema_int, q_name, 0);  curr_state := curr_state + 1;COMMIT;EXCEPTION   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001 , 'Insufficient Privileges to access     schema ' || broker_schema || '.');  WHEN BROKER_EXISTS THEN     RAISE_APPLICATION_ERROR(-20001 , 'broker name already exists');  WHEN OTHERS THEN     drop_broker_int(q_table, broker_schema_q, broker_name_int, curr_state);    RAISE;END;procedure drop_broker(broker_name in varchar2) as   any_rows_found              NUMBER;  broker_name_int             M_IDEN%TYPE;  broker_name_q               M_IDEN_Q%TYPE;  broker_schema               M_IDEN%TYPE;  broker_schema_q             M_IDEN_Q%TYPE;  q_table                     M_IDEN%TYPE;  q_table_q                   M_IDEN_Q%TYPE;  q_table_schema              M_IDEN_SCM%TYPE;  broker_qry                  VARCHAR2(500);  BROKERNOTFOUND              EXCEPTION;  PARTICIPANTATTERR           EXCEPTION;BEGIN   dbms_utility.canonicalize(broker_name, broker_name_int, MAX_ENTITY_NAME);  broker_name_q := dbms_assert.enquote_name(broker_name_int, FALSE);  BEGIN     select owner into broker_schema from saga_message_broker$     where name = broker_name_int;  EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE BROKERNOTFOUND;  END;  broker_schema_q := dbms_assert.enquote_name(broker_schema, FALSE);  broker_qry := 'select count(*) from saga_participant$                  where broker_id = (select id from saga_message_broker$                  where name = :1)';  execute immediate broker_qry into any_rows_found using broker_name_int;  IF any_rows_found <> 0 THEN     RAISE PARTICIPANTATTERR;  END IF;  q_table := 'SAGA$_' || broker_name_int || '_INOUT_QT';  q_table_q := dbms_assert.enquote_name(q_table, FALSE);  q_table_schema := broker_schema_q || '.' || q_table_q;  write_trace('DROP_BROKER(SYS) : q_table : ' || q_table_schema);  drop_broker_int(q_table, broker_schema_q, broker_name_int,                   dbms_saga_adm_sys.BROKER_MAX_STATE);COMMIT;EXCEPTION   WHEN BROKERNOTFOUND THEN     RAISE_APPLICATION_ERROR(-20001, 'Cannot Drop Broker: Broker not found');  WHEN PARTICIPANTATTERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Broker : Some     Participants are still attached to the broker');  WHEN OTHERS THEN     RAISE;END;procedure add_coordinator(coordinator_name IN varchar2 ,                           coordinator_schema IN varchar2,                           storage_clause IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           dblink_to_coordinator IN varchar2 DEFAULT NULL,                           current_user IN varchar2) AS   COORDINATOR_EXISTS       EXCEPTION;  UNAUTHACCESS             EXCEPTION;BEGIN   IF uniqueEntity(coordinator_name,coordinator_schema,FALSE) = FALSE THEN     RAISE COORDINATOR_EXISTS;  END IF;  addParticipantOrCoordinator(coordinator_name, coordinator_schema,                               storage_clause, dblink_to_broker,                               mailbox_schema, broker_name, NULL,                               NULL, dblink_to_coordinator , TRUE);COMMIT;EXCEPTION   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001 , 'Insufficient Privileges to access     schema ' || coordinator_schema || '.');  WHEN COORDINATOR_EXISTS THEN     RAISE_APPLICATION_ERROR(-20001 , 'coordinator name already exists');  WHEN OTHERS THEN     RAISE;END;procedure drop_coordinator(coordinator_name IN varchar2) AS   dependent_participants      NUMBER;  coordinator_name_int        M_IDEN%TYPE;  PARTICIPANTDEPEXCEPTION     EXCEPTION;BEGIN   dbms_utility.canonicalize(coordinator_name, coordinator_name_int,                             MAX_ENTITY_NAME);  select count(*) into dependent_participants from saga_participant$   where coordinator_id = (select id from saga_participant$   where name = coordinator_name_int);  IF dependent_participants <> 0 THEN     RAISE PARTICIPANTDEPEXCEPTION;  END IF;  dropParticipantOrCoordinator(coordinator_name,                      'plsql://dbms_saga_adm.notify_callback_coordinator');COMMIT;EXCEPTION   WHEN PARTICIPANTDEPEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot drop coordinator since there     are participants dependent on this. Please drop dependent participant     and then try again.');  WHEN OTHERS THEN     RAISE;END;procedure add_participant(participant_name IN varchar2 ,                           participant_schema IN varchar2,                           storage_clause IN varchar2 DEFAULT NULL,                           coordinator_name IN varchar2 DEFAULT NULL,                           dblink_to_broker IN varchar2 DEFAULT NULL,                           mailbox_schema IN varchar2,                           broker_name IN varchar2,                           callback_schema IN varchar2,                           callback_package IN varchar2 DEFAULT NULL,                           dblink_to_participant IN varchar2 DEFAULT NULL,                           current_user IN varchar2) AS   PARTICIPANT_EXISTS       EXCEPTION;  UNAUTHACCESS             EXCEPTION;BEGIN   IF uniqueEntity(participant_name,participant_schema,FALSE) = FALSE THEN     RAISE PARTICIPANT_EXISTS;  END IF;  addParticipantOrCoordinator(participant_name, participant_schema,                               storage_clause, dblink_to_broker,                               mailbox_schema, broker_name, callback_schema,                               callback_package, dblink_to_participant,                               FALSE, coordinator_name);COMMIT;EXCEPTION   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001 , 'Insufficient Privileges to access     schema ' || participant_schema || '.');  WHEN PARTICIPANT_EXISTS THEN     RAISE_APPLICATION_ERROR(-20001 , 'participant name already exists');  WHEN OTHERS THEN     RAISE;END;procedure drop_participant(participant_name IN varchar2) AS BEGIN   dropParticipantOrCoordinator(participant_name,                     'plsql://dbms_saga.notify_callback_participant');COMMIT;EXCEPTION   WHEN OTHERS THEN     RAISE;END;procedure register_saga_callback(participant_name IN varchar2,                                  callback_schema IN varchar2,                                  callback_package IN varchar2) AS   participant_name_int      M_IDEN%TYPE;  part_qin                  M_IDEN%TYPE;  part_qin_q                M_IDEN_Q%TYPE;  part_qin_q_schema         M_IDEN_SCM%TYPE;  participant_schema        M_IDEN%TYPE;  participant_schema_q      M_IDEN_Q%TYPE;  cbk_pkg                   M_IDEN%TYPE;  cbk_pkg_old               M_IDEN%TYPE;  cbk_schema                M_IDEN%TYPE;  cbk_schema_old            M_IDEN%TYPE;  broker_dblink             M_IDEN%TYPE;  broker_dblink_q           M_IDEN_Q%TYPE;  participant_id            RAW(16);  participant_status        NUMBER;  participant_type          NUMBER;  curr_state                NUMBER;  saga_secret               NUMBER;  broker_string             M_IDEN_SCM%TYPE;  v_sql                     VARCHAR2(600);  PARTICIPANTNOTFOUND       EXCEPTION;  INVALIDENTITY             EXCEPTION;  INVALIDPKG                EXCEPTION;BEGIN   dbms_utility.canonicalize(participant_name, participant_name_int,                             MAX_ENTITY_NAME);  BEGIN     select owner, participant_iscomplete, id, type, dblink_to_broker,     callback_schema, callback_package     into participant_schema, participant_status, participant_id,     participant_type, broker_dblink, cbk_schema_old, cbk_pkg_old     from saga_participant$ where name = participant_name_int;  EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE PARTICIPANTNOTFOUND;  END;  dbms_utility.canonicalize(callback_schema, cbk_schema, MAX_IDENTIFIER_NAME);  dbms_utility.canonicalize(callback_package, cbk_pkg, MAX_IDENTIFIER_NAME);  IF participant_type = dbms_saga_adm_sys.COORDINATOR THEN     RAISE INVALIDENTITY;  END  IF;  IF participant_status = dbms_saga_adm_sys.INCOMPLETE THEN     participant_schema_q := dbms_assert.enquote_name(participant_schema,FALSE);    part_qin := 'SAGA$_' || participant_name_int || '_IN_Q';    part_qin_q := dbms_assert.enquote_name(part_qin, FALSE);    part_qin_q_schema := participant_schema_q || '.' || part_qin_q;    DBMS_AQ.REGISTER(sys.aq$_reg_info_list(sys.aq$_reg_info(part_qin_q_schema     , dbms_aq.namespace_aq ,     'plsql://dbms_saga.notify_callback_participant' , HEXTORAW('FF'))) , 1);  END IF;  curr_state := curr_state + 1;  update saga_participant$ set callback_schema = cbk_schema,   callback_package = cbk_pkg,   participant_iscomplete = dbms_saga_adm_sys.COMPLETED   where name = participant_name_int;  curr_state := curr_state + 1;  IF broker_dblink IS NOT NULL THEN     broker_dblink_q := dbms_assert.enquote_name(broker_dblink, FALSE);    broker_string := 'dbms_saga_connect_int' || '.' ||     'updateCallbackInfo' || '@' || broker_dblink_q;    v_sql := 'BEGIN ' ||               broker_string ||              '(:1, :2, :3, :4, :5);END;';    execute immediate v_sql using callback_schema, callback_package,                                 dbms_saga_adm_sys.COMPLETED, participant_id,                                 saga_secret;  END IF;  curr_state := curr_state + 1;COMMIT;EXCEPTION   WHEN PARTICIPANTNOTFOUND THEN     RAISE_APPLICATION_ERROR(-20001 , 'Participant Not Found :     participant name does not exist');  WHEN INVALIDPKG THEN     RAISE_APPLICATION_ERROR(-20001 , 'Missing package or execution rights     for package ' || cbk_schema || '.' || cbk_pkg);  WHEN INVALIDENTITY THEN     RAISE_APPLICATION_ERROR(-20001 , 'Callback package cannot be set     for coordinator');  WHEN OTHERS THEN     register_callback_comp(participant_name_int, participant_schema,                            broker_dblink, participant_status, cbk_schema_old,                            cbk_pkg_old, participant_id, curr_state);    RAISE;END;procedure addParticipantOrCoordinator(entity_name IN varchar2,                                       entity_schema IN varchar2,                                       storage_clause IN varchar2 DEFAULT NULL,                                       dblink_to_broker IN varchar2,                                       mailbox_schema IN varchar2,                                       broker_name IN varchar2 DEFAULT NULL,                                       callback_schema IN varchar2,                                       callback_package IN varchar2,                                       dblink_to_entity IN varchar2,                                       isCoordinator IN boolean DEFAULT FALSE,                                       coordinator_name IN varchar2 DEFAULT NULL)                                       as   entity_name_int             M_IDEN%TYPE;  entity_name_q               M_IDEN_Q%TYPE;  entity_schema_int           M_IDEN%TYPE;  entity_schema_q             M_IDEN_Q%TYPE;  qt_in                       M_IDEN%TYPE;  qt_in_q                     M_IDEN_Q%TYPE;  qt_in_schema                M_IDEN_SCM%TYPE;  qt_out                      M_IDEN%TYPE;  qt_out_q                    M_IDEN_Q%TYPE;  qt_out_schema               M_IDEN_SCM%TYPE;  q_in                        M_IDEN%TYPE;  q_in_q                      M_IDEN_Q%TYPE;  q_out                       M_IDEN%TYPE;  q_out_q                     M_IDEN_Q%TYPE;  q_in_schema                 M_IDEN%TYPE;  q_out_schema                M_IDEN%TYPE;  q_in_coordinator            M_IDEN%TYPE;  broker_queue                M_IDEN%TYPE;  broker_queue_q              M_IDEN_Q%TYPE;  broker_queue_schema         M_IDEN_SCM%TYPE;  connectbroker_string        M_IDEN_SCM%TYPE;  disconnectbroker_string     M_IDEN_SCM%TYPE;  broker_string               M_IDEN_SCM%TYPE;  v_sql                       VARCHAR2(1500);  dblink_to_broker_int        M_IDEN%TYPE;  dblink_to_broker_sec        M_IDEN_Q%TYPE;  dblink_to_entity_int        M_IDEN%TYPE;  broker_name_int             M_IDEN%TYPE;  mailbox_schema_int          M_IDEN%TYPE;  mailbox_schema_q            M_IDEN_Q%TYPE;  coordinator_name_int        M_IDEN%TYPE;  callback_schema_int         M_IDEN%TYPE;  callback_package_int        M_IDEN%TYPE;  internal_callback           M_IDEN%TYPE;  subscriber_out              sys.aq$_agent;  coordinator_id              RAW(16);  broker_id                   RAW(16);  participant_id              RAW(16);  participant_status          NUMBER := dbms_saga_adm_sys.INCOMPLETE;  coordinatorOrParticipant    NUMBER;  any_rows_found              NUMBER;  curr_state                  NUMBER := 0;  saga_secret                 NUMBER;  uniqueentitybroker          BOOLEAN;  BROKERINVALID               EXCEPTION;  BROKERIDERR                 EXCEPTION;  COORDINATORNOTFOUND         EXCEPTION;  ENTITY_EXISTS_PDB           EXCEPTION;  NULLDBLINK                  EXCEPTION;  REMOTECALLERROR             EXCEPTION;  INVALIDPKG                  EXCEPTION;BEGIN   dbms_utility.canonicalize(entity_name, entity_name_int, MAX_ENTITY_NAME);  entity_name_q := dbms_assert.enquote_name(entity_name_int, FALSE);  dbms_utility.canonicalize(entity_schema, entity_schema_int, MAX_ENTITY_NAME);  entity_schema_q := dbms_assert.enquote_name(entity_schema_int, FALSE);  qt_in := 'SAGA$_' || entity_name_int || '_IN_QT';  qt_in_q := dbms_assert.enquote_name(qt_in, FALSE);  qt_in_schema := entity_schema_q || '.' || qt_in_q;  qt_out := 'SAGA$_' || entity_name_int || '_OUT_QT';  qt_out_q := dbms_assert.enquote_name(qt_out, FALSE);  qt_out_schema := entity_schema_q || '.' || qt_out_q;  q_in := 'SAGA$_' || entity_name_int || '_IN_Q';  q_in_q := dbms_assert.enquote_name(q_in, FALSE);  q_in_schema := entity_schema_q || '.' || q_in_q;  q_out := 'SAGA$_' || entity_name_int || '_OUT_Q';  q_out_q := dbms_assert.enquote_name(q_out, FALSE);  q_out_schema := entity_schema_q || '.' || q_out;  write_trace('ADDPARTICIPANTORCOORDINATOR(SYS) : qt_in :' || qt_in   || ' qt_out : ' || qt_out || ' q_in : ' || q_in_schema   || 'q_out : ' || q_out_schema);  IF callback_package IS NOT NULL THEN     dbms_utility.canonicalize(callback_schema, callback_schema_int,                               MAX_IDENTIFIER_NAME);    dbms_utility.canonicalize(callback_package, callback_package_int,                               MAX_IDENTIFIER_NAME);  END IF;  IF dblink_to_broker IS NOT NULL THEN     dbms_utility.canonicalize(dblink_to_broker, dblink_to_broker_int,                               MAX_IDENTIFIER_NAME);    dblink_to_broker_sec := dbms_assert.enquote_name(dblink_to_broker_int,                                                      FALSE);    IF dblink_to_entity IS NULL THEN       RAISE NULLDBLINK;    END IF;    dbms_utility.canonicalize(dblink_to_entity, dblink_to_entity_int,                               MAX_IDENTIFIER_NAME);    IF dblink_to_broker_int = dblink_to_entity_int THEN       dblink_to_broker_int := NULL;      dblink_to_broker_sec := NULL;      dblink_to_entity_int := NULL;    END IF;    IF dblink_to_broker_int IS NOT NULL THEN       BEGIN         broker_string := ':r := dbms_saga_connect_int'                || '.' || 'uniqueEntityAtPDB' || '@' || dblink_to_broker_sec;        v_sql := 'BEGIN ' ||                  broker_string ||                  '(:1, :2, :3, :4, :5);END;';        execute immediate v_sql using OUT uniqueentitybroker, IN entity_name,                 IN broker_name, IN mailbox_schema, IN dblink_to_broker,                 IN dblink_to_entity;        IF uniqueentitybroker = FALSE THEN           RAISE ENTITY_EXISTS_PDB;        END IF;      EXCEPTION         WHEN ENTITY_EXISTS_PDB THEN           RAISE ENTITY_EXISTS_PDB;        WHEN NO_DATA_FOUND THEN           RAISE NULLDBLINK;        WHEN OTHERS THEN           RAISE REMOTECALLERROR;      END;    END IF;  END IF;  dbms_utility.canonicalize(broker_name, broker_name_int, MAX_ENTITY_NAME);  dbms_utility.canonicalize(mailbox_schema, mailbox_schema_int,                             MAX_IDENTIFIER_NAME);  mailbox_schema_q := dbms_assert.enquote_name(mailbox_schema_int, FALSE);  BEGIN     IF dblink_to_broker_int IS NOT NULL THEN       broker_string := 'dbms_saga_connect_int' || '.' ||       'getBrokerInfo' || '@' || dblink_to_broker_sec;      v_sql := 'BEGIN ' ||                broker_string ||                '(:1, :2, :3, :4);END;';      execute immediate v_sql using IN OUT broker_id, IN OUT broker_name_int,                                     IN OUT mailbox_schema_int, TRUE;    ELSE       execute immediate 'select id from saga_message_broker$ where       name = :1 and owner = :2' into broker_id using broker_name_int,       mailbox_schema_int;    END IF;  EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE BROKERINVALID;    WHEN OTHERS THEN       RAISE BROKERIDERR;  END;  IF coordinator_name IS NOT NULL THEN     dbms_utility.canonicalize(coordinator_name, coordinator_name_int,                               MAX_ENTITY_NAME);    BEGIN       select id into coordinator_id from saga_participant$       where name = coordinator_name_int;    EXCEPTION       WHEN NO_DATA_FOUND THEN         RAISE COORDINATORNOTFOUND;    END;  END IF;  dbms_aqadm.create_queue_table(     QUEUE_TABLE => qt_in_schema,     QUEUE_PAYLOAD_TYPE => 'SYS.AQ$_JMS_TEXT_MESSAGE'   );  curr_state := curr_state + 1;  dbms_aqadm.create_queue_table(     QUEUE_TABLE => qt_out_schema,     QUEUE_PAYLOAD_TYPE => 'SYS.AQ$_JMS_TEXT_MESSAGE',     MULTIPLE_CONSUMERS => TRUE   );  curr_state := curr_state + 1;  dbms_aqadm.create_queue(     QUEUE_NAME => q_in_schema,     QUEUE_TABLE => qt_in_schema   );  dbms_aqadm.create_queue(     QUEUE_NAME => q_out_schema,     QUEUE_TABLE => qt_out_schema   );  dbms_aqadm.start_queue(     QUEUE_NAME => q_in_schema,     ENQUEUE => TRUE,     DEQUEUE => TRUE   );  dbms_aqadm.start_queue(     QUEUE_NAME => q_out_schema,     ENQUEUE => TRUE,     DEQUEUE => TRUE   );  broker_queue := 'SAGA$_' || broker_name_int || '_INOUT';  broker_queue_q := dbms_assert.enquote_name(broker_queue, FALSE);  broker_queue_schema := mailbox_schema_q || '.' || broker_queue_q;  IF dblink_to_broker_int IS NOT NULL THEN     subscriber_out := sys.aq$_agent(NULL,                 broker_queue_schema || '@' || dblink_to_broker_sec, 0);  ELSE     subscriber_out := sys.aq$_agent(NULL, broker_queue_schema, 0);  END IF;  dbms_aqadm.add_subscriber(     queue_name => q_out_schema,     subscriber => subscriber_out,     queue_to_queue => TRUE   );  write_trace('ADDPARTICIPANTORCOORDINATOR(SYS) : schedule propagation from   OUT queue to broker. queue_name : ' || q_out_schema ||' destination: '   || dblink_to_broker_sec);  curr_state := curr_state + 1;  dbms_aqadm.schedule_propagation(     queue_name => q_out_schema,     destination => dblink_to_broker_int,     destination_queue => broker_queue_schema,     latency => 0   );  curr_state := curr_state + 1;  IF isCoordinator = TRUE THEN     coordinatorOrParticipant := dbms_saga_adm_sys.COORDINATOR;    participant_status := NULL;    internal_callback :='plsql://dbms_saga_adm.notify_callback_coordinator';    DBMS_AQ.REGISTER(sys.aq$_reg_info_list(sys.aq$_reg_info(q_in_schema,     dbms_aq.namespace_aq, internal_callback, HEXTORAW('FF'))), 1);    curr_state := curr_state + 1;    write_trace('ADDPARTICIPANTORCOORDINATOR(SYS) : registering callback for     coordinator - plsql://dbms_saga_adm.notify_callback_coordinator');  ELSE     coordinatorOrParticipant := dbms_saga_adm_sys.PARTICIPANT;    IF callback_package IS NOT NULL THEN       participant_status := dbms_saga_adm_sys.COMPLETED;      internal_callback := 'plsql://dbms_saga.notify_callback_participant';      DBMS_AQ.REGISTER(sys.aq$_reg_info_list(sys.aq$_reg_info(q_in_schema,       dbms_aq.namespace_aq, internal_callback, HEXTORAW('FF'))), 1);    END IF;    curr_state := curr_state + 1;    write_trace('ADDPARTICIPANTORCOORDINATOR(SYS) : registering callback for     participant - plsql://dbms_saga.notify_callback_participant');  END IF;  IF dblink_to_broker_int IS NOT NULL THEN     select count(*) into any_rows_found from saga_message_broker$     where name = broker_name_int and owner = mailbox_schema_int     and remote = dbms_saga_adm_sys.DBMS_REMOTE;    IF any_rows_found = 0 THEN       insert into saga_message_broker$ values(broker_id, broker_name_int,                  mailbox_schema_int, 'SAGA$_' || broker_name_int || '_INOUT',                  dbms_saga_adm_sys.DBMS_REMOTE);    END IF;  END IF;  curr_state := curr_state + 1;  participant_id := sys_guid();  write_trace('ADDPARTICIPANTORCOORDINATOR(SYS) : participant GUID : '   || participant_id);  insert into saga_participant$ values(participant_id, entity_name_int,                                            entity_schema_int,                                            coordinatorOrParticipant,                                            broker_id,                                            coordinator_id,                                            dblink_to_broker_int,                                            dblink_to_entity_int,                                            q_in, q_out,                                            callback_schema_int,                                            callback_package_int,                                            participant_status,                                            dbms_saga_adm_sys.DBMS_LOCAL);  saga_secret := trunc(dbms_random.value(0,99999999));  insert into saga_secrets$ values(participant_id,                                        saga_secret,                                        dbms_saga_adm_sys.CONNECT_BROKER,                                        CURRENT_TIMESTAMP);  curr_state := curr_state + 1;  IF dblink_to_broker_int IS NOT NULL THEN     connectbroker_string := 'dbms_saga_connect_int'     || '.' || 'connectBrokerToInqueue' || '@' || dblink_to_broker_sec;  ELSE     null;    connectbroker_string := 'dbms_saga_connect_int'     || '.' || 'connectBrokerToInqueue';  END IF;  v_sql := 'BEGIN ' ||             connectbroker_string ||             '(:1 , :2 , :3 , :4 , :5 , :6 , :7 , :8 , :9 , :10 , :11             , :12 , :13 , :14 , :15, :16);END;';  execute immediate v_sql using participant_id,entity_name_int,   entity_schema_int,coordinatorOrParticipant,broker_id,coordinator_id,   dblink_to_broker_int,dblink_to_entity_int,q_in,q_out,callback_schema_int,   callback_package_int,participant_status,mailbox_schema_int,broker_name_int,   saga_secret;  delete from saga_secrets$ where secret = saga_secret;COMMIT;EXCEPTION   WHEN INVALIDPKG THEN     RAISE_APPLICATION_ERROR(-20001 , 'Missing package or execution rights     for package ' || callback_schema_int || '.' || callback_package_int);  WHEN NULLDBLINK THEN     RAISE_APPLICATION_ERROR(-20001 , 'dblink cannot be NULL when broker dblink                                       is non-null.');  WHEN REMOTECALLERROR THEN     RAISE_APPLICATION_ERROR(-20001 , 'unable to make remote call using the given                                       db_link');  WHEN ENTITY_EXISTS_PDB THEN     RAISE_APPLICATION_ERROR(-20001 , 'Entity ' || entity_name_int ||     ' already exists at the broker. Entity name should be unique across       this pdb and broker dependents');  WHEN BROKERINVALID THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Create Entity :     Cannot create participant or coordinator because the broker     name or schema is invalid');  WHEN BROKERIDERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Create Entity :     Cannot fetch broker id from the remote pdb.');  WHEN COORDINATORNOTFOUND THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Create Participant:     Invalid Coordinator Name');  WHEN dbms_saga_adm_sys.CONNECTTOBROKERFAILURE THEN     IF dblink_to_broker_int IS NOT NULL THEN       disconnectbroker_string := 'dbms_saga_connect_int' || '.'       || 'disconnectBrokerFromInqueue' || '@' || dblink_to_broker_sec;    ELSE       disconnectbroker_string := 'dbms_saga_connect_int' || '.'       || 'disconnectBrokerFromInqueue';    END IF;    v_sql := 'BEGIN ' ||               disconnectbroker_string ||               '(:1, :2, :3, :4, :5, :6, :7, :8);END;';    execute immediate v_sql using entity_name_int, entity_schema_int,                     dblink_to_entity_int, mailbox_schema_int,                     broker_name_int, dblink_to_broker_int, participant_id,                     saga_secret;    drop_entity_int(entity_name_int, entity_schema_int, broker_id,     participant_status, dblink_to_broker_int, broker_name_int,     mailbox_schema_int, internal_callback,     dbms_saga_adm_sys.PARTICIPANTENTRYDONE, saga_secret);    RAISE;  WHEN OTHERS THEN     drop_entity_int(entity_name_int, entity_schema_int, broker_id,     participant_status, dblink_to_broker_int, broker_name_int,     mailbox_schema_int, internal_callback,     curr_state, saga_secret);    RAISE;END;procedure connectBrokerToInqueue(participant_id IN RAW,                                  entity_name_int IN varchar2 ,                                  entity_schema_int IN varchar2 ,                                  coordinatorOrParticipant IN number,                                  broker_id IN RAW,                                  coordinator_id IN RAW,                                  dblink_to_broker_int IN varchar2,                                  dblink_to_entity_int IN varchar2,                                  inbound_queue IN varchar2,                                  outbound_queue IN varchar2,                                  callback_schema_int IN varchar2 ,                                  callback_package_int IN varchar2 ,                                  participant_iscomplete IN number,                                  broker_schema_int IN varchar2 ,                                  broker_name_int IN varchar2,                                  saga_secret IN number) as   q_in                M_IDEN%TYPE;  q_in_q              M_IDEN_Q%TYPE;  q_in_dest           M_IDEN_SCM%TYPE;  q_out               M_IDEN%TYPE;  q_out_q             M_IDEN_Q%TYPE;  q_out_schema        M_IDEN_SCM%TYPE;  q_in_schema         M_IDEN%TYPE;  broker_schema_q     M_IDEN_Q%TYPE;  entity_schema_q     M_IDEN_Q%TYPE;  dblink_to_entity_q  M_IDEN_Q%TYPE;  dest_dblink         M_IDEN%TYPE;  subscriber_out      sys.aq$_agent;BEGIN   broker_schema_q := dbms_assert.enquote_name(broker_schema_int, FALSE);  entity_schema_q := dbms_assert.enquote_name(entity_schema_int, FALSE);  IF dblink_to_entity_int IS NOT NULL THEN     dblink_to_entity_q := dbms_assert.enquote_name(dblink_to_entity_int, FALSE);  END IF;  q_out := 'SAGA$_' || broker_name_int || '_INOUT';  q_out_q := dbms_assert.enquote_name(q_out, FALSE);  q_out_schema := broker_schema_q || '.' || q_out_q;  q_in := 'SAGA$_' || entity_name_int || '_IN_Q';  q_in_q := dbms_assert.enquote_name(q_in, FALSE);  q_in_schema := entity_schema_q || '.' || q_in_q                                  || '@' || dblink_to_entity_q;  q_in_dest := entity_schema_q || '.' || q_in_q;  write_trace('CONNECTBROKERTOINQUEUE(SYS) : setting up reverse link from broker    to participant/coordinator IN Queue. Queue_out : ' || q_out   || 'destination_queue : ' || q_in_schema);  IF dblink_to_broker_int IS NOT NULL THEN     subscriber_out := sys.aq$_agent(NULL , q_in_schema, 0);    dest_dblink := dblink_to_entity_int;  ELSE     subscriber_out := sys.aq$_agent(NULL, q_in_dest, 0);  END IF;  DBMS_AQADM.ADD_SUBSCRIBER(queue_name => q_out_schema,                             subscriber => subscriber_out,                             queue_to_queue => TRUE,                             rule => 'tab.user_data.header.get_string_property(''jms_oracle_aq$_saga_recipient'') = '''                             || entity_name_int || '''');  dbms_aqadm.schedule_propagation(queue_name => q_out_schema,                                   destination => dest_dblink,                                   destination_queue => q_in_dest,                                   latency => 0);  IF dblink_to_broker_int IS NOT NULL THEN     insert into saga_participant$ values(participant_id,                                            entity_name_int,                                            entity_schema_int,                                            coordinatorOrParticipant,                                            broker_id, coordinator_id,                                            dblink_to_broker_int,                                            dblink_to_entity_int,                                            inbound_queue, outbound_queue,                                            callback_schema_int,                                            callback_package_int,                                            participant_iscomplete,                                            dbms_saga_adm_sys.DBMS_REMOTE);  END IF;COMMIT;EXCEPTION   WHEN OTHERS THEN     RAISE dbms_saga_adm_sys.CONNECTTOBROKERFAILURE;END;procedure drop_broker_int(queue_table IN varchar2,                           broker_schema IN varchar2,                           broker_name_int IN varchar2,                           curr_state IN number) AS   q_table_q               M_IDEN_Q%TYPE;  q_table_schema          M_IDEN_SCM%TYPE;  QTNOTFOUND              EXCEPTION;  PRAGMA                  EXCEPTION_INIT(QTNOTFOUND, -24002);  QTDROPEXCEPTION         EXCEPTION;  LOCALDELETEEXCEPTION    EXCEPTION;BEGIN   IF curr_state > 0 THEN     BEGIN     q_table_q := dbms_assert.enquote_name(queue_table, FALSE);    q_table_schema := broker_schema || '.' || q_table_q;    dbms_aqadm.drop_queue_table(       queue_table => q_table_schema,       force => TRUE     );    EXCEPTION       WHEN QTNOTFOUND THEN         null;      WHEN OTHERS THEN         RAISE QTDROPEXCEPTION;    END;  END IF;  IF curr_state > 1 THEN     BEGIN       delete from saga_message_broker$ where name = broker_name_int;    EXCEPTION       WHEN OTHERS THEN         RAISE LOCALDELETEEXCEPTION;    END;  END IF;COMMIT;EXCEPTION   WHEN QTDROPEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Queue Table:     Cannot drop broker queue table. Drop Queue table for this     broker and then try again.');  WHEN LOCALDELETEEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Broker:     Dictionary Entry cannot be cleared. Please try again');  WHEN OTHERS THEN     RAISE;END;procedure dropParticipantOrCoordinator(entity_name IN varchar2 ,                                        entity_ntfn_callback IN varchar2) as   entity_name_int             M_IDEN%TYPE;  entity_schema               M_IDEN%TYPE;  entity_q_in                 M_IDEN%TYPE;  entity_q_out                M_IDEN%TYPE;  entity_q_in_qt              M_IDEN%TYPE;  entity_q_out_qt             M_IDEN%TYPE;  entity_dblink               M_IDEN%TYPE;  broker_schema               M_IDEN%TYPE;  broker_name                 M_IDEN%TYPE;  broker_dblink               M_IDEN%TYPE;  broker_dblink_q             M_IDEN_Q%TYPE;  broker_queue                M_IDEN%TYPE;  participant_status          NUMBER;  disconnectbroker_string     M_IDEN%TYPE;  broker_string               M_IDEN_SCM%TYPE;  v_sql                       VARCHAR2(800);  broker_i                    RAW(16);  entity_i                    RAW(16);  saga_secret                 NUMBER;  ENTITYNOTFOUND              EXCEPTION;  BROKETNOTFOUND              EXCEPTION;  BROKERVALIDATIONERR         EXCEPTION;  REMOTEDROPFAILED            EXCEPTION;  DROPFAILED                  EXCEPTION;BEGIN   dbms_utility.canonicalize(entity_name, entity_name_int, MAX_ENTITY_NAME);  BEGIN     select owner,broker_id,dblink_to_participant,dblink_to_broker,            participant_iscomplete, id into entity_schema,broker_i,            entity_dblink,broker_dblink,participant_status, entity_i     from saga_participant$ where name = entity_name_int;  EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE ENTITYNOTFOUND;  END;  IF broker_dblink IS NOT NULL THEN     broker_dblink_q := dbms_assert.enquote_name(broker_dblink, FALSE);  END IF;  BEGIN     IF broker_dblink IS NOT NULL THEN       broker_string := 'dbms_saga_connect_int' || '.' ||       'getBrokerInfo' || '@' || broker_dblink_q;      v_sql := 'BEGIN ' ||                broker_string ||                '(:1, :2, :3, :4);END;';      execute immediate v_sql using IN OUT broker_i, IN OUT broker_schema,                                     IN OUT broker_name, FALSE;    ELSE       execute immediate 'select owner, name from saga_message_broker$       where id = :1' into broker_schema, broker_name using broker_i;    END IF;  EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE BROKETNOTFOUND;    WHEN OTHERS THEN       RAISE BROKERVALIDATIONERR;  END;  saga_secret := trunc(dbms_random.value(0,99999999));  insert into saga_secrets$ values(entity_i,                                        saga_secret,                                        dbms_saga_adm_sys.DISCONNECT_BROKER,                                        CURRENT_TIMESTAMP);  BEGIN     IF broker_dblink IS NOT NULL THEN       disconnectbroker_string := 'dbms_saga_connect_int' || '.'         || 'disconnectBrokerFromInqueue' || '@' || broker_dblink_q;    ELSE       disconnectbroker_string := 'dbms_saga_connect_int' || '.'         || 'disconnectBrokerFromInqueue';    END IF;    v_sql := 'BEGIN ' ||               disconnectbroker_string ||               '(:1, :2, :3, :4, :5, :6, :7, :8);END;';    execute immediate v_sql using entity_name_int, entity_schema,                                 entity_dblink, broker_schema,                                 broker_name, broker_dblink, entity_i,                                 saga_secret;  EXCEPTION     WHEN OTHERS THEN       RAISE REMOTEDROPFAILED;  END;  BEGIN     drop_entity_int(entity_name_int, entity_schema, broker_i,     participant_status, broker_dblink, broker_name, broker_schema,     entity_ntfn_callback, dbms_saga_adm_sys.PARTICIPANTENTRYDONE,     saga_secret);  EXCEPTION     WHEN OTHERS THEN       RAISE DROPFAILED;  END;COMMIT;EXCEPTION   WHEN ENTITYNOTFOUND THEN     RAISE_APPLICATION_ERROR(-20001 , 'Entity Not Found :     participant/coordinator does not exist.');  WHEN BROKETNOTFOUND THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity :     Cannot drop participant or coordinator because the broker     for this entity was not found on remote pdb');  WHEN BROKERVALIDATIONERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity :     Cannot validate if broker still exists on remote pdb');  WHEN REMOTEDROPFAILED THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity :     Drop operation at broker pdb failed.');  WHEN DROPFAILED THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity :     Drop operation failed. Please retry');  WHEN OTHERS THEN     RAISE;END;procedure disconnectBrokerFromInqueue(entity_name_int IN varchar2 ,                                       entity_schema_int IN varchar2,                                       dblink_to_entity_int IN varchar2,                                       broker_schema_int IN varchar2,                                       broker_name_int IN varchar2,                                       dblink_to_broker IN varchar2,                                       entity_id IN RAW,                                       saga_secret IN number) as   broker_schema_q           M_IDEN_Q%TYPE;  entity_schema_q           M_IDEN_Q%TYPE;  broker_queue              M_IDEN%TYPE;  broker_queue_q            M_IDEN_Q%TYPE;  broker_queue_schema       M_IDEN_SCM%TYPE;  entity_in_queue           M_IDEN%TYPE;  entity_in_queue_q         M_IDEN_Q%TYPE;  entity_in_queue_schema    M_IDEN_SCM%TYPE;  dblink_to_entity_q        M_IDEN_Q%TYPE;  subscriber_out            sys.aq$_agent;  entity_pdb                M_IDEN%TYPE;  dest_dblink               M_IDEN%TYPE;  PROPAGATIONNOTFOUND       EXCEPTION;  PRAGMA                    EXCEPTION_INIT(PROPAGATIONNOTFOUND, -24042);  SUBSCRIBERNOTFOUND        EXCEPTION;  PRAGMA                    EXCEPTION_INIT(SUBSCRIBERNOTFOUND, -24035);  QUEUENOTFOUND             EXCEPTION;  PRAGMA                    EXCEPTION_INIT(QUEUENOTFOUND, -24010);  PROPAGATIONDROPERR        EXCEPTION;  SUBSCRIBERDROPERR         EXCEPTION;  DICTCLEARERR              EXCEPTION;BEGIN   broker_schema_q := dbms_assert.enquote_name(broker_schema_int, FALSE);  entity_schema_q := dbms_assert.enquote_name(entity_schema_int, FALSE);  broker_queue := 'SAGA$_' || broker_name_int || '_INOUT';  broker_queue_q := dbms_assert.enquote_name(broker_queue, FALSE);  broker_queue_schema := broker_schema_q || '.' || broker_queue_q;  entity_in_queue := 'SAGA$_' || entity_name_int || '_IN_Q';  entity_in_queue_q := dbms_assert.enquote_name(entity_in_queue, FALSE);  entity_in_queue_schema := entity_schema_q || '.' || entity_in_queue_q;  IF dblink_to_broker IS NOT NULL THEN     dblink_to_entity_q := dbms_assert.enquote_name(dblink_to_entity_int, FALSE);    dest_dblink := dblink_to_entity_int;  END IF;  BEGIN     dbms_aqadm.unschedule_propagation(queue_name => broker_queue_schema,                                     destination => dest_dblink,                                     destination_queue => entity_in_queue_schema                                     );  EXCEPTION     WHEN QUEUENOTFOUND OR PROPAGATIONNOTFOUND THEN       null;    WHEN OTHERS THEN       RAISE PROPAGATIONDROPERR;  END;  BEGIN     entity_pdb := entity_in_queue_schema || '@' || dblink_to_entity_q;    IF dblink_to_broker IS NOT NULL THEN       subscriber_out := sys.aq$_agent(NULL , entity_pdb , 0);    ELSE       subscriber_out := sys.aq$_agent(NULL, entity_in_queue_schema, 0);    END IF;    DBMS_AQADM.REMOVE_SUBSCRIBER(queue_name => broker_queue_schema,                                  subscriber => subscriber_out);  EXCEPTION     WHEN QUEUENOTFOUND OR SUBSCRIBERNOTFOUND THEN       null;    WHEN OTHERS THEN       RAISE SUBSCRIBERDROPERR;  END;  write_trace('DISCONNECTBROKERFROMINQUEUE : destroying reverse link   from broker to participant/coordinator IN Queue. Queue_out : '   || broker_queue_schema || 'destination_queue : ' || entity_in_queue);  IF dblink_to_broker IS NOT NULL THEN     BEGIN       delete from saga_participant$ where name = entity_name_int;    EXCEPTION       WHEN OTHERS THEN         RAISE DICTCLEARERR;    END;  END IF;COMMIT;EXCEPTION   WHEN PROPAGATIONDROPERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: The propagation     from broker to the entity could not be unscheduled. Please unschedule     the propagation and try again.');  WHEN SUBSCRIBERDROPERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: The entity     subscriber cannot be dropped at the broker PDB. Please drop the     entity subscriber and try again.');  WHEN DICTCLEARERR THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity:     Dictionary Entry cannot be cleared. Please try again');  WHEN OTHERS THEN     RAISE;END;procedure drop_entity_int(entity_name_int IN varchar2,                           entity_schema_int IN varchar2,                           broker_idr IN raw,                           participant_status IN number,                           broker_dblink_int IN varchar2,                           broker_name_int IN varchar2,                           mailbox_schema_int IN varchar2,                           entity_ntfn_callback IN varchar2,                           curr_state_int IN number,                           saga_secret IN number) as   entity_q_in             M_IDEN%TYPE;  entity_q_in_q           M_IDEN_Q%TYPE;  entity_q_in_schema      M_IDEN_SCM%TYPE;  entity_q_out            M_IDEN%TYPE;  entity_q_out_q          M_IDEN_Q%TYPE;  entity_q_out_schema     M_IDEN_SCM%TYPE;  entity_schema_q         M_IDEN_Q%TYPE;  broker_queue            M_IDEN%TYPE;  broker_queue_q          M_IDEN_Q%TYPE;  broker_queue_schema     M_IDEN_SCM%TYPE;  mailbox_schema_q        M_IDEN_Q%TYPE;  broker_dblink_q         M_IDEN_Q%TYPE;  qt_in                   M_IDEN%TYPE;  qt_in_q                 M_IDEN_Q%TYPE;  qt_in_schema            M_IDEN_SCM%TYPE;  qt_out                  M_IDEN%TYPE;  qt_out_q                M_IDEN_Q%TYPE;  qt_out_schema           M_IDEN_SCM%TYPE;  broker_dest             M_IDEN_SCM%TYPE;  curr_state              NUMBER;  broker_dependency       NUMBER;  subscriber_out          sys.aq$_agent;  QUEUENOTFOUND           EXCEPTION;  PRAGMA                  EXCEPTION_INIT(QUEUENOTFOUND, -25205);  QUEUENOTFOUND2          EXCEPTION;  PRAGMA                  EXCEPTION_INIT(QUEUENOTFOUND2, -24010);  REGNOTFOUND             EXCEPTION;  PRAGMA                  EXCEPTION_INIT(REGNOTFOUND, -24950);  SUBSCRIBERNOTFOUND      EXCEPTION;  PRAGMA                  EXCEPTION_INIT(SUBSCRIBERNOTFOUND, -24035);  PROPAGATIONNOTFOUND     EXCEPTION;  PRAGMA                  EXCEPTION_INIT(PROPAGATIONNOTFOUND, -24042);  QTNOTFOUND              EXCEPTION;  PRAGMA                  EXCEPTION_INIT(QTNOTFOUND, -24002);  DICTDELEXCEPTION        EXCEPTION;  RMVCALLBACKEXCEPTION    EXCEPTION;  RMVPROPEXCEPTION        EXCEPTION;  RMVBQSBSCREXCEPTION     EXCEPTION;  QTOUTDROPEXCEPTION      EXCEPTION;  QTINDROPEXCEPTION       EXCEPTION;BEGIN   curr_state := curr_state_int;  IF curr_state = dbms_saga_adm_sys.PARTICIPANTENTRYDONE THEN     BEGIN       delete from saga_participant$ where name = entity_name_int;      delete from saga_secrets$ where secret = saga_secret;    EXCEPTION       WHEN OTHERS THEN         RAISE DICTDELEXCEPTION;    END;    curr_state := curr_state - 1;  END IF;  IF curr_state = dbms_saga_adm_sys.BROKERENTRYDONE THEN     IF broker_dblink_int IS NOT NULL THEN       BEGIN         select count(*) into broker_dependency from saga_participant$         where broker_id = broker_idr;        IF broker_dependency = 0 THEN           delete from saga_message_broker$ where id = broker_idr;        END IF;      EXCEPTION         WHEN OTHERS THEN           RAISE DICTDELEXCEPTION;      END;    END IF;    curr_state := curr_state - 1;  END IF;  entity_schema_q := dbms_assert.enquote_name(entity_schema_int, FALSE);  entity_q_in := 'SAGA$_' || entity_name_int || '_IN_Q';  entity_q_in_q := dbms_assert.enquote_name(entity_q_in, FALSE);  entity_q_in_schema := entity_schema_q || '.' || entity_q_in_q;  IF participant_status = dbms_saga_adm_sys.COMPLETED OR      participant_status = NULL THEN     IF curr_state = dbms_saga_adm_sys.CALLBACKDONE THEN       write_trace('DROPPARTICIPANTORCOORDINATOR(SYS) : try unregister for       notification:' || entity_ntfn_callback);      BEGIN         DBMS_AQ.UNREGISTER(         sys.aq$_reg_info_list(sys.aq$_reg_info(entity_q_in_schema,         dbms_aq.namespace_aq, entity_ntfn_callback, HEXTORAW('FF'))), 1);      EXCEPTION         WHEN QUEUENOTFOUND OR REGNOTFOUND THEN           null;        WHEN OTHERS THEN           RAISE RMVCALLBACKEXCEPTION;      END;      curr_state := curr_state - 1;    END IF;  ELSE     IF curr_state = dbms_saga_adm_sys.CALLBACKDONE THEN       curr_state := curr_state - 1;    END IF;  END IF;  entity_q_out := 'SAGA$_' || entity_name_int || '_OUT_Q';  entity_q_out_q := dbms_assert.enquote_name(entity_q_out, FALSE);  entity_q_out_schema := entity_schema_q || '.' || entity_q_out_q;  mailbox_schema_q := dbms_assert.enquote_name(mailbox_schema_int, FALSE);  broker_dblink_q := dbms_assert.enquote_name(broker_dblink_int,FALSE);  broker_queue := 'SAGA$_' || broker_name_int || '_INOUT';  broker_queue_q := dbms_assert.enquote_name(broker_queue, FALSE);  broker_queue_schema := mailbox_schema_q || '.' || broker_queue_q                                           || '@' || broker_dblink_q;  broker_dest := mailbox_schema_q || '.' || broker_queue_q;  IF curr_state = dbms_saga_adm_sys.PROPAGATIONDONE THEN     write_trace('DROPPARTICIPANTORCOORDINATOR(SYS) : try unschedule propagation     Queue_name : ' || entity_q_out_schema || '     destination : ' || broker_dblink_int);    BEGIN       dbms_aqadm.unschedule_propagation(         queue_name => entity_q_out_schema,         destination => broker_dblink_int,         destination_queue => broker_dest);    EXCEPTION       WHEN QUEUENOTFOUND2 OR PROPAGATIONNOTFOUND THEN         null;      WHEN OTHERS THEN         RAISE RMVPROPEXCEPTION;    END;    curr_state := curr_state - 1;  END IF;  IF curr_state = BROKERSUBDONE THEN     BEGIN       IF broker_dblink_int IS NOT NULL THEN         subscriber_out := sys.aq$_agent(NULL , broker_queue_schema, 0);      ELSE         subscriber_out := sys.aq$_agent(NULL, broker_dest, 0);      END IF;      dbms_aqadm.remove_subscriber(         queue_name => entity_q_out_schema,         subscriber => subscriber_out       );    EXCEPTION       WHEN QUEUENOTFOUND2 OR SUBSCRIBERNOTFOUND THEN         null;      WHEN OTHERS THEN         RAISE RMVBQSBSCREXCEPTION;    END;    curr_state := curr_state - 1;  END IF;  IF curr_state = OUTBOUNDDONE THEN     qt_out := 'SAGA$_' || entity_name_int || '_OUT_QT';    qt_out_q := dbms_assert.enquote_name(qt_out, FALSE);    qt_out_schema := entity_schema_q || '.' || qt_out_q;    write_trace('DROPPARTICIPANTORCOORDINATOR(SYS) : qt_out :'|| qt_out_schema);    BEGIN       dbms_aqadm.drop_queue_table(         queue_table => qt_out_schema,         force => TRUE       );    EXCEPTION       WHEN QTNOTFOUND THEN         null;      WHEN OTHERS THEN         RAISE QTOUTDROPEXCEPTION;    END;    curr_state := curr_state - 1;  END IF;  IF curr_state = INBOUNDDONE THEN     qt_in := 'SAGA$_' || entity_name_int || '_IN_QT';    qt_in_q := dbms_assert.enquote_name(qt_in, FALSE);    qt_in_schema := entity_schema_q || '.' || qt_in_q;    write_trace('DROPPARTICIPANTORCOORDINATOR(SYS) : qt_out :'|| qt_in_schema);    BEGIN       dbms_aqadm.drop_queue_table(         queue_table => qt_in_schema,         force => TRUE       );    EXCEPTION       WHEN QTNOTFOUND THEN         null;      WHEN OTHERS THEN         RAISE QTINDROPEXCEPTION;    END;    curr_state := curr_state - 1;  END IF;COMMIT;EXCEPTION   WHEN DICTDELEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity:     Dictionary Entry cannot be cleared. Please try again');  WHEN RMVCALLBACKEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity:     Cannot unregister notification callback for this entity.     Unregister the notification callback for this entity and     try again.');  WHEN RMVPROPEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: Cannot     unschedule the propagation from outbound queue to the broker.     Please unschedule the propagation and try again.');  WHEN RMVBQSBSCREXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: Cannot     drop the broker queue subscriber. Please remove the broker queue     subscriber and try again.');  WHEN QTOUTDROPEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: Cannot     drop the outbound queue table. Please drop the outbound queue     and then try again.');  WHEN QTINDROPEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Drop Entity: Cannot     drop the inbound queue table. Please drop the inbound queue     and then try again.');  WHEN OTHERS THEN     RAISE;END;procedure register_callback_comp(participant_name_int IN varchar2,                                  participant_schema IN varchar2,                                  broker_dblink IN varchar2,                                  old_p_status IN number,                                  old_p_callback_schm IN varchar2,                                  old_p_callback_name IN varchar2,                                  participant_id IN raw,                                  curr_state_int IN number) AS   p_q_in                     M_IDEN%TYPE;  p_q_in_q                   M_IDEN_Q%TYPE;  p_q_in_q_schema            M_IDEN_SCM%TYPE;  participant_schema_q       M_IDEN_Q%TYPE;  brkr_dblink_q              M_IDEN_Q%TYPE;  curr_state                 NUMBER;  broker_string              M_IDEN_SCM%TYPE;  v_sql                      VARCHAR2(600);  saga_secret                NUMBER;  QUEUENOTFOUND              EXCEPTION;  PRAGMA                     EXCEPTION_INIT(QUEUENOTFOUND, -25205);  REGNOTFOUND                EXCEPTION;  PRAGMA                     EXCEPTION_INIT(REGNOTFOUND, -24950);  QUEUENOTFOUND2             EXCEPTION;  PRAGMA                     EXCEPTION_INIT(QUEUENOTFOUND2, -24010);  REMOTEUPDATEEXCEPTION      EXCEPTION;  LOCALUPDATEEXCEPTION       EXCEPTION;  RMVCALLBACKEXCEPTION       EXCEPTION;BEGIN   curr_state := curr_state_int;  IF curr_state = dbms_saga_adm_sys.REGREMOTEDONE THEN     IF broker_dblink IS NOT NULL THEN       BEGIN         brkr_dblink_q := dbms_assert.enquote_name(broker_dblink, FALSE);        broker_string := 'dbms_saga_connect_int' || '.' ||           'updateCallbackInfo' || '@' || brkr_dblink_q;        v_sql := 'BEGIN ' ||                   broker_string ||                   '(:1, :2, :3, :4, :5);END;';        execute immediate v_sql using old_p_callback_schm, old_p_callback_name,                                 old_p_status, participant_id, saga_secret;      EXCEPTION         WHEN OTHERS THEN           RAISE REMOTEUPDATEEXCEPTION;      END;    END IF;    curr_state := curr_state - 1;  END IF;  IF curr_state = dbms_saga_adm_sys.REGLOCALDONE THEN     BEGIN       update saga_participant$ set callback_schema = old_p_callback_schm,       callback_package = old_p_callback_name,       participant_iscomplete = old_p_status       where name = participant_name_int;    EXCEPTION       WHEN OTHERS THEN         RAISE LOCALUPDATEEXCEPTION;    END;    curr_state := curr_state - 1;  END IF;  IF old_p_status = dbms_saga_adm_sys.INCOMPLETE THEN     participant_schema_q := dbms_assert.enquote_name(participant_schema,FALSE);    p_q_in := 'SAGA$_' || participant_name_int || '_IN_Q';    p_q_in_q := dbms_assert.enquote_name(p_q_in, FALSE);    p_q_in_q_schema := participant_schema_q || '.' || p_q_in_q;    IF curr_state = dbms_saga_adm_sys.REGCALLBACKDONE THEN       BEGIN         DBMS_AQ.UNREGISTER(         sys.aq$_reg_info_list(sys.aq$_reg_info(p_q_in_q_schema         , dbms_aq.namespace_aq,         'plsql://dbms_saga.notify_callback_participant', HEXTORAW('FF'))), 1);      EXCEPTION         WHEN QUEUENOTFOUND OR REGNOTFOUND THEN           null;        WHEN OTHERS THEN           RAISE RMVCALLBACKEXCEPTION;      END;    END IF;  END IF;  curr_state := curr_state - 1;COMMIT;EXCEPTION   WHEN REMOTEUPDATEEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Register Participant:     Compensation callback for register_saga_callback failed to update     broker table. Please try to register saga callback again.');  WHEN LOCALUPDATEEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Register Participant:     Compensation callback for register_saga_callback failed to update     local table. Please try to register saga callback again.');  WHEN RMVCALLBACKEXCEPTION THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot Register Participant:     Compensation callback for register_saga_callback failed to remove     registered callback. Please try to register saga callback again.');  WHEN OTHERS THEN     RAISE;END;procedure process_notification(recipient IN varchar2,                                sender IN varchar2,                                deq_saga_id IN saga_id_t,                                opcode IN number,                                coordinator IN varchar2,                                req_res IN clob) AS   valid_sagaid        NUMBER;   BAD_OPCODE          EXCEPTION;   procedure enqueue_ack(saga_id IN saga_id_t, receiver IN VARCHAR2,                         initiator IN VARCHAR2, req_payload IN CLOB) is     enqueue_options             sys.dbms_aq.enqueue_options_t;     message_properties_enq      sys.dbms_aq.message_properties_t;     message_handle_enq          RAW(16);     message_enq                 SYS.AQ$_JMS_TEXT_MESSAGE;     q_out                       M_IDEN%TYPE;     q_out_q                     M_IDEN_Q%TYPE;     q_out_schema                M_IDEN_SCM%TYPE;     initiator_schema            M_IDEN%TYPE;     initiator_schema_q          M_IDEN%TYPE;     BEGIN       select owner into initiator_schema from saga_participant$       where name = initiator;       initiator_schema_q := dbms_assert.enquote_name(initiator_schema, FALSE);       q_out := 'SAGA$_' || initiator || '_OUT_Q';       q_out_q := dbms_assert.enquote_name(q_out, FALSE);       q_out_schema := initiator_schema_q || '.' || q_out_q;       message_enq :=  SYS.AQ$_JMS_TEXT_MESSAGE.construct;       dbms_saga.set_saga_sender(message_enq, initiator);       dbms_saga.set_saga_recipient(message_enq, receiver);       dbms_saga.set_saga_opcode(message_enq, dbms_saga_sys.ACK_SAGA);       dbms_saga.set_saga_id(message_enq, saga_id);       message_enq.set_text(req_payload);       DBMS_AQ.ENQUEUE(queue_name => q_out_schema,                       enqueue_options    => enqueue_options,                       message_properties => message_properties_enq,                       payload  => message_enq,                       msgid   => message_handle_enq);     COMMIT;     END; BEGIN   CASE     WHEN (opcode = dbms_saga_sys.JOIN_SAGA) THEN       select count(*) into valid_sagaid from saga$ where id = deq_saga_id       and status = dbms_saga_sys.INITIATED;       IF valid_sagaid > 0 THEN         insert into saga_participant_set$ values(deq_saga_id,                                   recipient,                                   sender,                                   dbms_saga_sys.JOINED,                                   CURRENT_TIMESTAMP,                                   CURRENT_TIMESTAMP + INTERVAL '86400' SECOND);         enqueue_ack(deq_saga_id, sender,                     recipient, req_res);       END IF;     WHEN (opcode = dbms_saga.CMT_SAGA) THEN       update saga_participant_set$ set status = dbms_saga_sys.COMMITED       where saga_id = deq_saga_id and participant = sender;       COMMIT;     WHEN (opcode = dbms_saga.ABRT_SAGA) THEN       update saga_participant_set$ set status = dbms_saga_sys.ROLLEDBACK       where  saga_id = deq_saga_id and participant = sender;       COMMIT;     WHEN (opcode = dbms_saga.CMT_FAIL) THEN       update saga_participant_set$ set status = dbms_saga_sys.COMMIT_FAILED       where saga_id = deq_saga_id and participant = sender;       COMMIT;     WHEN (opcode = dbms_saga.ABRT_FAIL) THEN       update saga_participant_set$       set status = dbms_saga_sys.ROLLEDBACK_FAILED       where saga_id = deq_saga_id and participant = sender;       COMMIT;     ELSE       RAISE BAD_OPCODE;   END CASE; COMMIT; EXCEPTION   WHEN BAD_OPCODE THEN     RAISE_APPLICATION_ERROR(-20001 , 'Invalid Opcode for coordinator.');   WHEN OTHERS THEN     RAISE; END; function uniqueEntity(entity_name IN varchar2,                       entity_schema IN varchar2,                       isBroker IN boolean) return boolean as   entity_name_int             M_IDEN%TYPE;   entity_schema_int           M_IDEN%TYPE;   any_rows_found              NUMBER;   sql_stmt                    VARCHAR2(500); BEGIN   dbms_utility.canonicalize(entity_name, entity_name_int, MAX_ENTITY_NAME);   dbms_utility.canonicalize(entity_schema, entity_schema_int, MAX_ENTITY_NAME);   IF isBroker = TRUE THEN     sql_stmt := 'select count(*) from saga_message_broker$     where name = :1 and remote = ''' || dbms_saga_adm_sys.DBMS_LOCAL || '''';     execute immediate sql_stmt into any_rows_found     using entity_name_int;   ELSE     sql_stmt := 'select count(*) from saga_participant$                  where name = :1';     execute immediate sql_stmt into any_rows_found using entity_name_int;   END IF;   IF any_rows_found <> 0 THEN     RETURN FALSE;   ELSE     RETURN TRUE;   END IF; END; function uniqueEntityAtPDB(entity_name IN varchar2 ,                            broker_name IN varchar2,                            mailbox_schema IN varchar2,                            broker_pdb_link IN varchar2,                            entity_dblink IN varchar2) return boolean as   entity_name_int             M_IDEN%TYPE;   broker_name_int             M_IDEN%TYPE;   mailbox_schema_int          M_IDEN%TYPE;   dblink_int                  M_IDEN%TYPE;   entity_dblink_int           M_IDEN%TYPE;   any_rows_found              NUMBER;   sql_stmt                    VARCHAR2(700); BEGIN   IF entity_dblink IS NULL THEN     RAISE NO_DATA_FOUND;   END IF;   dbms_utility.canonicalize(entity_name, entity_name_int, MAX_ENTITY_NAME);   dbms_utility.canonicalize(broker_name, broker_name_int, MAX_ENTITY_NAME);   dbms_utility.canonicalize(mailbox_schema, mailbox_schema_int,                             MAX_IDENTIFIER_NAME);   dbms_utility.canonicalize(broker_pdb_link, dblink_int,                             MAX_IDENTIFIER_NAME);   dbms_utility.canonicalize(entity_dblink, entity_dblink_int,                             MAX_IDENTIFIER_NAME);   IF dblink_int = entity_dblink_int THEN     RETURN TRUE;   END IF;   sql_stmt := 'select count(*) from saga_participant$         where name = :1 and broker_id =         (select id from saga_message_broker$         where name = :2 and owner = :3         and remote = '''|| dbms_saga_adm_sys.DBMS_LOCAL || ''')';   execute immediate sql_stmt into any_rows_found     using entity_name_int, broker_name_int , mailbox_schema_int;   IF any_rows_found <> 0 THEN     RETURN FALSE;   ELSE     RETURN TRUE;   END IF; END; procedure getBrokerInfo(broker_id IN OUT RAW,                         broker_name IN OUT varchar2,                         broker_schema IN OUT varchar2,                         isCreate IN BOOLEAN) AS   broker_name_int      M_IDEN%TYPE;   broker_schema_int    M_IDEN%TYPE; BEGIN   IF isCreate = TRUE THEN     dbms_utility.canonicalize(broker_name, broker_name_int, MAX_ENTITY_NAME);     dbms_utility.canonicalize(broker_schema, broker_schema_int,                               MAX_IDENTIFIER_NAME);     select id into broker_id from saga_message_broker$     where name = broker_name_int and owner = broker_schema_int;   ELSE     select owner, name into broker_name, broker_schema     from saga_message_broker$ where id = broker_id;   END IF; END; procedure updateCallbackInfo(cbk_schema IN varchar2,                              cbk_package IN varchar2,                              p_status IN number,                              p_id IN RAW,                              saga_secret IN number) AS   cbk_schema_int         M_IDEN%TYPE;   cbk_pkg_int            M_IDEN%TYPE; BEGIN   IF cbk_schema IS NOT NULL THEN     dbms_utility.canonicalize(cbk_schema, cbk_schema_int, MAX_IDENTIFIER_NAME);   END IF;   IF cbk_package IS NOT NULL THEN     dbms_utility.canonicalize(cbk_package, cbk_pkg_int, MAX_IDENTIFIER_NAME);   END IF;   update saga_participant$ set callback_schema = cbk_schema_int,         callback_package = cbk_pkg_int,         participant_iscomplete = p_status         where id = p_id; EXCEPTION   WHEN OTHERS THEN     RAISE; END; function validateSecret(entity_id IN RAW,                         saga_operation IN NUMBER,                         saga_secret IN NUMBER) return boolean AS   any_rows_found        NUMBER; BEGIN   select count(*) into any_rows_found from saga_secrets$   where id = entity_id and secret = saga_secret;   IF any_rows_found <> 1 THEN     RETURN FALSE;   ELSE     RETURN TRUE;   END IF; END; procedure write_trace(   message      IN varchar2,   event        IN binary_integer DEFAULT 10855,   event_level  IN binary_integer DEFAULT 1,   time_info    IN boolean DEFAULT FALSE) AS   event_value BINARY_INTEGER := 0; BEGIN   IF bitand(event_value, event_level) = event_level THEN     dump_trace(message, time_info);   END IF; END write_trace; procedure dump_trace(   message      IN varchar2,   time_info    IN boolean DEFAULT FALSE) AS   pos        BINARY_INTEGER := 1;   mesg_len   BINARY_INTEGER := LENGTH(message); BEGIN   WHILE pos <= mesg_len LOOP     pos := pos + 80;   END LOOP; END dump_trace; end dbms_saga_adm_sys;";
        OsagaInfra.SQL[14] = "create or replace package body dbms_saga_sys as M_IDEN                  VARCHAR2(128); M_IDEN_Q                VARCHAR2(130); M_IDEN_SCM              VARCHAR2(261); MAX_ENTITY_NAME         CONSTANT BINARY_INTEGER := 115; procedure call_callbacks(package_name    IN VARCHAR2,                          package_schema  IN VARCHAR2,                          proc_name       IN VARCHAR2,                          saga_id         IN saga_id_t,                          initiator       IN VARCHAR2,                          saga_initiator  IN VARCHAR2,                          coordinator     IN VARCHAR2,                          payload         IN JSON DEFAULT NULL); procedure write_trace(message       IN VARCHAR2,                       event         IN BINARY_INTEGER DEFAULT 10855,                       event_level   IN BINARY_INTEGER DEFAULT 1,                       time_info     IN BOOLEAN DEFAULT FALSE); procedure dump_trace(message    IN  varchar2,                      time_info  IN boolean DEFAULT FALSE); procedure commit_or_rollback(saga_participant IN VARCHAR2,                               deq_saga_id IN saga_id_t,                               saga_opcode IN NUMBER,                               force IN boolean DEFAULT TRUE,                               current_user IN VARCHAR2); procedure commit_or_rollback_int(participant_name IN VARCHAR2,                                  participant_level IN NUMBER,                                  saga_id IN saga_id_t,                                  saga_opcode IN NUMBER,                                  force IN BOOLEAN,                                  saga_status IN NUMBER,                                  saga_sender IN VARCHAR2,                                  coordinator IN VARCHAR2,                                  cbk_package IN VARCHAR2,                                  cbk_schema IN VARCHAR2); procedure enqueue_opcode(saga_id IN saga_id_t,                          sender IN VARCHAR2,                          recipient IN VARCHAR2,                          opcode IN NUMBER); function begin_saga(initiator_name IN VARCHAR2 ,                     timeout IN number DEFAULT NULL,                     current_user IN VARCHAR2) return saga_id_t AS   stmt                  VARCHAR2(500);   coordinator_name      M_IDEN%TYPE;   owner_schema          M_IDEN%TYPE;   initiator_name_int    M_IDEN%TYPE;   guid                  RAW(16);   INVALIDENTITY         EXCEPTION;   UNAUTHACCESS          EXCEPTION; BEGIN   dbms_utility.canonicalize(initiator_name, initiator_name_int, MAX_ENTITY_NAME);   stmt := 'select s1.owner, s2.name from saga_participant$ s1,            saga_participant$ s2 where s1.coordinator_id = s2.id and            s1.name = :1';   BEGIN     execute immediate stmt into owner_schema,                                 coordinator_name using initiator_name_int;   EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE INVALIDENTITY;   END;   IF owner_schema <> current_user THEN    RAISE UNAUTHACCESS;   END IF;   guid := sys_guid();   insert into saga$ values(guid, dbms_saga_sys.INITIATOR,                                initiator_name_int,                                coordinator_name, owner_schema,                                initiator_name_int, timeout, CURRENT_TIMESTAMP,                                NULL, dbms_saga_sys.INITIATED);   RETURN guid; COMMIT; EXCEPTION   WHEN INVALIDENTITY THEN     RAISE_APPLICATION_ERROR(-20001 , 'Entity Not Found: The participant or     its coordinator was not found');   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001, 'Unauthorized Access: owner of the     initiator does not match the current user');   WHEN OTHERS THEN     RAISE; END; procedure commit_saga(saga_participant IN VARCHAR2,                       saga_id IN saga_id_t,                       force IN boolean DEFAULT TRUE,                       current_user IN varchar2) AS   UNAUTHACCESS        EXCEPTION; BEGIN   commit_or_rollback(saga_participant, saga_id, dbms_saga_sys.CMT_SAGA, force,                      current_user); EXCEPTION   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001, 'Unauthorized Access: owner of the     initiator does not match the current user');   WHEN OTHERS THEN     RAISE; END; procedure rollback_saga(saga_participant IN VARCHAR2,                         saga_id IN saga_id_t,                         force IN boolean DEFAULT TRUE,                         current_user IN varchar2) AS BEGIN   commit_or_rollback(saga_participant, saga_id, dbms_saga_sys.ABRT_SAGA, force,                      current_user); EXCEPTION   WHEN OTHERS THEN     RAISE; END; function get_out_topic(entity_name IN varchar2) return varchar2 as   out_queue         M_IDEN%TYPE;   entity_schema     M_IDEN%TYPE;   entity_name_int   M_IDEN%TYPE;   out_queue_q       M_IDEN_Q%TYPE;   entity_schema_q   M_IDEN_Q%TYPE; BEGIN   dbms_utility.canonicalize(entity_name, entity_name_int, MAX_ENTITY_NAME);   select outgoing_topic,owner into out_queue, entity_schema   from saga_participant$ where name = entity_name_int;   out_queue_q := dbms_assert.enquote_name(out_queue, FALSE);   entity_schema_q := dbms_assert.enquote_name(entity_schema, FALSE);   return entity_schema_q || '.' || out_queue_q; EXCEPTION   WHEN NO_DATA_FOUND THEN     RAISE_APPLICATION_ERROR(-20001 , 'Cannot fetch out queue. Please check     the entity name');   WHEN OTHERS THEN     RAISE; END; procedure process_notification(recipient IN varchar2,                                sender IN varchar2,                                saga_id IN saga_id_t,                                opcode IN number,                                coordinator IN varchar2,                                req_res IN clob) AS   cbk_schema              M_IDEN%TYPE;   cbk_package             M_IDEN%TYPE;   saga_initiator          M_IDEN%TYPE;   req_res_json            JSON;   join_status             NUMBER;   BAD_OPCODE              EXCEPTION; BEGIN   BEGIN     select callback_schema, callback_package into cbk_schema,            cbk_package from saga_participant$     where name = recipient;   EXCEPTION     WHEN NO_DATA_FOUND THEN       cbk_schema := NULL;       cbk_package := NULL;   END;   IF req_res IS NOT NULL THEN     req_res_json := json(req_res);   END IF;   CASE     WHEN (opcode = dbms_saga_sys.REQUEST) THEN       join_status := join_saga_int(saga_id, recipient,                                    sender, coordinator, req_res);        IF join_status = dbms_saga_sys.JOIN_EXISTS THEN          call_callbacks(cbk_package, cbk_schema, 'REQUEST', saga_id,                         recipient, sender, coordinator, req_res_json);        END IF;     WHEN (opcode = dbms_saga_sys.ACK_SAGA) THEN       update saga$ set status = dbms_saga_sys.JOINED where id = saga_id       and participant = recipient;       select initiator into saga_initiator from saga$       where id = saga_id and participant = recipient;       call_callbacks(cbk_package, cbk_schema, 'REQUEST', saga_id, recipient,                      saga_initiator, sender, req_res_json);     WHEN (opcode = dbms_saga_sys.CMT_SAGA) THEN       commit_or_rollback_int(recipient, dbms_saga_sys.PARTICIPANT, saga_id,         dbms_saga_sys.CMT_SAGA, TRUE, null, sender, sender, cbk_package,         cbk_schema);     WHEN (opcode = dbms_saga_sys.ABRT_SAGA) THEN       commit_or_rollback_int(recipient, dbms_saga_sys.PARTICIPANT, saga_id,         dbms_saga_sys.ABRT_SAGA, TRUE, null, sender, sender, cbk_package,         cbk_schema);     WHEN (opcode = dbms_saga_sys.RESPONSE) THEN       call_callbacks(cbk_package, cbk_schema, 'RESPONSE', saga_id,                      null, sender, null, req_res_json);     ELSE       RAISE BAD_OPCODE;   END CASE; COMMIT; EXCEPTION   WHEN BAD_OPCODE THEN     RAISE_APPLICATION_ERROR(-20001 , 'bad opcode');   WHEN OTHERS THEN     RAISE; END; procedure commit_or_rollback(saga_participant IN VARCHAR2,                              deq_saga_id IN saga_id_t,                              saga_opcode IN NUMBER,                              force IN boolean DEFAULT TRUE,                              current_user IN VARCHAR2) AS   saga_level_entity    NUMBER;   coordinator_name     M_IDEN%TYPE;   saga_owner           M_IDEN%TYPE;   participant_int      M_IDEN%TYPE;   saga_status          NUMBER;   return_opcode        NUMBER;   type enqueue_record is record(     participant_name M_IDEN%TYPE,     status           NUMBER   );   type enqueue_record_list is table of enqueue_record;   er enqueue_record_list;   collection_stmt      VARCHAR2(500);   INVALIDSAGAID        EXCEPTION;   UNAUTHACCESS         EXCEPTION; BEGIN   dbms_utility.canonicalize(saga_participant, participant_int,                             MAX_ENTITY_NAME);   BEGIN     select saga_level, coordinator, status, owner into saga_level_entity,     coordinator_name, saga_status, saga_owner     from saga$ where id = deq_saga_id and participant = participant_int;   EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE INVALIDSAGAID;   END;   IF saga_owner <> current_user THEN    RAISE UNAUTHACCESS;   END IF;   IF saga_level_entity = dbms_saga_sys.INITIATOR THEN     collection_stmt := 'select participant,status from                         saga_participant_set$ where                         saga_id= :1';     execute immediate collection_stmt bulk collect into er using deq_saga_id;     IF er.count > 0 THEN       FOR i in er.first .. er.last LOOP         update saga_participant_set$         set status = dbms_saga_sys.FINALIZATION         where participant = er(i).participant_name         and saga_id = deq_saga_id;         enqueue_opcode(deq_saga_id, coordinator_name, er(i).participant_name,                        saga_opcode);       END LOOP;     END IF;   END IF;   commit_or_rollback_int(participant_int, saga_level_entity, deq_saga_id,                  saga_opcode, force, saga_status, participant_int,                  coordinator_name, null, null); EXCEPTION   WHEN INVALIDSAGAID THEN     RAISE_APPLICATION_ERROR(-20001 , 'Saga ID not found');   WHEN UNAUTHACCESS THEN     RAISE_APPLICATION_ERROR(-20001, 'Unauthorized Access: owner of the     initiator does not match the current user');   WHEN OTHERS THEN     RAISE; END; procedure commit_or_rollback_int(participant_name IN VARCHAR2,                                  participant_level IN NUMBER,                                  saga_id IN saga_id_t,                                  saga_opcode IN NUMBER,                                  force IN BOOLEAN,                                  saga_status IN NUMBER,                                  saga_sender IN VARCHAR2,                                  coordinator IN VARCHAR2,                                  cbk_package IN VARCHAR2,                                  cbk_schema IN VARCHAR2) AS   saga_status_int      NUMBER;   cbk_package_int      M_IDEN%TYPE;   cbk_schema_int       M_IDEN%TYPE;   cr_result            BOOLEAN := TRUE;   return_opcode        NUMBER;   INVALIDSAGAID        EXCEPTION; BEGIN   BEGIN     IF saga_status IS NULL THEN       select status into saga_status_int from saga$ where id = saga_id and       participant = participant_name;     ELSE       saga_status_int := saga_status;     END IF;   EXCEPTION     WHEN NO_DATA_FOUND THEN       RAISE INVALIDSAGAID;   END;   BEGIN     IF cbk_package IS NULL THEN      select callback_schema, callback_package into cbk_schema_int,       cbk_package_int from saga_participant$ where name = participant_name;     ELSE       cbk_package_int := cbk_package;       cbk_schema_int := cbk_schema;     END IF;   EXCEPTION     WHEN NO_DATA_FOUND THEN       cbk_schema_int := NULL;       cbk_package_int := NULL;   END;   IF saga_status_int = dbms_saga_sys.JOINED THEN     IF saga_opcode = dbms_saga_sys.CMT_SAGA THEN       call_callbacks(cbk_package, cbk_schema, 'BEFORE_COMMIT', saga_id,                      null, saga_sender, null, null);       IF cr_result = TRUE THEN         return_opcode := dbms_saga_sys.CMT_SAGA;         saga_status_int := dbms_saga_sys.COMMITED;       ELSE         return_opcode := dbms_saga_sys.CMT_FAIL;         saga_status_int := dbms_saga_sys.COMMIT_FAILED;       END IF;       call_callbacks(cbk_package, cbk_schema, 'AFTER_COMMIT', saga_id,                      null, saga_sender, null, null);     ELSIF saga_opcode = dbms_saga_sys.ABRT_SAGA THEN       call_callbacks(cbk_package, cbk_schema, 'BEFORE_ROLLBACK', saga_id,                      null, saga_sender, null, null);       IF cr_result = TRUE THEN         return_opcode := dbms_saga_sys.ABRT_SAGA;         saga_status_int := dbms_saga_sys.ROLLEDBACK;       ELSE         return_opcode := dbms_saga_sys.ABRT_FAIL;         saga_status_int := dbms_saga_sys.ROLLEDBACK_FAILED;       END IF;       call_callbacks(cbk_package, cbk_schema, 'AFTER_ROLLBACK', saga_id,                      null, saga_sender, null, null);     END IF;     update saga$ set status = saga_status_int, end_time = CURRENT_TIMESTAMP     where id = saga_id and participant = participant_name;   END IF;   IF participant_level = dbms_saga_sys.PARTICIPANT THEN     enqueue_opcode(saga_id, participant_name, coordinator,                           return_opcode);   END IF; COMMIT; EXCEPTION   WHEN INVALIDSAGAID THEN     RAISE_APPLICATION_ERROR(-20001 , 'Saga ID not found'); END; function join_saga_int(saga_id IN saga_id_t,                         initiator_name IN VARCHAR2,                         saga_initiator IN VARCHAR2,                         coordinator IN VARCHAR2,                         payload IN CLOB) return NUMBER as   dequeue_options       dbms_aq.dequeue_options_t;   message_properties    dbms_aq.message_properties_t;   message_handle        RAW(16);   message               SYS.AQ$_JMS_TEXT_MESSAGE;   initiator_schema      M_IDEN%TYPE;   initiator_schema_q    M_IDEN_Q%TYPE;   saga_status           NUMBER;   procedure enqueue_coordinator(saga_id IN saga_id_t,                                 initiator_schema IN VARCHAR2,                                 initiator_name IN VARCHAR2,                                 coordinator_name IN VARCHAR2,                                 saga_initiator IN VARCHAR2,                                 payload IN CLOB) is     enqueue_options         dbms_aq.enqueue_options_t;     message_properties_enq  dbms_aq.message_properties_t;     message_handle_enq      RAW(16);     message_enq             SYS.AQ$_JMS_TEXT_MESSAGE;     subscriber_ack          SYS.aq$_agent;     q_out                   M_IDEN%TYPE;     q_out_q                 M_IDEN_Q%TYPE;     q_out_schema            M_IDEN_SCM%TYPE;     q_in                    M_IDEN%TYPE;     pragma autonomous_transaction;   BEGIN     write_trace('JOIN_SAGA_INT : enqueue a join message                  to the coordinator. Saga ID : ' || saga_id);     q_out := 'SAGA$_' || initiator_name || '_OUT_Q';     q_out_q := dbms_assert.enquote_name(q_out, FALSE);     initiator_schema_q := dbms_assert.enquote_name(initiator_schema, FALSE);     q_out_schema := initiator_schema_q || '.' || q_out_q;     message_enq :=  SYS.AQ$_JMS_TEXT_MESSAGE.construct;     dbms_saga.set_saga_sender(message_enq, initiator_name);     dbms_saga.set_saga_recipient(message_enq, coordinator_name);     dbms_saga.set_saga_opcode(message_enq, dbms_saga_sys.JOIN_SAGA);     dbms_saga.set_saga_id(message_enq, saga_id);     message_enq.set_text(payload);     DBMS_AQ.ENQUEUE(queue_name => q_out_schema,                     enqueue_options    => enqueue_options,                     message_properties => message_properties_enq,                     payload  => message_enq,                     msgid   => message_handle_enq);     insert into saga$ values(saga_id, dbms_saga_sys.PARTICIPANT,                                  saga_initiator, coordinator_name,                                  initiator_schema,                                  initiator_name, 86400, CURRENT_TIMESTAMP,                                  NULL, dbms_saga_sys.JOINING);   COMMIT;   END; BEGIN   write_trace('JOIN_SAGA_INT : begin join_saga_int');   BEGIN     select status into saga_status from saga$ where id = saga_id     and participant = initiator_name;     IF saga_status = dbms_saga_sys.JOINED THEN       return dbms_saga_sys.JOIN_EXISTS;     ELSE       return dbms_saga_sys.JOIN_SKIP;     END IF;   EXCEPTION     WHEN NO_DATA_FOUND THEN       null;   END;   select owner into initiator_schema from saga_participant$   where name = initiator_name;   enqueue_coordinator(saga_id, initiator_schema, initiator_name,                       coordinator, saga_initiator, payload);   write_trace('JOIN_SAGA_INT : end join_saga_int');   return dbms_saga_sys.JOIN_SUCCESS; END; procedure enqueue_opcode(saga_id IN saga_id_t,                          sender IN VARCHAR2,                          recipient IN VARCHAR2,                          opcode IN NUMBER) AS   enqueue_options         dbms_aq.enqueue_options_t;   message_properties      dbms_aq.message_properties_t;   message_handle          RAW(16);   message                 SYS.AQ$_JMS_TEXT_MESSAGE;   q_out                   M_IDEN%TYPE;   q_out_q                 M_IDEN_Q%TYPE;   q_out_schema            M_IDEN_SCM%TYPE;   s_schema                M_IDEN%TYPE;   s_schema_q              M_IDEN_Q%TYPE; BEGIN   select owner into s_schema from saga_participant$   where name = sender;   s_schema_q := dbms_assert.enquote_name(s_schema, FALSE);   q_out := 'SAGA$_' || sender || '_OUT_Q';   q_out_q := dbms_assert.enquote_name(q_out, FALSE);   q_out_schema := s_schema_q || '.' || q_out_q;   message :=  SYS.AQ$_JMS_TEXT_MESSAGE.construct;   dbms_saga.set_saga_sender(message, sender);   dbms_saga.set_saga_recipient(message, recipient);   dbms_saga.set_saga_opcode(message, opcode);   dbms_saga.set_saga_id(message, saga_id);   DBMS_AQ.ENQUEUE(queue_name         => q_out_schema,                   enqueue_options    => enqueue_options,                   message_properties => message_properties,                   payload            => message,                   msgid              => message_handle); COMMIT; END; procedure call_callbacks(package_name    IN VARCHAR2,                          package_schema  IN VARCHAR2,                          proc_name       IN VARCHAR2,                          saga_id         IN saga_id_t,                          initiator       IN VARCHAR2,                          saga_initiator  IN VARCHAR2,                          coordinator     IN VARCHAR2,                          payload         IN JSON DEFAULT NULL) as   v_sql                 VARCHAR2(700);   pkg_owner_q           M_IDEN_Q%TYPE;   pkg_name_q            M_IDEN_Q%TYPE;   proc_name_q           M_IDEN_Q%TYPE;   package_def           VARCHAR2(650);   procedure_exists      NUMBER;   response              JSON;   procedure enqueue_response(saga_id IN saga_id_t , receiver IN VARCHAR2 ,                              sender IN VARCHAR2,                              coordinator_name in VARCHAR2) is     enqueue_options     dbms_aq.enqueue_options_t;     message_properties  dbms_aq.message_properties_t;     message_handle      RAW(16);     message             SYS.AQ$_JMS_TEXT_MESSAGE;     q_out               M_IDEN%TYPE;     q_out_q             M_IDEN_Q%TYPE;     q_out_schema        M_IDEN_SCM%TYPE;     sender_schema       M_IDEN%TYPE;   BEGIN     BEGIN       select owner into sender_schema from saga_participant$       where name = sender;     EXCEPTION       WHEN NO_DATA_FOUND THEN         RETURN;     END;     q_out := 'SAGA$_' || sender || '_OUT_Q';     q_out_q := dbms_assert.enquote_name(q_out, FALSE);     q_out_schema := sender_schema || '.' || q_out_q;     message :=  SYS.AQ$_JMS_TEXT_MESSAGE.construct;     dbms_saga.set_saga_sender(message, sender);     dbms_saga.set_saga_recipient(message, receiver);     dbms_saga.set_saga_opcode(message, dbms_saga_sys.RESPONSE);     dbms_saga.set_saga_id(message, saga_id);     message.set_text(to_clob(json_serialize(response)));     DBMS_AQ.ENQUEUE(queue_name => q_out_schema,                     enqueue_options    => enqueue_options,                     message_properties => message_properties,                     payload  => message,                     msgid   => message_handle);     COMMIT;     END; BEGIN   BEGIN     select count(*) into procedure_exists from all_procedures     where object_name = package_name     and owner = package_schema     and procedure_name = proc_name;     IF procedure_exists = 0 THEN       RETURN;     END IF;   END;   pkg_owner_q := dbms_assert.enquote_name(package_schema, FALSE);   pkg_name_q := dbms_assert.enquote_name(package_name, FALSE);   proc_name_q := dbms_assert.enquote_name(proc_name, FALSE);   package_def := pkg_owner_q || '.' || pkg_name_q                              || '.' || proc_name_q;   IF coordinator IS NOT NULL THEN     v_sql := 'BEGIN :r := ' ||               package_def ||               '(:1,:2,:3); END;';     execute immediate v_sql using out response, in saga_id,                                             in saga_initiator, in payload;     enqueue_response(saga_id, saga_initiator, initiator, coordinator);   ELSE     v_sql := 'BEGIN ' ||              package_def ||              '(:1,:2,:3); END;';     execute immediate v_sql using saga_id, saga_initiator, payload;   END IF; COMMIT; END; procedure write_trace(       message      IN varchar2,       event        IN binary_integer DEFAULT 10855,       event_level  IN binary_integer DEFAULT 1,       time_info    IN boolean DEFAULT FALSE) AS   event_value BINARY_INTEGER := 0; BEGIN   IF bitand(event_value, event_level) = event_level THEN     dump_trace(message, time_info);   END IF; END write_trace; procedure dump_trace(     message      IN varchar2,     time_info    IN boolean DEFAULT FALSE) AS   pos        BINARY_INTEGER := 1;   mesg_len   BINARY_INTEGER := LENGTH(message); BEGIN   WHILE pos <= mesg_len LOOP     pos := pos + 80;   END LOOP; END dump_trace; end dbms_saga_sys;";
        OsagaInfra.SQL[15] = "create or replace package body dbms_saga_connect_int as function isTrusted(dblink_to_entity_int IN varchar2,                    participant_id IN RAW,                    saga_operation IN NUMBER,                    saga_secret IN NUMBER) return boolean; procedure connectBrokerToInqueue(participant_id IN RAW,                                  entity_name_int IN varchar2 ,                                  entity_schema_int IN varchar2 ,                                  coordinatorOrParticipant IN number,                                  broker_id IN RAW,                                  coordinator_id IN RAW,                                  dblink_to_broker_int IN varchar2,                                  dblink_to_entity_int IN varchar2,                                  inbound_queue IN varchar2,                                  outbound_queue IN varchar2,                                  callback_schema_int IN varchar2 ,                                  callback_package_int IN varchar2 ,                                  participant_iscomplete IN number,                                  broker_schema_int IN varchar2 ,                                  broker_name_int IN varchar2,                                  saga_secret IN number) AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   IF isTrusted(dblink_to_entity_int, participant_id,                dbms_saga_adm_sys.CONNECT_BROKER, saga_secret) THEN     dbms_saga_adm_sys.connectBrokerToInqueue(                         participant_id => participant_id,                         entity_name_int => entity_name_int,                         entity_schema_int => entity_schema_int,                         coordinatorOrParticipant => coordinatorOrParticipant,                         broker_id => broker_id,                         coordinator_id => coordinator_id,                         dblink_to_broker_int => dblink_to_broker_int,                         dblink_to_entity_int => dblink_to_entity_int,                         inbound_queue => inbound_queue,                         outbound_queue => outbound_queue,                         callback_schema_int => callback_schema_int,                         callback_package_int => callback_package_int,                         participant_iscomplete => participant_iscomplete,                         broker_schema_int => broker_schema_int,                         broker_name_int => broker_name_int,                         saga_secret => saga_secret);   ELSE     RAISE NO_DATA_FOUND;   END IF; END; procedure disconnectBrokerFromInqueue(entity_name_int IN varchar2 ,                                       entity_schema_int IN varchar2,                                       dblink_to_entity_int IN varchar2,                                       broker_schema_int IN varchar2,                                       broker_name_int IN varchar2,                                       dblink_to_broker IN varchar2,                                       entity_id IN RAW,                                       saga_secret IN number) AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   IF isTrusted(dblink_to_entity_int, entity_id,                dbms_saga_adm_sys.DISCONNECT_BROKER, saga_secret) THEN     dbms_saga_adm_sys.disconnectBrokerFromInqueue(                                 entity_name_int => entity_name_int,                                 entity_schema_int => entity_schema_int,                                 dblink_to_entity_int => dblink_to_entity_int,                                 broker_schema_int => broker_schema_int,                                 broker_name_int => broker_name_int,                                 dblink_to_broker => dblink_to_broker,                                 entity_id => entity_id,                                 saga_secret => saga_secret);   ELSE     RAISE NO_DATA_FOUND;   END IF; END; function uniqueEntityAtPDB(entity_name IN varchar2,                            broker_name IN varchar2,                            mailbox_schema IN varchar2,                            broker_pdb_link IN varchar2,                            entity_dblink IN varchar2) return boolean AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   RETURN dbms_saga_adm_sys.uniqueEntityAtPDB(                                           entity_name => entity_name,                                           broker_name => broker_name,                                           mailbox_schema => mailbox_schema,                                           broker_pdb_link => broker_pdb_link,                                           entity_dblink => entity_dblink); END; procedure getBrokerInfo(broker_id IN OUT RAW,                         broker_name IN OUT varchar2,                         broker_schema IN OUT varchar2,                         isCreate IN BOOLEAN) AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   dbms_saga_adm_sys.getBrokerInfo(broker_id => broker_id,                                       broker_name => broker_name,                                       broker_schema => broker_schema,                                       isCreate => isCreate); END; procedure updateCallbackInfo(cbk_schema IN varchar2,                              cbk_package IN varchar2,                              p_status IN number,                              p_id IN RAW,                              saga_secret IN number) AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   dbms_saga_adm_sys.updateCallbackInfo(cbk_schema => cbk_schema,                                            cbk_package => cbk_package,                                            p_status => p_status,                                            p_id => p_id,                                            saga_secret => saga_secret); END; function validateSecret(entity_id IN RAW,                         saga_operation IN NUMBER,                         saga_secret IN NUMBER) return boolean AS BEGIN   IF upper(sys_context('userenv','IS_DG_ROLLING_UPGRADE'))  = 'TRUE' THEN     RAISE dbms_saga_connect_int.ROLLINGUNSUPPORTED;   END IF;   RETURN dbms_saga_adm_sys.validateSecret(                                     entity_id => entity_id,                                     saga_operation => saga_operation,                                     saga_secret => saga_secret); END; function isTrusted(dblink_to_entity_int IN varchar2,                    participant_id IN RAW,                    saga_operation IN NUMBER,                    saga_secret IN NUMBER) return boolean AS   validation_success    BOOLEAN;   validation_string     VARCHAR2(500);   v_sql                 VARCHAR2(1500);   dblink_entity_q       VARCHAR2(130); BEGIN   IF dblink_to_entity_int IS NOT NULL THEN     dblink_entity_q := dbms_assert.enquote_name(dblink_to_entity_int, FALSE);     validation_string := ':r := dbms_saga_connect_int'                       || '.' || 'validateSecret' || '@' || dblink_entity_q;   ELSE     validation_string := ':r := dbms_saga_connect_int'                       || '.' || 'validateSecret';   END IF;   v_sql := 'BEGIN' ||            validation_string ||            '(:1, :2, :3); END;';   execute immediate v_sql using OUT validation_success, IN participant_id,               IN saga_operation, IN saga_secret;   RETURN validation_success; END; end dbms_saga_connect_int;";
        OsagaInfra.createEnrollParticipant = "CREATE OR REPLACE PROCEDURE ENROLL_PARTICIPANT_IN_SAGA ( PARTICIPANTTYPE IN VARCHAR2,                     RESERVATIONTYPE IN VARCHAR2,                     RESERVATIONVALUE IN VARCHAR2,                     SAGANAME IN VARCHAR2,                     SAGAID IN VARCHAR2             )     IS     request JSON;     BEGIN     request := json('[{\"flight\":\"United\"}]');     dbms_saga.enroll_participant(SAGAID, SAGANAME, PARTICIPANTTYPE, 'TravelCoordinator', request);     END;";
    }
}
