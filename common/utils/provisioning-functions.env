#!/bin/bash
# Copyright (c) 2021 Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

# All functions assume the current directory is to contain the state of the thing to be provisioned or contains
# the state of the thing to be worked on.

if ! (return 0 2>/dev/null); then
  echo "ERROR: Usage 'source provisioning_functions.env'"
  return 1
fi

# provisioning-apply()
#   Provision something.  Current directory is to be used to store the state.
#   $1: The code home of the thing to be provisioned (required)
#
#   If the byo file exists then do nothing
#   Checks and creates the MY_CODE file
#   Validates the required input parameters, constructs the state file, and removes the input file
#   Executes apply.sh
#
function provisioning-apply() {
  local MY_STATE=$PWD
  local OUTPUT_FILE=$MY_STATE/output.env
  local STATE_FILE=$MY_STATE/state.env
  local INPUT_FILE=$MY_STATE/input.env
 
  # Skip provisioning?
  if test -f $MY_STATE/byo; then
    return
  fi

  # See if we are already done
  if test -f $OUTPUT_FILE; then
    echo "$MY_STATE apply is complete"
    return
  fi

  # Locate and check the code home
  local MY_CODE
  local MY_CODE_FILE=$MY_STATE/MY_CODE
  if test -f $MY_CODE_FILE; then
    MY_CODE=$(<$MY_CODE_FILE)
    if test "$MY_CODE" != "$1"; then
      echo "ERROR: Code folder $MY_CODE already set.  Cannot be changed to $1."
      return 1
    fi
  else
    MY_CODE="$1"
  fi
  
  if ! test -d $MY_CODE; then
    echo "ERROR: Code folder $MY_CODE does not exist"
    return 1
  fi
  echo "$MY_CODE" > $MY_CODE_FILE
  
  local REQ_UTILS REQ_INPUT_PARAMS REQ_OUTPUT_PARAMS
  local REQ_FILE=$MY_CODE/requirements.env
  if ! test -f $REQ_FILE; then
    echo "ERROR: Invalid code folder $MY_CODE.  $REQ_FILE is missing."
    return 1
  fi
  source $REQ_FILE

  # Validate required utils TODO

  # Populate the state file with input
  if ! test -f $STATE_FILE; then
    # Not already populated
    if test -z "$REQ_INPUT_PARAMS"; then
      # No required parameters, no input required, empty init state file
      echo "" > $STATE_FILE
    elif ! test -f $INPUT_FILE; then
      # Input file is missing
      echo "$INPUT_FILE is missing"
      return 1
    else
      # Populate init state
      local TEMP_STATE_FILE=$MY_STATE/temp_state.env
      echo -n "" > $TEMP_STATE_FILE
      # Process input file in a subshell so we don't polute this shell
      if (
        source $INPUT_FILE
        for p in $REQ_INPUT_PARAMS; do
          if test -z "${!p}"; then
            echo "ERROR: Parameter $p is required and not set"
            exit 1
          fi
          echo "$p='${!p}'" >>$TEMP_STATE_FILE
        done
      ); then
        # If successful then make it permanent
        mv $TEMP_STATE_FILE $STATE_FILE
        source $STATE_FILE
      else
        return 1
      fi
    fi
  fi

  # Done with the input file so remove it
  rm -f $INPUT_FILE

  # Execute the apply.sh (if it exists)
  if test -f $MY_CODE/apply.sh; then
    cd $MY_STATE
    echo "Beginning $MY_CODE/apply.sh on $MY_STATE"
    echo "apply" >$MY_STATE/phase
    $MY_CODE/apply.sh
  else
    echo "ERROR: No apply script in code folder $MY_CODE"
    return 1
  fi

  cd $MY_STATE

  if ! test -f $OUTPUT_FILE; then
    # We ran setup and no output file, so looks like we failed
    echo "ERROR: Provisioning-apply failed for code $MY_CODE in state folder $MY_STATE."
    return 1
  fi

  # Validate the output TODO
  echo "applied" >$MY_STATE/phase
  echo "Completed $MY_CODE/apply.sh on $MY_STATE"
}


# provisioning-destroy()
#   Destroy something previsouly provisioned.
#   Current directory contains the state of the thing to be destroyed.  
#   The MY_CODE file within the state folder contains the location of the code (from previously run apply).
#
#   If the byo file exists then do nothing
#   Checks the MY_CODE file
#   Executes destroy.sh
#

function provisioning-destroy() {
  local MY_STATE=$PWD
  local OUTPUT_FILE=$MY_STATE/output.env
  local STATE_FILE=$MY_STATE/state.env
  local INPUT_FILE=$MY_STATE/input.env

  # Skip provisioning if BYO?
  if test -f $MY_STATE/byo; then
    return
  fi

  # Find my code
  local MY_CODE_FILE=$MY_STATE/MY_CODE
  if ! test -f $MY_CODE_FILE; then
    echo "ERROR: $MY_CODE_FILE is missing.  Cannot destroy what has never been created."
    return 1
  fi
  local MY_CODE=$(<$MY_CODE_FILE)

  if ! test -d $MY_CODE; then
    echo "ERROR: Code folder $MY_CODE does not exist"
    return 1
  fi

  if ! test -f $MY_CODE/destroy.env && ! test -f $MY_CODE/destroy.sh; then
    echo "ERROR: No destroy script in code folder $MY_CODE"
    return 1
  fi
  
  # Execute the destroy.sh (is it exists)
  if test -f $MY_CODE/destroy.sh; then
    cd $MY_STATE
    echo "Beginning $MY_CODE/destroy.sh on $MY_STATE"
    echo "destroy" >$MY_STATE/phase
    $MY_CODE/destroy.sh
  else
    echo "ERROR: No destroy script in code folder $MY_CODE"
    return 1
  fi

  cd $MY_STATE

  if test -f $STATE_FILE; then
    # We ran destroy and the state file still exists, so looks like we failed
    echo "ERROR: Provisioning destroy failed for code $MY_CODE in state folder $MY_STATE"
    return 1
  fi

  echo "Completed $MY_CODE/destroy.sh on $MY_STATE"
  echo "destroyed" >$MY_STATE/phase
}


# provisioning-helper-pre-apply()
#
# First thing to run in every executed apply function
#   Sets the MY_STATE, STATE_FILE and OUTPUT_FILE variables
#   Finds and sets the MY_CODE variable
#   Exits it the apply has already been done
#   Checks and sets PID file so only one instance can be running
#   Sets the STATE_FILE variable and sources the file
#
function provisioning-helper-pre-apply() {
  MY_STATE=$PWD
  OUTPUT_FILE=$MY_STATE/output.env
  STATE_FILE=$MY_STATE/state.env
  INPUT_FILE=$MY_STATE/input.env

  # Locate my code
  MY_CODE_FILE=$MY_STATE/MY_CODE
  if ! test -f "$MY_CODE_FILE"; then
    echo "ERROR: Invalid state directory.  $MY_CODE_FILE does not exist."
    exit 1
  fi
  MY_CODE=$(<$MY_CODE_FILE)

  # See if we are already done (output file exists)
  if test -f $OUTPUT_FILE; then
    echo "$MY_STATE apply is complete"
    exit
  fi

  # Prevent parallel execution
  PID_FILE=$MY_STATE/PID
  if test -f $PID_FILE && ps -fp $(<$PID_FILE); then
      echo "A script is already running against ${MY_STATE}."
      echo "If you want to run an operation on it, kill process $(cat $PID_FILE), delete the file $PID_FILE, and then retry"
      exit
  fi
  trap "rm -f -- '$PID_FILE'" EXIT
  echo $$ > "$PID_FILE"

  # Set the STATE_FILE variable and source the state file
  if test -f $STATE_FILE; then
    source $STATE_FILE
  fi
}


# provisioning-helper-pre-destroy()
#
# First thing to run in every executed destroy function
#   Sets the MY_STATE variables
#   Finds and sets the MY_CODE variable
#   Checks and sets PID file so only one instance can be running
#   Exits it the destroy has already been done (state file does not exist)
#   Sets the STATE_FILE variable and sources the file
#   Removes the output file to begin the destroy process
#
function provisioning-helper-pre-destroy() {
  set -e
  
  MY_STATE=$PWD
  OUTPUT_FILE=$MY_STATE/output.env
  STATE_FILE=$MY_STATE/state.env

  # Locate my code
  MY_CODE_FILE=$MY_STATE/MY_CODE
  if ! test -f "$MY_CODE_FILE"; then
    echo "ERROR: Invalid state directory.  $MY_CODE_FILE does not exist."
    exit 1
  fi
  MY_CODE=$(<$MY_CODE_FILE)

  # Prevent parallel execution
  PID_FILE=$MY_STATE/PID
  if test -f $PID_FILE && ps -fp $(<$PID_FILE); then
      echo "A script is already running against ${MY_STATE}."
      echo "If you want to run an operation on it, kill process $(cat $PID_FILE), delete the file $PID_FILE, and then retry"
      exit
  fi
  trap "rm -f -- '$PID_FILE'" EXIT
  echo $$ > "$PID_FILE"

  # Source the state file
  if test -f $STATE_FILE; then
    source $STATE_FILE
  fi

  # Remove the output file to start the destroy process
  rm -f $OUTPUT_FILE
}


export -f provisioning-apply
export -f provisioning-destroy
export -f provisioning-helper-pre-apply
export -f provisioning-helper-pre-destroy
