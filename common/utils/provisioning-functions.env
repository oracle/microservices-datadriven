#!/bin/bash
# Copyright (c) 2021 Oracle and/or its affiliates.
# Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl.

# All functions assume the current directory is to contain the state of the thing to be provisioned or contains
# the state of the thing to be worked on.

if ! (return 0 2>/dev/null); then
  echo "ERROR: Usage 'source provisioning_functions.env'"
  return 1
fi

# provisioning-apply()
#   Provision something.  Current directory is to be used to store the state.
#   $1: The code home of the thing to be provisioned (required)
#
#   Checks and creates the MY_CODE file
#   Validates the required input parameters, constructs the state file, and removes the input file, and executes apply.sh (except for BYO)
#   Validates the output file (including BYO)
#
function provisioning-apply() {
  local MY_STATE=$PWD
  local OUTPUT_FILE=$MY_STATE/output.env
  local STATE_FILE=$MY_STATE/state.env
  local INPUT_FILE=$MY_STATE/input.env
  local PID_FILE=$MY_STATE/PID
  local MY_CODE="$1"
  local MY_CODE_FILE=$MY_STATE/MY_CODE
  local REQ_UTILS REQ_INPUT_PARAMS REQ_OUTPUT_PARAMS
  local REQ_FILE=$MY_CODE/requirements.env
  local MY_PHASE_FILE=$MY_STATE/PROVISIONING_PHASE
 
  # Prevent parallel execution
  if test -f $PID_FILE; then
    if ps -fp $(<$PID_FILE); then
      echo "A script is already running against ${MY_STATE}."
      echo "If you want to restart an operation on it, kill process $(cat $PID_FILE), delete the file $PID_FILE, and then retry"
      return
    else
      rm -f $PID_FILE
    fi
  fi

  # Locate and check the code home
  if test -f $MY_CODE_FILE && test "$(<$MY_CODE_FILE)" != "$MY_CODE"; then
    echo "ERROR: Code folder $(<$MY_CODE_FILE) already set.  Cannot be changed to $MY_CODE."
    return 1
  fi
  
  if ! test -d $MY_CODE; then
    echo "ERROR: Code folder $MY_CODE does not exist"
    return 1
  fi
  echo "$MY_CODE" > $MY_CODE_FILE
  
  if ! test -f $REQ_FILE; then
    echo "ERROR: Invalid code folder $MY_CODE.  $REQ_FILE is missing."
    return 1
  fi
  source $REQ_FILE

  # Validate required utils TODO
  
  # Populate the state file with input. Skip if the output (already done) or state (reapply) files already exist or if BYO.
  if ! test -f $STATE_FILE && ! test -f $OUTPUT_FILE && ! test -f $MY_STATE/byo; then
    # Not already populated
    if test -z "$REQ_INPUT_PARAMS"; then
      # No required parameters, no input required, empty init state file
      echo "" > $STATE_FILE
    elif ! test -f $INPUT_FILE; then
      # Input file is missing
      echo "$INPUT_FILE is missing"
      return 1
    else
      # Populate init state
      local TEMP_STATE_FILE=$MY_STATE/temp_state.env
      rm -f $TEMP_STATE_FILE
      # Process input file in a subshell with empty env
      if env -i /bin/bash --norc --noprofile; then
        # If successful then make it permanent
        mv $TEMP_STATE_FILE $STATE_FILE
      else
        return 1
      fi  <<!
source $INPUT_FILE
REQ_INPUT_PARAMS='$REQ_INPUT_PARAMS'
for p in \$REQ_INPUT_PARAMS; do
  if test -z "\${!p}"; then
    echo "ERROR: Input parameter \$p is required and not set"
    exit 1
  fi
  echo "\$p='\${!p}'" >>$TEMP_STATE_FILE
done
!
      # Done with the input file so remove it
      rm -f $INPUT_FILE
    fi
  fi
   
  # Execute the apply.sh.  Skip if the output file exists (already done) or BYO.
  if test -f $MY_CODE/apply.sh; then
    if ! test -f $OUTPUT_FILE && ! test -f $MY_STATE/byo; then
      cd $MY_STATE
      echo "Beginning $MY_CODE/apply.sh on $MY_STATE"
      echo "applying" >$MY_PHASE_FILE
      $MY_CODE/apply.sh
    fi
  else
    echo "ERROR: No apply script in code folder $MY_CODE"
    return 1
  fi
  cd $MY_STATE

  # Check for success
  if ! test -f $OUTPUT_FILE; then
    # We are done but no output file, so looks like we failed
    echo "ERROR: Provisioning-apply failed for code $MY_CODE in state folder $MY_STATE.  No output file. "
    return 1
  fi

  # Validate the output
  if ! env -i /bin/bash --norc --noprofile; then
    # Missing output parameter
    return 1
  fi <<!
source $OUTPUT_FILE
REQ_OUTPUT_PARAMS='$REQ_OUTPUT_PARAMS'
for p in \$REQ_OUTPUT_PARAMS; do
  if test -z "\${!p}"; then
    echo "ERROR: Output parameter \$p is required and not set"
    exit 1
  fi
done
!
 
  echo "applied" >$MY_PHASE_FILE
  echo "Completed $MY_CODE/apply.sh on $MY_STATE"
}


# provisioning-destroy()
#   Destroy something previsouly provisioned.
#   Current directory contains the state of the thing to be destroyed.  
#   The MY_CODE file within the state folder contains the location of the code (from previously run apply).
#
#   If the byo file exists then do nothing
#   Checks the MY_CODE file
#   Executes destroy.sh
#

function provisioning-destroy() {
  local MY_STATE=$PWD
  local STATE_FILE=$MY_STATE/state.env
  local OUTPUT_FILE=$MY_STATE/output.env
  local PID_FILE=$MY_STATE/PID
  local MY_CODE_FILE=$MY_STATE/MY_CODE
  local MY_PHASE_FILE=$MY_STATE/PROVISIONING_PHASE

  # Prevent parallel execution
  if test -f $PID_FILE; then
    if ps -fp $(<$PID_FILE); then
      echo "A script is already running against ${MY_STATE}."
      echo "If you want to restart an operation on it, kill process $(cat $PID_FILE), delete the file $PID_FILE, and then retry"
      return
    else
      rm -f $PID_FILE
    fi
  fi

  # If no state file we are already done or nothing to do if BYO
  if ! test -f $STATE_FILE || test -f $MY_STATE/byo; then
    return
  fi

  # Find my code
  if ! test -f $MY_CODE_FILE; then
    echo "No $MY_CODE_FILE is missing.  Cannot destroy what has never been created."
    return 1
  fi
  local MY_CODE=$(<$MY_CODE_FILE)

  if ! test -d $MY_CODE; then
    echo "ERROR: Code folder $MY_CODE does not exist"
    return 1
  fi

  if ! test -f $MY_CODE/destroy.sh; then
    echo "ERROR: No destroy script in code folder $MY_CODE"
    return 1
  fi
  
  # Remove the output file
  rm -f $OUTPUT_FILE
  
  # Execute destroy.sh
  cd $MY_STATE
  echo "Beginning $MY_CODE/destroy.sh on $MY_STATE"
  echo "destroying" >$MY_PHASE_FILE
  $MY_CODE/destroy.sh
  cd $MY_STATE

  # Check if we were successful
  if test -f $STATE_FILE; then
    # We ran destroy and the state file still exists, so looks like we failed
    echo "ERROR: Provisioning destroy failed for code $MY_CODE in state folder $MY_STATE. State file still exists."
    return 1
  fi

  echo "Completed $MY_CODE/destroy.sh on $MY_STATE"
  echo "destroyed" >$MY_PHASE_FILE
}


# provisioning-helper-pre-apply()
#
# First thing to run in every executed apply function
#   Sets the MY_STATE, STATE_FILE and OUTPUT_FILE variables
#   Sets the MY_CODE variable
#   Sets PID file so only one instance can be running
#   Sources the state file
#
function provisioning-helper-pre-apply() {
  MY_STATE=$PWD
  OUTPUT_FILE=$MY_STATE/output.env
  STATE_FILE=$MY_STATE/state.env
  PID_FILE=$MY_STATE/PID
  MY_CODE_FILE=$MY_STATE/MY_CODE

  # Locate my code
  MY_CODE=$(<$MY_CODE_FILE)

  # Prevent parallel execution
  trap "rm -f -- '$PID_FILE'" EXIT
  echo $$ > "$PID_FILE"

  source $STATE_FILE
}


# provisioning-helper-pre-destroy()
#
# First thing to run in every executed destroy function
#   Sets the MY_STATE variable
#   Finds and sets the MY_CODE variable
#   Sets PID file so only one instance can be running
#   Sources the state file
#
function provisioning-helper-pre-destroy() {
  set -e
  
  MY_STATE=$PWD
  STATE_FILE=$MY_STATE/state.env
  PID_FILE=$MY_STATE/PID
  MY_CODE_FILE=$MY_STATE/MY_CODE

  # Locate my code
  MY_CODE=$(<$MY_CODE_FILE)

  # Prevent parallel execution
  trap "rm -f -- '$PID_FILE'" EXIT
  echo $$ > "$PID_FILE"

  source $STATE_FILE
}


export -f provisioning-apply
export -f provisioning-destroy
export -f provisioning-helper-pre-apply
export -f provisioning-helper-pre-destroy